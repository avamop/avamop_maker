import * as React from "react";
import React__default, { createContext, useContext, useRef, useEffect, forwardRef, useState, useLayoutEffect } from "react";
var jsxRuntime = { exports: {} }, reactJsxRuntime_development = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_development;
function requireReactJsxRuntime_development() {
  return hasRequiredReactJsxRuntime_development || (hasRequiredReactJsxRuntime_development = 1, process.env.NODE_ENV !== "production" && function() {
    var d = React__default, l = Symbol.for("react.element"), s = Symbol.for("react.portal"), e = Symbol.for("react.fragment"), f = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), t = Symbol.for("react.context"), r = Symbol.for("react.forward_ref"), o = Symbol.for("react.suspense"), n = Symbol.for("react.suspense_list"), u = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), v = Symbol.iterator, x = "@@iterator";
    function b(Se) {
      if (Se === null || typeof Se != "object")
        return null;
      var Ye = v && Se[v] || Se[x];
      return typeof Ye == "function" ? Ye : null;
    }
    var w = d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function M(Se) {
      {
        for (var Ye = arguments.length, Ke = new Array(Ye > 1 ? Ye - 1 : 0), ut = 1; ut < Ye; ut++)
          Ke[ut - 1] = arguments[ut];
        G("error", Se, Ke);
      }
    }
    function G(Se, Ye, Ke) {
      {
        var ut = w.ReactDebugCurrentFrame, bt = ut.getStackAddendum();
        bt !== "" && (Ye += "%s", Ke = Ke.concat([bt]));
        var At = Ke.map(function(Ct) {
          return String(Ct);
        });
        At.unshift("Warning: " + Ye), Function.prototype.apply.call(console[Se], console, At);
      }
    }
    var F = !1, V = !1, q = !1, I = !1, _ = !1, R;
    R = Symbol.for("react.module.reference");
    function W(Se) {
      return !!(typeof Se == "string" || typeof Se == "function" || Se === e || Se === i || _ || Se === f || Se === o || Se === n || I || Se === g || F || V || q || typeof Se == "object" && Se !== null && (Se.$$typeof === p || Se.$$typeof === u || Se.$$typeof === a || Se.$$typeof === t || Se.$$typeof === r || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      Se.$$typeof === R || Se.getModuleId !== void 0));
    }
    function O(Se, Ye, Ke) {
      var ut = Se.displayName;
      if (ut)
        return ut;
      var bt = Ye.displayName || Ye.name || "";
      return bt !== "" ? Ke + "(" + bt + ")" : Ke;
    }
    function j(Se) {
      return Se.displayName || "Context";
    }
    function U(Se) {
      if (Se == null)
        return null;
      if (typeof Se.tag == "number" && M("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof Se == "function")
        return Se.displayName || Se.name || null;
      if (typeof Se == "string")
        return Se;
      switch (Se) {
        case e:
          return "Fragment";
        case s:
          return "Portal";
        case i:
          return "Profiler";
        case f:
          return "StrictMode";
        case o:
          return "Suspense";
        case n:
          return "SuspenseList";
      }
      if (typeof Se == "object")
        switch (Se.$$typeof) {
          case t:
            var Ye = Se;
            return j(Ye) + ".Consumer";
          case a:
            var Ke = Se;
            return j(Ke._context) + ".Provider";
          case r:
            return O(Se, Se.render, "ForwardRef");
          case u:
            var ut = Se.displayName || null;
            return ut !== null ? ut : U(Se.type) || "Memo";
          case p: {
            var bt = Se, At = bt._payload, Ct = bt._init;
            try {
              return U(Ct(At));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var C = Object.assign, ae = 0, J, te, $, L, re, z, N;
    function ne() {
    }
    ne.__reactDisabledLog = !0;
    function le() {
      {
        if (ae === 0) {
          J = console.log, te = console.info, $ = console.warn, L = console.error, re = console.group, z = console.groupCollapsed, N = console.groupEnd;
          var Se = {
            configurable: !0,
            enumerable: !0,
            value: ne,
            writable: !0
          };
          Object.defineProperties(console, {
            info: Se,
            log: Se,
            warn: Se,
            error: Se,
            group: Se,
            groupCollapsed: Se,
            groupEnd: Se
          });
        }
        ae++;
      }
    }
    function he() {
      {
        if (ae--, ae === 0) {
          var Se = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: C({}, Se, {
              value: J
            }),
            info: C({}, Se, {
              value: te
            }),
            warn: C({}, Se, {
              value: $
            }),
            error: C({}, Se, {
              value: L
            }),
            group: C({}, Se, {
              value: re
            }),
            groupCollapsed: C({}, Se, {
              value: z
            }),
            groupEnd: C({}, Se, {
              value: N
            })
          });
        }
        ae < 0 && M("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var k = w.ReactCurrentDispatcher, T;
    function B(Se, Ye, Ke) {
      {
        if (T === void 0)
          try {
            throw Error();
          } catch (bt) {
            var ut = bt.stack.trim().match(/\n( *(at )?)/);
            T = ut && ut[1] || "";
          }
        return `
` + T + Se;
      }
    }
    var K = !1, h;
    {
      var c = typeof WeakMap == "function" ? WeakMap : Map;
      h = new c();
    }
    function m(Se, Ye) {
      if (!Se || K)
        return "";
      {
        var Ke = h.get(Se);
        if (Ke !== void 0)
          return Ke;
      }
      var ut;
      K = !0;
      var bt = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var At;
      At = k.current, k.current = null, le();
      try {
        if (Ye) {
          var Ct = function() {
            throw Error();
          };
          if (Object.defineProperty(Ct.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(Ct, []);
            } catch (Xt) {
              ut = Xt;
            }
            Reflect.construct(Se, [], Ct);
          } else {
            try {
              Ct.call();
            } catch (Xt) {
              ut = Xt;
            }
            Se.call(Ct.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Xt) {
            ut = Xt;
          }
          Se();
        }
      } catch (Xt) {
        if (Xt && ut && typeof Xt.stack == "string") {
          for (var vt = Xt.stack.split(`
`), Dt = ut.stack.split(`
`), Nt = vt.length - 1, Ut = Dt.length - 1; Nt >= 1 && Ut >= 0 && vt[Nt] !== Dt[Ut]; )
            Ut--;
          for (; Nt >= 1 && Ut >= 0; Nt--, Ut--)
            if (vt[Nt] !== Dt[Ut]) {
              if (Nt !== 1 || Ut !== 1)
                do
                  if (Nt--, Ut--, Ut < 0 || vt[Nt] !== Dt[Ut]) {
                    var Gt = `
` + vt[Nt].replace(" at new ", " at ");
                    return Se.displayName && Gt.includes("<anonymous>") && (Gt = Gt.replace("<anonymous>", Se.displayName)), typeof Se == "function" && h.set(Se, Gt), Gt;
                  }
                while (Nt >= 1 && Ut >= 0);
              break;
            }
        }
      } finally {
        K = !1, k.current = At, he(), Error.prepareStackTrace = bt;
      }
      var Jt = Se ? Se.displayName || Se.name : "", er = Jt ? B(Jt) : "";
      return typeof Se == "function" && h.set(Se, er), er;
    }
    function D(Se, Ye, Ke) {
      return m(Se, !1);
    }
    function ee(Se) {
      var Ye = Se.prototype;
      return !!(Ye && Ye.isReactComponent);
    }
    function E(Se, Ye, Ke) {
      if (Se == null)
        return "";
      if (typeof Se == "function")
        return m(Se, ee(Se));
      if (typeof Se == "string")
        return B(Se);
      switch (Se) {
        case o:
          return B("Suspense");
        case n:
          return B("SuspenseList");
      }
      if (typeof Se == "object")
        switch (Se.$$typeof) {
          case r:
            return D(Se.render);
          case u:
            return E(Se.type, Ye, Ke);
          case p: {
            var ut = Se, bt = ut._payload, At = ut._init;
            try {
              return E(At(bt), Ye, Ke);
            } catch {
            }
          }
        }
      return "";
    }
    var Q = Object.prototype.hasOwnProperty, se = {}, Y = w.ReactDebugCurrentFrame;
    function be(Se) {
      if (Se) {
        var Ye = Se._owner, Ke = E(Se.type, Se._source, Ye ? Ye.type : null);
        Y.setExtraStackFrame(Ke);
      } else
        Y.setExtraStackFrame(null);
    }
    function Ee(Se, Ye, Ke, ut, bt) {
      {
        var At = Function.call.bind(Q);
        for (var Ct in Se)
          if (At(Se, Ct)) {
            var vt = void 0;
            try {
              if (typeof Se[Ct] != "function") {
                var Dt = Error((ut || "React class") + ": " + Ke + " type `" + Ct + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof Se[Ct] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Dt.name = "Invariant Violation", Dt;
              }
              vt = Se[Ct](Ye, Ct, ut, Ke, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Nt) {
              vt = Nt;
            }
            vt && !(vt instanceof Error) && (be(bt), M("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ut || "React class", Ke, Ct, typeof vt), be(null)), vt instanceof Error && !(vt.message in se) && (se[vt.message] = !0, be(bt), M("Failed %s type: %s", Ke, vt.message), be(null));
          }
      }
    }
    var Me = Array.isArray;
    function ke(Se) {
      return Me(Se);
    }
    function oe(Se) {
      {
        var Ye = typeof Symbol == "function" && Symbol.toStringTag, Ke = Ye && Se[Symbol.toStringTag] || Se.constructor.name || "Object";
        return Ke;
      }
    }
    function ce(Se) {
      try {
        return xe(Se), !1;
      } catch {
        return !0;
      }
    }
    function xe(Se) {
      return "" + Se;
    }
    function Ce(Se) {
      if (ce(Se))
        return M("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", oe(Se)), xe(Se);
    }
    var _e = w.ReactCurrentOwner, Be = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Pe, Fe, We;
    We = {};
    function Qe(Se) {
      if (Q.call(Se, "ref")) {
        var Ye = Object.getOwnPropertyDescriptor(Se, "ref").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return Se.ref !== void 0;
    }
    function lt(Se) {
      if (Q.call(Se, "key")) {
        var Ye = Object.getOwnPropertyDescriptor(Se, "key").get;
        if (Ye && Ye.isReactWarning)
          return !1;
      }
      return Se.key !== void 0;
    }
    function P(Se, Ye) {
      if (typeof Se.ref == "string" && _e.current && Ye && _e.current.stateNode !== Ye) {
        var Ke = U(_e.current.type);
        We[Ke] || (M('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(_e.current.type), Se.ref), We[Ke] = !0);
      }
    }
    function we(Se, Ye) {
      {
        var Ke = function() {
          Pe || (Pe = !0, M("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        Ke.isReactWarning = !0, Object.defineProperty(Se, "key", {
          get: Ke,
          configurable: !0
        });
      }
    }
    function X(Se, Ye) {
      {
        var Ke = function() {
          Fe || (Fe = !0, M("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", Ye));
        };
        Ke.isReactWarning = !0, Object.defineProperty(Se, "ref", {
          get: Ke,
          configurable: !0
        });
      }
    }
    var de = function(Se, Ye, Ke, ut, bt, At, Ct) {
      var vt = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: l,
        // Built-in properties that belong on the element
        type: Se,
        key: Ye,
        ref: Ke,
        props: Ct,
        // Record the component responsible for creating this element.
        _owner: At
      };
      return vt._store = {}, Object.defineProperty(vt._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(vt, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ut
      }), Object.defineProperty(vt, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: bt
      }), Object.freeze && (Object.freeze(vt.props), Object.freeze(vt)), vt;
    };
    function Ze(Se, Ye, Ke, ut, bt) {
      {
        var At, Ct = {}, vt = null, Dt = null;
        Ke !== void 0 && (Ce(Ke), vt = "" + Ke), lt(Ye) && (Ce(Ye.key), vt = "" + Ye.key), Qe(Ye) && (Dt = Ye.ref, P(Ye, bt));
        for (At in Ye)
          Q.call(Ye, At) && !Be.hasOwnProperty(At) && (Ct[At] = Ye[At]);
        if (Se && Se.defaultProps) {
          var Nt = Se.defaultProps;
          for (At in Nt)
            Ct[At] === void 0 && (Ct[At] = Nt[At]);
        }
        if (vt || Dt) {
          var Ut = typeof Se == "function" ? Se.displayName || Se.name || "Unknown" : Se;
          vt && we(Ct, Ut), Dt && X(Ct, Ut);
        }
        return de(Se, vt, Dt, bt, ut, _e.current, Ct);
      }
    }
    var Re = w.ReactCurrentOwner, rt = w.ReactDebugCurrentFrame;
    function De(Se) {
      if (Se) {
        var Ye = Se._owner, Ke = E(Se.type, Se._source, Ye ? Ye.type : null);
        rt.setExtraStackFrame(Ke);
      } else
        rt.setExtraStackFrame(null);
    }
    var Je;
    Je = !1;
    function Ne(Se) {
      return typeof Se == "object" && Se !== null && Se.$$typeof === l;
    }
    function Ie() {
      {
        if (Re.current) {
          var Se = U(Re.current.type);
          if (Se)
            return `

Check the render method of \`` + Se + "`.";
        }
        return "";
      }
    }
    function at(Se) {
      {
        if (Se !== void 0) {
          var Ye = Se.fileName.replace(/^.*[\\\/]/, ""), Ke = Se.lineNumber;
          return `

Check your code at ` + Ye + ":" + Ke + ".";
        }
        return "";
      }
    }
    var st = {};
    function tt(Se) {
      {
        var Ye = Ie();
        if (!Ye) {
          var Ke = typeof Se == "string" ? Se : Se.displayName || Se.name;
          Ke && (Ye = `

Check the top-level render call using <` + Ke + ">.");
        }
        return Ye;
      }
    }
    function mt(Se, Ye) {
      {
        if (!Se._store || Se._store.validated || Se.key != null)
          return;
        Se._store.validated = !0;
        var Ke = tt(Ye);
        if (st[Ke])
          return;
        st[Ke] = !0;
        var ut = "";
        Se && Se._owner && Se._owner !== Re.current && (ut = " It was passed a child from " + U(Se._owner.type) + "."), De(Se), M('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', Ke, ut), De(null);
      }
    }
    function It(Se, Ye) {
      {
        if (typeof Se != "object")
          return;
        if (ke(Se))
          for (var Ke = 0; Ke < Se.length; Ke++) {
            var ut = Se[Ke];
            Ne(ut) && mt(ut, Ye);
          }
        else if (Ne(Se))
          Se._store && (Se._store.validated = !0);
        else if (Se) {
          var bt = b(Se);
          if (typeof bt == "function" && bt !== Se.entries)
            for (var At = bt.call(Se), Ct; !(Ct = At.next()).done; )
              Ne(Ct.value) && mt(Ct.value, Ye);
        }
      }
    }
    function wt(Se) {
      {
        var Ye = Se.type;
        if (Ye == null || typeof Ye == "string")
          return;
        var Ke;
        if (typeof Ye == "function")
          Ke = Ye.propTypes;
        else if (typeof Ye == "object" && (Ye.$$typeof === r || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        Ye.$$typeof === u))
          Ke = Ye.propTypes;
        else
          return;
        if (Ke) {
          var ut = U(Ye);
          Ee(Ke, Se.props, "prop", ut, Se);
        } else if (Ye.PropTypes !== void 0 && !Je) {
          Je = !0;
          var bt = U(Ye);
          M("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", bt || "Unknown");
        }
        typeof Ye.getDefaultProps == "function" && !Ye.getDefaultProps.isReactClassApproved && M("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function ot(Se) {
      {
        for (var Ye = Object.keys(Se.props), Ke = 0; Ke < Ye.length; Ke++) {
          var ut = Ye[Ke];
          if (ut !== "children" && ut !== "key") {
            De(Se), M("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ut), De(null);
            break;
          }
        }
        Se.ref !== null && (De(Se), M("Invalid attribute `ref` supplied to `React.Fragment`."), De(null));
      }
    }
    function kt(Se, Ye, Ke, ut, bt, At) {
      {
        var Ct = W(Se);
        if (!Ct) {
          var vt = "";
          (Se === void 0 || typeof Se == "object" && Se !== null && Object.keys(Se).length === 0) && (vt += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Dt = at(bt);
          Dt ? vt += Dt : vt += Ie();
          var Nt;
          Se === null ? Nt = "null" : ke(Se) ? Nt = "array" : Se !== void 0 && Se.$$typeof === l ? (Nt = "<" + (U(Se.type) || "Unknown") + " />", vt = " Did you accidentally export a JSX literal instead of a component?") : Nt = typeof Se, M("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Nt, vt);
        }
        var Ut = Ze(Se, Ye, Ke, bt, At);
        if (Ut == null)
          return Ut;
        if (Ct) {
          var Gt = Ye.children;
          if (Gt !== void 0)
            if (ut)
              if (ke(Gt)) {
                for (var Jt = 0; Jt < Gt.length; Jt++)
                  It(Gt[Jt], Se);
                Object.freeze && Object.freeze(Gt);
              } else
                M("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              It(Gt, Se);
        }
        return Se === e ? ot(Ut) : wt(Ut), Ut;
      }
    }
    function Ft(Se, Ye, Ke) {
      return kt(Se, Ye, Ke, !0);
    }
    function Rt(Se, Ye, Ke) {
      return kt(Se, Ye, Ke, !1);
    }
    var qt = Rt, Lt = Ft;
    reactJsxRuntime_development.Fragment = e, reactJsxRuntime_development.jsx = qt, reactJsxRuntime_development.jsxs = Lt;
  }()), reactJsxRuntime_development;
}
var reactJsxRuntime_production_min = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var hasRequiredReactJsxRuntime_production_min;
function requireReactJsxRuntime_production_min() {
  if (hasRequiredReactJsxRuntime_production_min)
    return reactJsxRuntime_production_min;
  hasRequiredReactJsxRuntime_production_min = 1;
  var d = React__default, l = Symbol.for("react.element"), s = Symbol.for("react.fragment"), e = Object.prototype.hasOwnProperty, f = d.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(t, r, o) {
    var n, u = {}, p = null, g = null;
    o !== void 0 && (p = "" + o), r.key !== void 0 && (p = "" + r.key), r.ref !== void 0 && (g = r.ref);
    for (n in r)
      e.call(r, n) && !i.hasOwnProperty(n) && (u[n] = r[n]);
    if (t && t.defaultProps)
      for (n in r = t.defaultProps, r)
        u[n] === void 0 && (u[n] = r[n]);
    return { $$typeof: l, type: t, key: p, ref: g, props: u, _owner: f.current };
  }
  return reactJsxRuntime_production_min.Fragment = s, reactJsxRuntime_production_min.jsx = a, reactJsxRuntime_production_min.jsxs = a, reactJsxRuntime_production_min;
}
process.env.NODE_ENV === "production" ? jsxRuntime.exports = requireReactJsxRuntime_production_min() : jsxRuntime.exports = requireReactJsxRuntime_development();
var jsxRuntimeExports = jsxRuntime.exports;
const avatarImgAll = "_avatarImgAll_46r89_1", bottomButton = "_bottomButton_46r89_5", allObjectContainer = "_allObjectContainer_46r89_22", optionMenuGroup = "_optionMenuGroup_46r89_25", MakerWindow_module = {
  avatarImgAll,
  bottomButton,
  allObjectContainer,
  optionMenuGroup
};
/*! For license information please see jimp.js.LICENSE.txt */
(() => {
  var __webpack_modules__ = { 236: (d, l, s) => {
    var e = s(4618);
    function f(i, a) {
      var t = new e(i, a);
      return function(r) {
        return t.convert(r);
      };
    }
    f.BIN = "01", f.OCT = "01234567", f.DEC = "0123456789", f.HEX = "0123456789abcdef", d.exports = f;
  }, 4618: (d) => {
    function l(s, e) {
      if (!(s && e && s.length && e.length))
        throw new Error("Bad alphabet");
      this.srcAlphabet = s, this.dstAlphabet = e;
    }
    l.prototype.convert = function(s) {
      var e, f, i, a = {}, t = this.srcAlphabet.length, r = this.dstAlphabet.length, o = s.length, n = typeof s == "string" ? "" : [];
      if (!this.isValid(s))
        throw new Error('Number "' + s + '" contains of non-alphabetic digits (' + this.srcAlphabet + ")");
      if (this.srcAlphabet === this.dstAlphabet)
        return s;
      for (e = 0; e < o; e++)
        a[e] = this.srcAlphabet.indexOf(s[e]);
      do {
        for (f = 0, i = 0, e = 0; e < o; e++)
          (f = f * t + a[e]) >= r ? (a[i++] = parseInt(f / r, 10), f %= r) : i > 0 && (a[i++] = 0);
        o = i, n = this.dstAlphabet.slice(f, f + 1).concat(n);
      } while (i !== 0);
      return n;
    }, l.prototype.isValid = function(s) {
      for (var e = 0; e < s.length; ++e)
        if (this.srcAlphabet.indexOf(s[e]) === -1)
          return !1;
      return !0;
    }, d.exports = l;
  }, 5766: (d, l) => {
    l.byteLength = function(n) {
      var u = r(n), p = u[0], g = u[1];
      return 3 * (p + g) / 4 - g;
    }, l.toByteArray = function(n) {
      var u, p, g = r(n), v = g[0], x = g[1], b = new f(function(G, F, V) {
        return 3 * (F + V) / 4 - V;
      }(0, v, x)), w = 0, M = x > 0 ? v - 4 : v;
      for (p = 0; p < M; p += 4)
        u = e[n.charCodeAt(p)] << 18 | e[n.charCodeAt(p + 1)] << 12 | e[n.charCodeAt(p + 2)] << 6 | e[n.charCodeAt(p + 3)], b[w++] = u >> 16 & 255, b[w++] = u >> 8 & 255, b[w++] = 255 & u;
      return x === 2 && (u = e[n.charCodeAt(p)] << 2 | e[n.charCodeAt(p + 1)] >> 4, b[w++] = 255 & u), x === 1 && (u = e[n.charCodeAt(p)] << 10 | e[n.charCodeAt(p + 1)] << 4 | e[n.charCodeAt(p + 2)] >> 2, b[w++] = u >> 8 & 255, b[w++] = 255 & u), b;
    }, l.fromByteArray = function(n) {
      for (var u, p = n.length, g = p % 3, v = [], x = 16383, b = 0, w = p - g; b < w; b += x)
        v.push(o(n, b, b + x > w ? w : b + x));
      return g === 1 ? (u = n[p - 1], v.push(s[u >> 2] + s[u << 4 & 63] + "==")) : g === 2 && (u = (n[p - 2] << 8) + n[p - 1], v.push(s[u >> 10] + s[u >> 4 & 63] + s[u << 2 & 63] + "=")), v.join("");
    };
    for (var s = [], e = [], f = typeof Uint8Array < "u" ? Uint8Array : Array, i = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", a = 0, t = i.length; a < t; ++a)
      s[a] = i[a], e[i.charCodeAt(a)] = a;
    function r(n) {
      var u = n.length;
      if (u % 4 > 0)
        throw new Error("Invalid string. Length must be a multiple of 4");
      var p = n.indexOf("=");
      return p === -1 && (p = u), [p, p === u ? 0 : 4 - p % 4];
    }
    function o(n, u, p) {
      for (var g, v, x = [], b = u; b < p; b += 3)
        g = (n[b] << 16 & 16711680) + (n[b + 1] << 8 & 65280) + (255 & n[b + 2]), x.push(s[(v = g) >> 18 & 63] + s[v >> 12 & 63] + s[v >> 6 & 63] + s[63 & v]);
      return x.join("");
    }
    e["-".charCodeAt(0)] = 62, e["_".charCodeAt(0)] = 63;
  }, 486: (d, l, s) => {
    var e = s(5433), f = s(1651);
    d.exports = { encode: e, decode: f };
  }, 1651: (d, l, s) => {
    var e = s(8834).lW;
    function f(i, a) {
      if (this.pos = 0, this.buffer = i, this.is_with_alpha = !!a, this.bottom_up = !0, this.flag = this.buffer.toString("utf-8", 0, this.pos += 2), this.flag != "BM")
        throw new Error("Invalid BMP File");
      this.parseHeader(), this.parseRGBA();
    }
    f.prototype.parseHeader = function() {
      if (this.fileSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.reserved = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.offset = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.headerSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.width = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.height = this.buffer.readInt32LE(this.pos), this.pos += 4, this.planes = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.bitPP = this.buffer.readUInt16LE(this.pos), this.pos += 2, this.compress = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.rawSize = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.hr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.vr = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.colors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.importantColors = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.bitPP === 16 && this.is_with_alpha && (this.bitPP = 15), this.bitPP < 15) {
        var i = this.colors === 0 ? 1 << this.bitPP : this.colors;
        this.palette = new Array(i);
        for (var a = 0; a < i; a++) {
          var t = this.buffer.readUInt8(this.pos++), r = this.buffer.readUInt8(this.pos++), o = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++);
          this.palette[a] = { red: o, green: r, blue: t, quad: n };
        }
      }
      this.height < 0 && (this.height *= -1, this.bottom_up = !1);
    }, f.prototype.parseRGBA = function() {
      var i = "bit" + this.bitPP, a = this.width * this.height * 4;
      this.data = new e(a), this[i]();
    }, f.prototype.bit1 = function() {
      var i = Math.ceil(this.width / 8), a = i % 4, t = this.height >= 0 ? this.height - 1 : -this.height;
      for (t = this.height - 1; t >= 0; t--) {
        for (var r = this.bottom_up ? t : this.height - 1 - t, o = 0; o < i; o++)
          for (var n = this.buffer.readUInt8(this.pos++), u = r * this.width * 4 + 8 * o * 4, p = 0; p < 8 && 8 * o + p < this.width; p++) {
            var g = this.palette[n >> 7 - p & 1];
            this.data[u + 4 * p] = 0, this.data[u + 4 * p + 1] = g.blue, this.data[u + 4 * p + 2] = g.green, this.data[u + 4 * p + 3] = g.red;
          }
        a != 0 && (this.pos += 4 - a);
      }
    }, f.prototype.bit4 = function() {
      if (this.compress == 2) {
        let F = function(V) {
          var q = this.palette[V];
          this.data[i] = 0, this.data[i + 1] = q.blue, this.data[i + 2] = q.green, this.data[i + 3] = q.red, i += 4;
        };
        this.data.fill(255);
        for (var i = 0, a = this.bottom_up ? this.height - 1 : 0, t = !1; i < this.data.length; ) {
          var r = this.buffer.readUInt8(this.pos++), o = this.buffer.readUInt8(this.pos++);
          if (r == 0) {
            if (o == 0) {
              this.bottom_up ? a-- : a++, i = a * this.width * 4, t = !1;
              continue;
            }
            if (o == 1)
              break;
            if (o == 2) {
              var n = this.buffer.readUInt8(this.pos++), u = this.buffer.readUInt8(this.pos++);
              this.bottom_up ? a -= u : a += u, i += u * this.width * 4 + 4 * n;
            } else {
              for (var p = this.buffer.readUInt8(this.pos++), g = 0; g < o; g++)
                t ? F.call(this, 15 & p) : F.call(this, (240 & p) >> 4), 1 & g && g + 1 < o && (p = this.buffer.readUInt8(this.pos++)), t = !t;
              (o + 1 >> 1 & 1) == 1 && this.pos++;
            }
          } else
            for (g = 0; g < r; g++)
              t ? F.call(this, 15 & o) : F.call(this, (240 & o) >> 4), t = !t;
        }
      } else {
        var v = Math.ceil(this.width / 2), x = v % 4;
        for (u = this.height - 1; u >= 0; u--) {
          var b = this.bottom_up ? u : this.height - 1 - u;
          for (n = 0; n < v; n++) {
            o = this.buffer.readUInt8(this.pos++), i = b * this.width * 4 + 2 * n * 4;
            var w = o >> 4, M = 15 & o, G = this.palette[w];
            if (this.data[i] = 0, this.data[i + 1] = G.blue, this.data[i + 2] = G.green, this.data[i + 3] = G.red, 2 * n + 1 >= this.width)
              break;
            G = this.palette[M], this.data[i + 4] = 0, this.data[i + 4 + 1] = G.blue, this.data[i + 4 + 2] = G.green, this.data[i + 4 + 3] = G.red;
          }
          x != 0 && (this.pos += 4 - x);
        }
      }
    }, f.prototype.bit8 = function() {
      if (this.compress == 1) {
        let b = function(w) {
          var M = this.palette[w];
          this.data[i] = 0, this.data[i + 1] = M.blue, this.data[i + 2] = M.green, this.data[i + 3] = M.red, i += 4;
        };
        this.data.fill(255);
        for (var i = 0, a = this.bottom_up ? this.height - 1 : 0; i < this.data.length; ) {
          var t = this.buffer.readUInt8(this.pos++), r = this.buffer.readUInt8(this.pos++);
          if (t == 0) {
            if (r == 0) {
              this.bottom_up ? a-- : a++, i = a * this.width * 4;
              continue;
            }
            if (r == 1)
              break;
            if (r == 2) {
              var o = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++);
              this.bottom_up ? a -= n : a += n, i += n * this.width * 4 + 4 * o;
            } else {
              for (var u = 0; u < r; u++) {
                var p = this.buffer.readUInt8(this.pos++);
                b.call(this, p);
              }
              !0 & r && this.pos++;
            }
          } else
            for (u = 0; u < t; u++)
              b.call(this, r);
        }
      } else {
        var g = this.width % 4;
        for (n = this.height - 1; n >= 0; n--) {
          var v = this.bottom_up ? n : this.height - 1 - n;
          for (o = 0; o < this.width; o++)
            if (r = this.buffer.readUInt8(this.pos++), i = v * this.width * 4 + 4 * o, r < this.palette.length) {
              var x = this.palette[r];
              this.data[i] = 0, this.data[i + 1] = x.blue, this.data[i + 2] = x.green, this.data[i + 3] = x.red;
            } else
              this.data[i] = 0, this.data[i + 1] = 255, this.data[i + 2] = 255, this.data[i + 3] = 255;
          g != 0 && (this.pos += 4 - g);
        }
      }
    }, f.prototype.bit15 = function() {
      for (var i = this.width % 3, a = parseInt("11111", 2), t = this.height - 1; t >= 0; t--) {
        for (var r = this.bottom_up ? t : this.height - 1 - t, o = 0; o < this.width; o++) {
          var n = this.buffer.readUInt16LE(this.pos);
          this.pos += 2;
          var u = (n & a) / a * 255 | 0, p = (n >> 5 & a) / a * 255 | 0, g = (n >> 10 & a) / a * 255 | 0, v = n >> 15 ? 255 : 0, x = r * this.width * 4 + 4 * o;
          this.data[x] = v, this.data[x + 1] = u, this.data[x + 2] = p, this.data[x + 3] = g;
        }
        this.pos += i;
      }
    }, f.prototype.bit16 = function() {
      var i = this.width % 2 * 2;
      this.maskRed = 31744, this.maskGreen = 992, this.maskBlue = 31, this.mask0 = 0, this.compress == 3 && (this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4);
      for (var a = [0, 0, 0], t = 0; t < 16; t++)
        this.maskRed >> t & 1 && a[0]++, this.maskGreen >> t & 1 && a[1]++, this.maskBlue >> t & 1 && a[2]++;
      a[1] += a[0], a[2] += a[1], a[0] = 8 - a[0], a[1] -= 8, a[2] -= 8;
      for (var r = this.height - 1; r >= 0; r--) {
        for (var o = this.bottom_up ? r : this.height - 1 - r, n = 0; n < this.width; n++) {
          var u = this.buffer.readUInt16LE(this.pos);
          this.pos += 2;
          var p = (u & this.maskBlue) << a[0], g = (u & this.maskGreen) >> a[1], v = (u & this.maskRed) >> a[2], x = o * this.width * 4 + 4 * n;
          this.data[x] = 0, this.data[x + 1] = p, this.data[x + 2] = g, this.data[x + 3] = v;
        }
        this.pos += i;
      }
    }, f.prototype.bit24 = function() {
      for (var i = this.height - 1; i >= 0; i--) {
        for (var a = this.bottom_up ? i : this.height - 1 - i, t = 0; t < this.width; t++) {
          var r = this.buffer.readUInt8(this.pos++), o = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++), u = a * this.width * 4 + 4 * t;
          this.data[u] = 0, this.data[u + 1] = r, this.data[u + 2] = o, this.data[u + 3] = n;
        }
        this.pos += this.width % 4;
      }
    }, f.prototype.bit32 = function() {
      if (this.compress == 3) {
        this.maskRed = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskGreen = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.maskBlue = this.buffer.readUInt32LE(this.pos), this.pos += 4, this.mask0 = this.buffer.readUInt32LE(this.pos), this.pos += 4;
        for (var i = this.height - 1; i >= 0; i--)
          for (var a = this.bottom_up ? i : this.height - 1 - i, t = 0; t < this.width; t++) {
            var r = this.buffer.readUInt8(this.pos++), o = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++), u = this.buffer.readUInt8(this.pos++), p = a * this.width * 4 + 4 * t;
            this.data[p] = r, this.data[p + 1] = o, this.data[p + 2] = n, this.data[p + 3] = u;
          }
      } else
        for (i = this.height - 1; i >= 0; i--)
          for (a = this.bottom_up ? i : this.height - 1 - i, t = 0; t < this.width; t++)
            o = this.buffer.readUInt8(this.pos++), n = this.buffer.readUInt8(this.pos++), u = this.buffer.readUInt8(this.pos++), r = this.buffer.readUInt8(this.pos++), p = a * this.width * 4 + 4 * t, this.data[p] = r, this.data[p + 1] = o, this.data[p + 2] = n, this.data[p + 3] = u;
    }, f.prototype.getData = function() {
      return this.data;
    }, d.exports = function(i) {
      return new f(i);
    };
  }, 5433: (d, l, s) => {
    var e = s(8834).lW;
    function f(i) {
      this.buffer = i.data, this.width = i.width, this.height = i.height, this.extraBytes = this.width % 4, this.rgbSize = this.height * (3 * this.width + this.extraBytes), this.headerInfoSize = 40, this.data = [], this.flag = "BM", this.reserved = 0, this.offset = 54, this.fileSize = this.rgbSize + this.offset, this.planes = 1, this.bitPP = 24, this.compress = 0, this.hr = 0, this.vr = 0, this.colors = 0, this.importantColors = 0;
    }
    f.prototype.encode = function() {
      var i = new e(this.offset + this.rgbSize);
      this.pos = 0, i.write(this.flag, this.pos, 2), this.pos += 2, i.writeUInt32LE(this.fileSize, this.pos), this.pos += 4, i.writeUInt32LE(this.reserved, this.pos), this.pos += 4, i.writeUInt32LE(this.offset, this.pos), this.pos += 4, i.writeUInt32LE(this.headerInfoSize, this.pos), this.pos += 4, i.writeUInt32LE(this.width, this.pos), this.pos += 4, i.writeInt32LE(-this.height, this.pos), this.pos += 4, i.writeUInt16LE(this.planes, this.pos), this.pos += 2, i.writeUInt16LE(this.bitPP, this.pos), this.pos += 2, i.writeUInt32LE(this.compress, this.pos), this.pos += 4, i.writeUInt32LE(this.rgbSize, this.pos), this.pos += 4, i.writeUInt32LE(this.hr, this.pos), this.pos += 4, i.writeUInt32LE(this.vr, this.pos), this.pos += 4, i.writeUInt32LE(this.colors, this.pos), this.pos += 4, i.writeUInt32LE(this.importantColors, this.pos), this.pos += 4;
      for (var a = 0, t = 3 * this.width + this.extraBytes, r = 0; r < this.height; r++) {
        for (var o = 0; o < this.width; o++) {
          var n = this.pos + r * t + 3 * o;
          a++, i[n] = this.buffer[a++], i[n + 1] = this.buffer[a++], i[n + 2] = this.buffer[a++];
        }
        if (this.extraBytes > 0) {
          var u = this.pos + r * t + 3 * this.width;
          i.fill(0, u, u + this.extraBytes);
        }
      }
      return i;
    }, d.exports = function(i, a) {
      return { data: new f(i).encode(), width: i.width, height: i.height };
    };
  }, 5137: (d, l, s) => {
    var e = s(8834).lW;
    d.exports = function(f, i) {
      if (e.isBuffer(f) && e.isBuffer(i)) {
        if (typeof f.equals == "function")
          return f.equals(i);
        if (f.length !== i.length)
          return !1;
        for (var a = 0; a < f.length; a++)
          if (f[a] !== i[a])
            return !1;
        return !0;
      }
    };
  }, 8834: (d, l, s) => {
    var e = s(5766), f = s(4181);
    l.lW = t, l.h2 = 50;
    var i = 2147483647;
    function a(k) {
      if (k > i)
        throw new RangeError('The value "' + k + '" is invalid for option "size"');
      var T = new Uint8Array(k);
      return T.__proto__ = t.prototype, T;
    }
    function t(k, T, B) {
      if (typeof k == "number") {
        if (typeof T == "string")
          throw new TypeError('The "string" argument must be of type string. Received type number');
        return n(k);
      }
      return r(k, T, B);
    }
    function r(k, T, B) {
      if (typeof k == "string")
        return function(c, m) {
          if (typeof m == "string" && m !== "" || (m = "utf8"), !t.isEncoding(m))
            throw new TypeError("Unknown encoding: " + m);
          var D = 0 | g(c, m), ee = a(D), E = ee.write(c, m);
          return E !== D && (ee = ee.slice(0, E)), ee;
        }(k, T);
      if (ArrayBuffer.isView(k))
        return u(k);
      if (k == null)
        throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof k);
      if (le(k, ArrayBuffer) || k && le(k.buffer, ArrayBuffer))
        return function(c, m, D) {
          if (m < 0 || c.byteLength < m)
            throw new RangeError('"offset" is outside of buffer bounds');
          if (c.byteLength < m + (D || 0))
            throw new RangeError('"length" is outside of buffer bounds');
          var ee;
          return (ee = m === void 0 && D === void 0 ? new Uint8Array(c) : D === void 0 ? new Uint8Array(c, m) : new Uint8Array(c, m, D)).__proto__ = t.prototype, ee;
        }(k, T, B);
      if (typeof k == "number")
        throw new TypeError('The "value" argument must not be of type number. Received type number');
      var K = k.valueOf && k.valueOf();
      if (K != null && K !== k)
        return t.from(K, T, B);
      var h = function(c) {
        if (t.isBuffer(c)) {
          var m = 0 | p(c.length), D = a(m);
          return D.length === 0 || c.copy(D, 0, 0, m), D;
        }
        return c.length !== void 0 ? typeof c.length != "number" || he(c.length) ? a(0) : u(c) : c.type === "Buffer" && Array.isArray(c.data) ? u(c.data) : void 0;
      }(k);
      if (h)
        return h;
      if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof k[Symbol.toPrimitive] == "function")
        return t.from(k[Symbol.toPrimitive]("string"), T, B);
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof k);
    }
    function o(k) {
      if (typeof k != "number")
        throw new TypeError('"size" argument must be of type number');
      if (k < 0)
        throw new RangeError('The value "' + k + '" is invalid for option "size"');
    }
    function n(k) {
      return o(k), a(k < 0 ? 0 : 0 | p(k));
    }
    function u(k) {
      for (var T = k.length < 0 ? 0 : 0 | p(k.length), B = a(T), K = 0; K < T; K += 1)
        B[K] = 255 & k[K];
      return B;
    }
    function p(k) {
      if (k >= i)
        throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + i.toString(16) + " bytes");
      return 0 | k;
    }
    function g(k, T) {
      if (t.isBuffer(k))
        return k.length;
      if (ArrayBuffer.isView(k) || le(k, ArrayBuffer))
        return k.byteLength;
      if (typeof k != "string")
        throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof k);
      var B = k.length, K = arguments.length > 2 && arguments[2] === !0;
      if (!K && B === 0)
        return 0;
      for (var h = !1; ; )
        switch (T) {
          case "ascii":
          case "latin1":
          case "binary":
            return B;
          case "utf8":
          case "utf-8":
            return z(k).length;
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return 2 * B;
          case "hex":
            return B >>> 1;
          case "base64":
            return N(k).length;
          default:
            if (h)
              return K ? -1 : z(k).length;
            T = ("" + T).toLowerCase(), h = !0;
        }
    }
    function v(k, T, B) {
      var K = !1;
      if ((T === void 0 || T < 0) && (T = 0), T > this.length || ((B === void 0 || B > this.length) && (B = this.length), B <= 0) || (B >>>= 0) <= (T >>>= 0))
        return "";
      for (k || (k = "utf8"); ; )
        switch (k) {
          case "hex":
            return U(this, T, B);
          case "utf8":
          case "utf-8":
            return R(this, T, B);
          case "ascii":
            return O(this, T, B);
          case "latin1":
          case "binary":
            return j(this, T, B);
          case "base64":
            return _(this, T, B);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return C(this, T, B);
          default:
            if (K)
              throw new TypeError("Unknown encoding: " + k);
            k = (k + "").toLowerCase(), K = !0;
        }
    }
    function x(k, T, B) {
      var K = k[T];
      k[T] = k[B], k[B] = K;
    }
    function b(k, T, B, K, h) {
      if (k.length === 0)
        return -1;
      if (typeof B == "string" ? (K = B, B = 0) : B > 2147483647 ? B = 2147483647 : B < -2147483648 && (B = -2147483648), he(B = +B) && (B = h ? 0 : k.length - 1), B < 0 && (B = k.length + B), B >= k.length) {
        if (h)
          return -1;
        B = k.length - 1;
      } else if (B < 0) {
        if (!h)
          return -1;
        B = 0;
      }
      if (typeof T == "string" && (T = t.from(T, K)), t.isBuffer(T))
        return T.length === 0 ? -1 : w(k, T, B, K, h);
      if (typeof T == "number")
        return T &= 255, typeof Uint8Array.prototype.indexOf == "function" ? h ? Uint8Array.prototype.indexOf.call(k, T, B) : Uint8Array.prototype.lastIndexOf.call(k, T, B) : w(k, [T], B, K, h);
      throw new TypeError("val must be string, number or Buffer");
    }
    function w(k, T, B, K, h) {
      var c, m = 1, D = k.length, ee = T.length;
      if (K !== void 0 && ((K = String(K).toLowerCase()) === "ucs2" || K === "ucs-2" || K === "utf16le" || K === "utf-16le")) {
        if (k.length < 2 || T.length < 2)
          return -1;
        m = 2, D /= 2, ee /= 2, B /= 2;
      }
      function E(be, Ee) {
        return m === 1 ? be[Ee] : be.readUInt16BE(Ee * m);
      }
      if (h) {
        var Q = -1;
        for (c = B; c < D; c++)
          if (E(k, c) === E(T, Q === -1 ? 0 : c - Q)) {
            if (Q === -1 && (Q = c), c - Q + 1 === ee)
              return Q * m;
          } else
            Q !== -1 && (c -= c - Q), Q = -1;
      } else
        for (B + ee > D && (B = D - ee), c = B; c >= 0; c--) {
          for (var se = !0, Y = 0; Y < ee; Y++)
            if (E(k, c + Y) !== E(T, Y)) {
              se = !1;
              break;
            }
          if (se)
            return c;
        }
      return -1;
    }
    function M(k, T, B, K) {
      B = Number(B) || 0;
      var h = k.length - B;
      K ? (K = Number(K)) > h && (K = h) : K = h;
      var c = T.length;
      K > c / 2 && (K = c / 2);
      for (var m = 0; m < K; ++m) {
        var D = parseInt(T.substr(2 * m, 2), 16);
        if (he(D))
          return m;
        k[B + m] = D;
      }
      return m;
    }
    function G(k, T, B, K) {
      return ne(z(T, k.length - B), k, B, K);
    }
    function F(k, T, B, K) {
      return ne(function(h) {
        for (var c = [], m = 0; m < h.length; ++m)
          c.push(255 & h.charCodeAt(m));
        return c;
      }(T), k, B, K);
    }
    function V(k, T, B, K) {
      return F(k, T, B, K);
    }
    function q(k, T, B, K) {
      return ne(N(T), k, B, K);
    }
    function I(k, T, B, K) {
      return ne(function(h, c) {
        for (var m, D, ee, E = [], Q = 0; Q < h.length && !((c -= 2) < 0); ++Q)
          D = (m = h.charCodeAt(Q)) >> 8, ee = m % 256, E.push(ee), E.push(D);
        return E;
      }(T, k.length - B), k, B, K);
    }
    function _(k, T, B) {
      return T === 0 && B === k.length ? e.fromByteArray(k) : e.fromByteArray(k.slice(T, B));
    }
    function R(k, T, B) {
      B = Math.min(k.length, B);
      for (var K = [], h = T; h < B; ) {
        var c, m, D, ee, E = k[h], Q = null, se = E > 239 ? 4 : E > 223 ? 3 : E > 191 ? 2 : 1;
        if (h + se <= B)
          switch (se) {
            case 1:
              E < 128 && (Q = E);
              break;
            case 2:
              (192 & (c = k[h + 1])) == 128 && (ee = (31 & E) << 6 | 63 & c) > 127 && (Q = ee);
              break;
            case 3:
              c = k[h + 1], m = k[h + 2], (192 & c) == 128 && (192 & m) == 128 && (ee = (15 & E) << 12 | (63 & c) << 6 | 63 & m) > 2047 && (ee < 55296 || ee > 57343) && (Q = ee);
              break;
            case 4:
              c = k[h + 1], m = k[h + 2], D = k[h + 3], (192 & c) == 128 && (192 & m) == 128 && (192 & D) == 128 && (ee = (15 & E) << 18 | (63 & c) << 12 | (63 & m) << 6 | 63 & D) > 65535 && ee < 1114112 && (Q = ee);
          }
        Q === null ? (Q = 65533, se = 1) : Q > 65535 && (Q -= 65536, K.push(Q >>> 10 & 1023 | 55296), Q = 56320 | 1023 & Q), K.push(Q), h += se;
      }
      return function(Y) {
        var be = Y.length;
        if (be <= W)
          return String.fromCharCode.apply(String, Y);
        for (var Ee = "", Me = 0; Me < be; )
          Ee += String.fromCharCode.apply(String, Y.slice(Me, Me += W));
        return Ee;
      }(K);
    }
    t.TYPED_ARRAY_SUPPORT = function() {
      try {
        var k = new Uint8Array(1);
        return k.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
          return 42;
        } }, k.foo() === 42;
      } catch {
        return !1;
      }
    }(), t.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(t.prototype, "parent", { enumerable: !0, get: function() {
      if (t.isBuffer(this))
        return this.buffer;
    } }), Object.defineProperty(t.prototype, "offset", { enumerable: !0, get: function() {
      if (t.isBuffer(this))
        return this.byteOffset;
    } }), typeof Symbol < "u" && Symbol.species != null && t[Symbol.species] === t && Object.defineProperty(t, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), t.poolSize = 8192, t.from = function(k, T, B) {
      return r(k, T, B);
    }, t.prototype.__proto__ = Uint8Array.prototype, t.__proto__ = Uint8Array, t.alloc = function(k, T, B) {
      return function(K, h, c) {
        return o(K), K <= 0 ? a(K) : h !== void 0 ? typeof c == "string" ? a(K).fill(h, c) : a(K).fill(h) : a(K);
      }(k, T, B);
    }, t.allocUnsafe = function(k) {
      return n(k);
    }, t.allocUnsafeSlow = function(k) {
      return n(k);
    }, t.isBuffer = function(k) {
      return k != null && k._isBuffer === !0 && k !== t.prototype;
    }, t.compare = function(k, T) {
      if (le(k, Uint8Array) && (k = t.from(k, k.offset, k.byteLength)), le(T, Uint8Array) && (T = t.from(T, T.offset, T.byteLength)), !t.isBuffer(k) || !t.isBuffer(T))
        throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
      if (k === T)
        return 0;
      for (var B = k.length, K = T.length, h = 0, c = Math.min(B, K); h < c; ++h)
        if (k[h] !== T[h]) {
          B = k[h], K = T[h];
          break;
        }
      return B < K ? -1 : K < B ? 1 : 0;
    }, t.isEncoding = function(k) {
      switch (String(k).toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "latin1":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return !0;
        default:
          return !1;
      }
    }, t.concat = function(k, T) {
      if (!Array.isArray(k))
        throw new TypeError('"list" argument must be an Array of Buffers');
      if (k.length === 0)
        return t.alloc(0);
      var B;
      if (T === void 0)
        for (T = 0, B = 0; B < k.length; ++B)
          T += k[B].length;
      var K = t.allocUnsafe(T), h = 0;
      for (B = 0; B < k.length; ++B) {
        var c = k[B];
        if (le(c, Uint8Array) && (c = t.from(c)), !t.isBuffer(c))
          throw new TypeError('"list" argument must be an Array of Buffers');
        c.copy(K, h), h += c.length;
      }
      return K;
    }, t.byteLength = g, t.prototype._isBuffer = !0, t.prototype.swap16 = function() {
      var k = this.length;
      if (k % 2 != 0)
        throw new RangeError("Buffer size must be a multiple of 16-bits");
      for (var T = 0; T < k; T += 2)
        x(this, T, T + 1);
      return this;
    }, t.prototype.swap32 = function() {
      var k = this.length;
      if (k % 4 != 0)
        throw new RangeError("Buffer size must be a multiple of 32-bits");
      for (var T = 0; T < k; T += 4)
        x(this, T, T + 3), x(this, T + 1, T + 2);
      return this;
    }, t.prototype.swap64 = function() {
      var k = this.length;
      if (k % 8 != 0)
        throw new RangeError("Buffer size must be a multiple of 64-bits");
      for (var T = 0; T < k; T += 8)
        x(this, T, T + 7), x(this, T + 1, T + 6), x(this, T + 2, T + 5), x(this, T + 3, T + 4);
      return this;
    }, t.prototype.toString = function() {
      var k = this.length;
      return k === 0 ? "" : arguments.length === 0 ? R(this, 0, k) : v.apply(this, arguments);
    }, t.prototype.toLocaleString = t.prototype.toString, t.prototype.equals = function(k) {
      if (!t.isBuffer(k))
        throw new TypeError("Argument must be a Buffer");
      return this === k || t.compare(this, k) === 0;
    }, t.prototype.inspect = function() {
      var k = "", T = l.h2;
      return k = this.toString("hex", 0, T).replace(/(.{2})/g, "$1 ").trim(), this.length > T && (k += " ... "), "<Buffer " + k + ">";
    }, t.prototype.compare = function(k, T, B, K, h) {
      if (le(k, Uint8Array) && (k = t.from(k, k.offset, k.byteLength)), !t.isBuffer(k))
        throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof k);
      if (T === void 0 && (T = 0), B === void 0 && (B = k ? k.length : 0), K === void 0 && (K = 0), h === void 0 && (h = this.length), T < 0 || B > k.length || K < 0 || h > this.length)
        throw new RangeError("out of range index");
      if (K >= h && T >= B)
        return 0;
      if (K >= h)
        return -1;
      if (T >= B)
        return 1;
      if (this === k)
        return 0;
      for (var c = (h >>>= 0) - (K >>>= 0), m = (B >>>= 0) - (T >>>= 0), D = Math.min(c, m), ee = this.slice(K, h), E = k.slice(T, B), Q = 0; Q < D; ++Q)
        if (ee[Q] !== E[Q]) {
          c = ee[Q], m = E[Q];
          break;
        }
      return c < m ? -1 : m < c ? 1 : 0;
    }, t.prototype.includes = function(k, T, B) {
      return this.indexOf(k, T, B) !== -1;
    }, t.prototype.indexOf = function(k, T, B) {
      return b(this, k, T, B, !0);
    }, t.prototype.lastIndexOf = function(k, T, B) {
      return b(this, k, T, B, !1);
    }, t.prototype.write = function(k, T, B, K) {
      if (T === void 0)
        K = "utf8", B = this.length, T = 0;
      else if (B === void 0 && typeof T == "string")
        K = T, B = this.length, T = 0;
      else {
        if (!isFinite(T))
          throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
        T >>>= 0, isFinite(B) ? (B >>>= 0, K === void 0 && (K = "utf8")) : (K = B, B = void 0);
      }
      var h = this.length - T;
      if ((B === void 0 || B > h) && (B = h), k.length > 0 && (B < 0 || T < 0) || T > this.length)
        throw new RangeError("Attempt to write outside buffer bounds");
      K || (K = "utf8");
      for (var c = !1; ; )
        switch (K) {
          case "hex":
            return M(this, k, T, B);
          case "utf8":
          case "utf-8":
            return G(this, k, T, B);
          case "ascii":
            return F(this, k, T, B);
          case "latin1":
          case "binary":
            return V(this, k, T, B);
          case "base64":
            return q(this, k, T, B);
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return I(this, k, T, B);
          default:
            if (c)
              throw new TypeError("Unknown encoding: " + K);
            K = ("" + K).toLowerCase(), c = !0;
        }
    }, t.prototype.toJSON = function() {
      return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
    };
    var W = 4096;
    function O(k, T, B) {
      var K = "";
      B = Math.min(k.length, B);
      for (var h = T; h < B; ++h)
        K += String.fromCharCode(127 & k[h]);
      return K;
    }
    function j(k, T, B) {
      var K = "";
      B = Math.min(k.length, B);
      for (var h = T; h < B; ++h)
        K += String.fromCharCode(k[h]);
      return K;
    }
    function U(k, T, B) {
      var K, h = k.length;
      (!T || T < 0) && (T = 0), (!B || B < 0 || B > h) && (B = h);
      for (var c = "", m = T; m < B; ++m)
        c += (K = k[m]) < 16 ? "0" + K.toString(16) : K.toString(16);
      return c;
    }
    function C(k, T, B) {
      for (var K = k.slice(T, B), h = "", c = 0; c < K.length; c += 2)
        h += String.fromCharCode(K[c] + 256 * K[c + 1]);
      return h;
    }
    function ae(k, T, B) {
      if (k % 1 != 0 || k < 0)
        throw new RangeError("offset is not uint");
      if (k + T > B)
        throw new RangeError("Trying to access beyond buffer length");
    }
    function J(k, T, B, K, h, c) {
      if (!t.isBuffer(k))
        throw new TypeError('"buffer" argument must be a Buffer instance');
      if (T > h || T < c)
        throw new RangeError('"value" argument is out of bounds');
      if (B + K > k.length)
        throw new RangeError("Index out of range");
    }
    function te(k, T, B, K, h, c) {
      if (B + K > k.length)
        throw new RangeError("Index out of range");
      if (B < 0)
        throw new RangeError("Index out of range");
    }
    function $(k, T, B, K, h) {
      return T = +T, B >>>= 0, h || te(k, 0, B, 4), f.write(k, T, B, K, 23, 4), B + 4;
    }
    function L(k, T, B, K, h) {
      return T = +T, B >>>= 0, h || te(k, 0, B, 8), f.write(k, T, B, K, 52, 8), B + 8;
    }
    t.prototype.slice = function(k, T) {
      var B = this.length;
      (k = ~~k) < 0 ? (k += B) < 0 && (k = 0) : k > B && (k = B), (T = T === void 0 ? B : ~~T) < 0 ? (T += B) < 0 && (T = 0) : T > B && (T = B), T < k && (T = k);
      var K = this.subarray(k, T);
      return K.__proto__ = t.prototype, K;
    }, t.prototype.readUIntLE = function(k, T, B) {
      k >>>= 0, T >>>= 0, B || ae(k, T, this.length);
      for (var K = this[k], h = 1, c = 0; ++c < T && (h *= 256); )
        K += this[k + c] * h;
      return K;
    }, t.prototype.readUIntBE = function(k, T, B) {
      k >>>= 0, T >>>= 0, B || ae(k, T, this.length);
      for (var K = this[k + --T], h = 1; T > 0 && (h *= 256); )
        K += this[k + --T] * h;
      return K;
    }, t.prototype.readUInt8 = function(k, T) {
      return k >>>= 0, T || ae(k, 1, this.length), this[k];
    }, t.prototype.readUInt16LE = function(k, T) {
      return k >>>= 0, T || ae(k, 2, this.length), this[k] | this[k + 1] << 8;
    }, t.prototype.readUInt16BE = function(k, T) {
      return k >>>= 0, T || ae(k, 2, this.length), this[k] << 8 | this[k + 1];
    }, t.prototype.readUInt32LE = function(k, T) {
      return k >>>= 0, T || ae(k, 4, this.length), (this[k] | this[k + 1] << 8 | this[k + 2] << 16) + 16777216 * this[k + 3];
    }, t.prototype.readUInt32BE = function(k, T) {
      return k >>>= 0, T || ae(k, 4, this.length), 16777216 * this[k] + (this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3]);
    }, t.prototype.readIntLE = function(k, T, B) {
      k >>>= 0, T >>>= 0, B || ae(k, T, this.length);
      for (var K = this[k], h = 1, c = 0; ++c < T && (h *= 256); )
        K += this[k + c] * h;
      return K >= (h *= 128) && (K -= Math.pow(2, 8 * T)), K;
    }, t.prototype.readIntBE = function(k, T, B) {
      k >>>= 0, T >>>= 0, B || ae(k, T, this.length);
      for (var K = T, h = 1, c = this[k + --K]; K > 0 && (h *= 256); )
        c += this[k + --K] * h;
      return c >= (h *= 128) && (c -= Math.pow(2, 8 * T)), c;
    }, t.prototype.readInt8 = function(k, T) {
      return k >>>= 0, T || ae(k, 1, this.length), 128 & this[k] ? -1 * (255 - this[k] + 1) : this[k];
    }, t.prototype.readInt16LE = function(k, T) {
      k >>>= 0, T || ae(k, 2, this.length);
      var B = this[k] | this[k + 1] << 8;
      return 32768 & B ? 4294901760 | B : B;
    }, t.prototype.readInt16BE = function(k, T) {
      k >>>= 0, T || ae(k, 2, this.length);
      var B = this[k + 1] | this[k] << 8;
      return 32768 & B ? 4294901760 | B : B;
    }, t.prototype.readInt32LE = function(k, T) {
      return k >>>= 0, T || ae(k, 4, this.length), this[k] | this[k + 1] << 8 | this[k + 2] << 16 | this[k + 3] << 24;
    }, t.prototype.readInt32BE = function(k, T) {
      return k >>>= 0, T || ae(k, 4, this.length), this[k] << 24 | this[k + 1] << 16 | this[k + 2] << 8 | this[k + 3];
    }, t.prototype.readFloatLE = function(k, T) {
      return k >>>= 0, T || ae(k, 4, this.length), f.read(this, k, !0, 23, 4);
    }, t.prototype.readFloatBE = function(k, T) {
      return k >>>= 0, T || ae(k, 4, this.length), f.read(this, k, !1, 23, 4);
    }, t.prototype.readDoubleLE = function(k, T) {
      return k >>>= 0, T || ae(k, 8, this.length), f.read(this, k, !0, 52, 8);
    }, t.prototype.readDoubleBE = function(k, T) {
      return k >>>= 0, T || ae(k, 8, this.length), f.read(this, k, !1, 52, 8);
    }, t.prototype.writeUIntLE = function(k, T, B, K) {
      k = +k, T >>>= 0, B >>>= 0, K || J(this, k, T, B, Math.pow(2, 8 * B) - 1, 0);
      var h = 1, c = 0;
      for (this[T] = 255 & k; ++c < B && (h *= 256); )
        this[T + c] = k / h & 255;
      return T + B;
    }, t.prototype.writeUIntBE = function(k, T, B, K) {
      k = +k, T >>>= 0, B >>>= 0, K || J(this, k, T, B, Math.pow(2, 8 * B) - 1, 0);
      var h = B - 1, c = 1;
      for (this[T + h] = 255 & k; --h >= 0 && (c *= 256); )
        this[T + h] = k / c & 255;
      return T + B;
    }, t.prototype.writeUInt8 = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 1, 255, 0), this[T] = 255 & k, T + 1;
    }, t.prototype.writeUInt16LE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 2, 65535, 0), this[T] = 255 & k, this[T + 1] = k >>> 8, T + 2;
    }, t.prototype.writeUInt16BE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 2, 65535, 0), this[T] = k >>> 8, this[T + 1] = 255 & k, T + 2;
    }, t.prototype.writeUInt32LE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 4, 4294967295, 0), this[T + 3] = k >>> 24, this[T + 2] = k >>> 16, this[T + 1] = k >>> 8, this[T] = 255 & k, T + 4;
    }, t.prototype.writeUInt32BE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 4, 4294967295, 0), this[T] = k >>> 24, this[T + 1] = k >>> 16, this[T + 2] = k >>> 8, this[T + 3] = 255 & k, T + 4;
    }, t.prototype.writeIntLE = function(k, T, B, K) {
      if (k = +k, T >>>= 0, !K) {
        var h = Math.pow(2, 8 * B - 1);
        J(this, k, T, B, h - 1, -h);
      }
      var c = 0, m = 1, D = 0;
      for (this[T] = 255 & k; ++c < B && (m *= 256); )
        k < 0 && D === 0 && this[T + c - 1] !== 0 && (D = 1), this[T + c] = (k / m >> 0) - D & 255;
      return T + B;
    }, t.prototype.writeIntBE = function(k, T, B, K) {
      if (k = +k, T >>>= 0, !K) {
        var h = Math.pow(2, 8 * B - 1);
        J(this, k, T, B, h - 1, -h);
      }
      var c = B - 1, m = 1, D = 0;
      for (this[T + c] = 255 & k; --c >= 0 && (m *= 256); )
        k < 0 && D === 0 && this[T + c + 1] !== 0 && (D = 1), this[T + c] = (k / m >> 0) - D & 255;
      return T + B;
    }, t.prototype.writeInt8 = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 1, 127, -128), k < 0 && (k = 255 + k + 1), this[T] = 255 & k, T + 1;
    }, t.prototype.writeInt16LE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 2, 32767, -32768), this[T] = 255 & k, this[T + 1] = k >>> 8, T + 2;
    }, t.prototype.writeInt16BE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 2, 32767, -32768), this[T] = k >>> 8, this[T + 1] = 255 & k, T + 2;
    }, t.prototype.writeInt32LE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 4, 2147483647, -2147483648), this[T] = 255 & k, this[T + 1] = k >>> 8, this[T + 2] = k >>> 16, this[T + 3] = k >>> 24, T + 4;
    }, t.prototype.writeInt32BE = function(k, T, B) {
      return k = +k, T >>>= 0, B || J(this, k, T, 4, 2147483647, -2147483648), k < 0 && (k = 4294967295 + k + 1), this[T] = k >>> 24, this[T + 1] = k >>> 16, this[T + 2] = k >>> 8, this[T + 3] = 255 & k, T + 4;
    }, t.prototype.writeFloatLE = function(k, T, B) {
      return $(this, k, T, !0, B);
    }, t.prototype.writeFloatBE = function(k, T, B) {
      return $(this, k, T, !1, B);
    }, t.prototype.writeDoubleLE = function(k, T, B) {
      return L(this, k, T, !0, B);
    }, t.prototype.writeDoubleBE = function(k, T, B) {
      return L(this, k, T, !1, B);
    }, t.prototype.copy = function(k, T, B, K) {
      if (!t.isBuffer(k))
        throw new TypeError("argument should be a Buffer");
      if (B || (B = 0), K || K === 0 || (K = this.length), T >= k.length && (T = k.length), T || (T = 0), K > 0 && K < B && (K = B), K === B || k.length === 0 || this.length === 0)
        return 0;
      if (T < 0)
        throw new RangeError("targetStart out of bounds");
      if (B < 0 || B >= this.length)
        throw new RangeError("Index out of range");
      if (K < 0)
        throw new RangeError("sourceEnd out of bounds");
      K > this.length && (K = this.length), k.length - T < K - B && (K = k.length - T + B);
      var h = K - B;
      if (this === k && typeof Uint8Array.prototype.copyWithin == "function")
        this.copyWithin(T, B, K);
      else if (this === k && B < T && T < K)
        for (var c = h - 1; c >= 0; --c)
          k[c + T] = this[c + B];
      else
        Uint8Array.prototype.set.call(k, this.subarray(B, K), T);
      return h;
    }, t.prototype.fill = function(k, T, B, K) {
      if (typeof k == "string") {
        if (typeof T == "string" ? (K = T, T = 0, B = this.length) : typeof B == "string" && (K = B, B = this.length), K !== void 0 && typeof K != "string")
          throw new TypeError("encoding must be a string");
        if (typeof K == "string" && !t.isEncoding(K))
          throw new TypeError("Unknown encoding: " + K);
        if (k.length === 1) {
          var h = k.charCodeAt(0);
          (K === "utf8" && h < 128 || K === "latin1") && (k = h);
        }
      } else
        typeof k == "number" && (k &= 255);
      if (T < 0 || this.length < T || this.length < B)
        throw new RangeError("Out of range index");
      if (B <= T)
        return this;
      var c;
      if (T >>>= 0, B = B === void 0 ? this.length : B >>> 0, k || (k = 0), typeof k == "number")
        for (c = T; c < B; ++c)
          this[c] = k;
      else {
        var m = t.isBuffer(k) ? k : t.from(k, K), D = m.length;
        if (D === 0)
          throw new TypeError('The value "' + k + '" is invalid for argument "value"');
        for (c = 0; c < B - T; ++c)
          this[c + T] = m[c % D];
      }
      return this;
    };
    var re = /[^+/0-9A-Za-z-_]/g;
    function z(k, T) {
      var B;
      T = T || 1 / 0;
      for (var K = k.length, h = null, c = [], m = 0; m < K; ++m) {
        if ((B = k.charCodeAt(m)) > 55295 && B < 57344) {
          if (!h) {
            if (B > 56319) {
              (T -= 3) > -1 && c.push(239, 191, 189);
              continue;
            }
            if (m + 1 === K) {
              (T -= 3) > -1 && c.push(239, 191, 189);
              continue;
            }
            h = B;
            continue;
          }
          if (B < 56320) {
            (T -= 3) > -1 && c.push(239, 191, 189), h = B;
            continue;
          }
          B = 65536 + (h - 55296 << 10 | B - 56320);
        } else
          h && (T -= 3) > -1 && c.push(239, 191, 189);
        if (h = null, B < 128) {
          if ((T -= 1) < 0)
            break;
          c.push(B);
        } else if (B < 2048) {
          if ((T -= 2) < 0)
            break;
          c.push(B >> 6 | 192, 63 & B | 128);
        } else if (B < 65536) {
          if ((T -= 3) < 0)
            break;
          c.push(B >> 12 | 224, B >> 6 & 63 | 128, 63 & B | 128);
        } else {
          if (!(B < 1114112))
            throw new Error("Invalid code point");
          if ((T -= 4) < 0)
            break;
          c.push(B >> 18 | 240, B >> 12 & 63 | 128, B >> 6 & 63 | 128, 63 & B | 128);
        }
      }
      return c;
    }
    function N(k) {
      return e.toByteArray(function(T) {
        if ((T = (T = T.split("=")[0]).trim().replace(re, "")).length < 2)
          return "";
        for (; T.length % 4 != 0; )
          T += "=";
        return T;
      }(k));
    }
    function ne(k, T, B, K) {
      for (var h = 0; h < K && !(h + B >= T.length || h >= k.length); ++h)
        T[h + B] = k[h];
      return h;
    }
    function le(k, T) {
      return k instanceof T || k != null && k.constructor != null && k.constructor.name != null && k.constructor.name === T.name;
    }
    function he(k) {
      return k != k;
    }
  }, 4181: (d, l) => {
    l.read = function(s, e, f, i, a) {
      var t, r, o = 8 * a - i - 1, n = (1 << o) - 1, u = n >> 1, p = -7, g = f ? a - 1 : 0, v = f ? -1 : 1, x = s[e + g];
      for (g += v, t = x & (1 << -p) - 1, x >>= -p, p += o; p > 0; t = 256 * t + s[e + g], g += v, p -= 8)
        ;
      for (r = t & (1 << -p) - 1, t >>= -p, p += i; p > 0; r = 256 * r + s[e + g], g += v, p -= 8)
        ;
      if (t === 0)
        t = 1 - u;
      else {
        if (t === n)
          return r ? NaN : 1 / 0 * (x ? -1 : 1);
        r += Math.pow(2, i), t -= u;
      }
      return (x ? -1 : 1) * r * Math.pow(2, t - i);
    }, l.write = function(s, e, f, i, a, t) {
      var r, o, n, u = 8 * t - a - 1, p = (1 << u) - 1, g = p >> 1, v = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = i ? 0 : t - 1, b = i ? 1 : -1, w = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, r = p) : (r = Math.floor(Math.log(e) / Math.LN2), e * (n = Math.pow(2, -r)) < 1 && (r--, n *= 2), (e += r + g >= 1 ? v / n : v * Math.pow(2, 1 - g)) * n >= 2 && (r++, n /= 2), r + g >= p ? (o = 0, r = p) : r + g >= 1 ? (o = (e * n - 1) * Math.pow(2, a), r += g) : (o = e * Math.pow(2, g - 1) * Math.pow(2, a), r = 0)); a >= 8; s[f + x] = 255 & o, x += b, o /= 256, a -= 8)
        ;
      for (r = r << a | o, u += a; u > 0; s[f + x] = 255 & r, x += b, r /= 256, u -= 8)
        ;
      s[f + x - b] |= 128 * w;
    };
  }, 2699: (d) => {
    var l, s = typeof Reflect == "object" ? Reflect : null, e = s && typeof s.apply == "function" ? s.apply : function(b, w, M) {
      return Function.prototype.apply.call(b, w, M);
    };
    l = s && typeof s.ownKeys == "function" ? s.ownKeys : Object.getOwnPropertySymbols ? function(b) {
      return Object.getOwnPropertyNames(b).concat(Object.getOwnPropertySymbols(b));
    } : function(b) {
      return Object.getOwnPropertyNames(b);
    };
    var f = Number.isNaN || function(b) {
      return b != b;
    };
    function i() {
      i.init.call(this);
    }
    d.exports = i, d.exports.once = function(b, w) {
      return new Promise(function(M, G) {
        function F(q) {
          b.removeListener(w, V), G(q);
        }
        function V() {
          typeof b.removeListener == "function" && b.removeListener("error", F), M([].slice.call(arguments));
        }
        x(b, w, V, { once: !0 }), w !== "error" && function(q, I, _) {
          typeof q.on == "function" && x(q, "error", I, { once: !0 });
        }(b, F);
      });
    }, i.EventEmitter = i, i.prototype._events = void 0, i.prototype._eventsCount = 0, i.prototype._maxListeners = void 0;
    var a = 10;
    function t(b) {
      if (typeof b != "function")
        throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof b);
    }
    function r(b) {
      return b._maxListeners === void 0 ? i.defaultMaxListeners : b._maxListeners;
    }
    function o(b, w, M, G) {
      var F, V, q, I;
      if (t(M), (V = b._events) === void 0 ? (V = b._events = /* @__PURE__ */ Object.create(null), b._eventsCount = 0) : (V.newListener !== void 0 && (b.emit("newListener", w, M.listener ? M.listener : M), V = b._events), q = V[w]), q === void 0)
        q = V[w] = M, ++b._eventsCount;
      else if (typeof q == "function" ? q = V[w] = G ? [M, q] : [q, M] : G ? q.unshift(M) : q.push(M), (F = r(b)) > 0 && q.length > F && !q.warned) {
        q.warned = !0;
        var _ = new Error("Possible EventEmitter memory leak detected. " + q.length + " " + String(w) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        _.name = "MaxListenersExceededWarning", _.emitter = b, _.type = w, _.count = q.length, I = _, console && console.warn && console.warn(I);
      }
      return b;
    }
    function n() {
      if (!this.fired)
        return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
    }
    function u(b, w, M) {
      var G = { fired: !1, wrapFn: void 0, target: b, type: w, listener: M }, F = n.bind(G);
      return F.listener = M, G.wrapFn = F, F;
    }
    function p(b, w, M) {
      var G = b._events;
      if (G === void 0)
        return [];
      var F = G[w];
      return F === void 0 ? [] : typeof F == "function" ? M ? [F.listener || F] : [F] : M ? function(V) {
        for (var q = new Array(V.length), I = 0; I < q.length; ++I)
          q[I] = V[I].listener || V[I];
        return q;
      }(F) : v(F, F.length);
    }
    function g(b) {
      var w = this._events;
      if (w !== void 0) {
        var M = w[b];
        if (typeof M == "function")
          return 1;
        if (M !== void 0)
          return M.length;
      }
      return 0;
    }
    function v(b, w) {
      for (var M = new Array(w), G = 0; G < w; ++G)
        M[G] = b[G];
      return M;
    }
    function x(b, w, M, G) {
      if (typeof b.on == "function")
        G.once ? b.once(w, M) : b.on(w, M);
      else {
        if (typeof b.addEventListener != "function")
          throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof b);
        b.addEventListener(w, function F(V) {
          G.once && b.removeEventListener(w, F), M(V);
        });
      }
    }
    Object.defineProperty(i, "defaultMaxListeners", { enumerable: !0, get: function() {
      return a;
    }, set: function(b) {
      if (typeof b != "number" || b < 0 || f(b))
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + b + ".");
      a = b;
    } }), i.init = function() {
      this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
    }, i.prototype.setMaxListeners = function(b) {
      if (typeof b != "number" || b < 0 || f(b))
        throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + b + ".");
      return this._maxListeners = b, this;
    }, i.prototype.getMaxListeners = function() {
      return r(this);
    }, i.prototype.emit = function(b) {
      for (var w = [], M = 1; M < arguments.length; M++)
        w.push(arguments[M]);
      var G = b === "error", F = this._events;
      if (F !== void 0)
        G = G && F.error === void 0;
      else if (!G)
        return !1;
      if (G) {
        var V;
        if (w.length > 0 && (V = w[0]), V instanceof Error)
          throw V;
        var q = new Error("Unhandled error." + (V ? " (" + V.message + ")" : ""));
        throw q.context = V, q;
      }
      var I = F[b];
      if (I === void 0)
        return !1;
      if (typeof I == "function")
        e(I, this, w);
      else {
        var _ = I.length, R = v(I, _);
        for (M = 0; M < _; ++M)
          e(R[M], this, w);
      }
      return !0;
    }, i.prototype.addListener = function(b, w) {
      return o(this, b, w, !1);
    }, i.prototype.on = i.prototype.addListener, i.prototype.prependListener = function(b, w) {
      return o(this, b, w, !0);
    }, i.prototype.once = function(b, w) {
      return t(w), this.on(b, u(this, b, w)), this;
    }, i.prototype.prependOnceListener = function(b, w) {
      return t(w), this.prependListener(b, u(this, b, w)), this;
    }, i.prototype.removeListener = function(b, w) {
      var M, G, F, V, q;
      if (t(w), (G = this._events) === void 0)
        return this;
      if ((M = G[b]) === void 0)
        return this;
      if (M === w || M.listener === w)
        --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete G[b], G.removeListener && this.emit("removeListener", b, M.listener || w));
      else if (typeof M != "function") {
        for (F = -1, V = M.length - 1; V >= 0; V--)
          if (M[V] === w || M[V].listener === w) {
            q = M[V].listener, F = V;
            break;
          }
        if (F < 0)
          return this;
        F === 0 ? M.shift() : function(I, _) {
          for (; _ + 1 < I.length; _++)
            I[_] = I[_ + 1];
          I.pop();
        }(M, F), M.length === 1 && (G[b] = M[0]), G.removeListener !== void 0 && this.emit("removeListener", b, q || w);
      }
      return this;
    }, i.prototype.off = i.prototype.removeListener, i.prototype.removeAllListeners = function(b) {
      var w, M, G;
      if ((M = this._events) === void 0)
        return this;
      if (M.removeListener === void 0)
        return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : M[b] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete M[b]), this;
      if (arguments.length === 0) {
        var F, V = Object.keys(M);
        for (G = 0; G < V.length; ++G)
          (F = V[G]) !== "removeListener" && this.removeAllListeners(F);
        return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
      }
      if (typeof (w = M[b]) == "function")
        this.removeListener(b, w);
      else if (w !== void 0)
        for (G = w.length - 1; G >= 0; G--)
          this.removeListener(b, w[G]);
      return this;
    }, i.prototype.listeners = function(b) {
      return p(this, b, !0);
    }, i.prototype.rawListeners = function(b) {
      return p(this, b, !1);
    }, i.listenerCount = function(b, w) {
      return typeof b.listenerCount == "function" ? b.listenerCount(w) : g.call(b, w);
    }, i.prototype.listenerCount = g, i.prototype.eventNames = function() {
      return this._eventsCount > 0 ? l(this._events) : [];
    };
  }, 6551: (d, l, s) => {
    var e = s(453);
    d.exports = { create: function(f, i) {
      if (f instanceof (i = i || (0, eval)("this")).ArrayBuffer) {
        var a = s(909);
        return new e(new a(f, 0, f.byteLength, !0, i));
      }
      var t = s(3684);
      return new e(new t(f, 0, f.length, !0));
    } };
  }, 3684: (d) => {
    function l(s, e, f, i) {
      this.buffer = s, this.offset = e || 0, f = typeof f == "number" ? f : s.length, this.endPosition = this.offset + f, this.setBigEndian(i);
    }
    l.prototype = { setBigEndian: function(s) {
      this.bigEndian = !!s;
    }, nextUInt8: function() {
      var s = this.buffer.readUInt8(this.offset);
      return this.offset += 1, s;
    }, nextInt8: function() {
      var s = this.buffer.readInt8(this.offset);
      return this.offset += 1, s;
    }, nextUInt16: function() {
      var s = this.bigEndian ? this.buffer.readUInt16BE(this.offset) : this.buffer.readUInt16LE(this.offset);
      return this.offset += 2, s;
    }, nextUInt32: function() {
      var s = this.bigEndian ? this.buffer.readUInt32BE(this.offset) : this.buffer.readUInt32LE(this.offset);
      return this.offset += 4, s;
    }, nextInt16: function() {
      var s = this.bigEndian ? this.buffer.readInt16BE(this.offset) : this.buffer.readInt16LE(this.offset);
      return this.offset += 2, s;
    }, nextInt32: function() {
      var s = this.bigEndian ? this.buffer.readInt32BE(this.offset) : this.buffer.readInt32LE(this.offset);
      return this.offset += 4, s;
    }, nextFloat: function() {
      var s = this.bigEndian ? this.buffer.readFloatBE(this.offset) : this.buffer.readFloatLE(this.offset);
      return this.offset += 4, s;
    }, nextDouble: function() {
      var s = this.bigEndian ? this.buffer.readDoubleBE(this.offset) : this.buffer.readDoubleLE(this.offset);
      return this.offset += 8, s;
    }, nextBuffer: function(s) {
      var e = this.buffer.slice(this.offset, this.offset + s);
      return this.offset += s, e;
    }, remainingLength: function() {
      return this.endPosition - this.offset;
    }, nextString: function(s) {
      var e = this.buffer.toString("utf8", this.offset, this.offset + s);
      return this.offset += s, e;
    }, mark: function() {
      var s = this;
      return { openWithOffset: function(e) {
        return e = (e || 0) + this.offset, new l(s.buffer, e, s.endPosition - e, s.bigEndian);
      }, offset: this.offset };
    }, offsetFrom: function(s) {
      return this.offset - s.offset;
    }, skip: function(s) {
      this.offset += s;
    }, branch: function(s, e) {
      return e = typeof e == "number" ? e : this.endPosition - (this.offset + s), new l(this.buffer, this.offset + s, e, this.bigEndian);
    } }, d.exports = l;
  }, 565: (d) => {
    function l(t) {
      return parseInt(t, 10);
    }
    var s = 3600, e = 60;
    function f(t, r) {
      t = t.map(l), r = r.map(l);
      var o = t[0], n = t[1] - 1, u = t[2], p = r[0], g = r[1], v = r[2];
      return Date.UTC(o, n, u, p, g, v, 0) / 1e3;
    }
    function i(t) {
      var r = t.substr(0, 10).split("-"), o = t.substr(11, 8).split(":"), n = t.substr(19, 6).split(":").map(l), u = n[0] * s + n[1] * e, p = f(r, o);
      if (typeof (p -= u) == "number" && !isNaN(p))
        return p;
    }
    function a(t) {
      var r = t.split(" "), o = f(r[0].split(":"), r[1].split(":"));
      if (typeof o == "number" && !isNaN(o))
        return o;
    }
    d.exports = { parseDateWithSpecFormat: a, parseDateWithTimezoneFormat: i, parseExifDate: function(t) {
      var r = t.length === 19 && t.charAt(4) === ":";
      return t.length === 25 && t.charAt(10) === "T" ? i(t) : r ? a(t) : void 0;
    } };
  }, 909: (d) => {
    function l(s, e, f, i, a, t) {
      this.global = a, e = e || 0, f = f || s.byteLength - e, this.arrayBuffer = s.slice(e, e + f), this.view = new a.DataView(this.arrayBuffer, 0, this.arrayBuffer.byteLength), this.setBigEndian(i), this.offset = 0, this.parentOffset = (t || 0) + e;
    }
    l.prototype = { setBigEndian: function(s) {
      this.littleEndian = !s;
    }, nextUInt8: function() {
      var s = this.view.getUint8(this.offset);
      return this.offset += 1, s;
    }, nextInt8: function() {
      var s = this.view.getInt8(this.offset);
      return this.offset += 1, s;
    }, nextUInt16: function() {
      var s = this.view.getUint16(this.offset, this.littleEndian);
      return this.offset += 2, s;
    }, nextUInt32: function() {
      var s = this.view.getUint32(this.offset, this.littleEndian);
      return this.offset += 4, s;
    }, nextInt16: function() {
      var s = this.view.getInt16(this.offset, this.littleEndian);
      return this.offset += 2, s;
    }, nextInt32: function() {
      var s = this.view.getInt32(this.offset, this.littleEndian);
      return this.offset += 4, s;
    }, nextFloat: function() {
      var s = this.view.getFloat32(this.offset, this.littleEndian);
      return this.offset += 4, s;
    }, nextDouble: function() {
      var s = this.view.getFloat64(this.offset, this.littleEndian);
      return this.offset += 8, s;
    }, nextBuffer: function(s) {
      var e = this.arrayBuffer.slice(this.offset, this.offset + s);
      return this.offset += s, e;
    }, remainingLength: function() {
      return this.arrayBuffer.byteLength - this.offset;
    }, nextString: function(s) {
      var e = this.arrayBuffer.slice(this.offset, this.offset + s);
      return e = String.fromCharCode.apply(null, new this.global.Uint8Array(e)), this.offset += s, e;
    }, mark: function() {
      var s = this;
      return { openWithOffset: function(e) {
        return e = (e || 0) + this.offset, new l(s.arrayBuffer, e, s.arrayBuffer.byteLength - e, !s.littleEndian, s.global, s.parentOffset);
      }, offset: this.offset, getParentOffset: function() {
        return s.parentOffset;
      } };
    }, offsetFrom: function(s) {
      return this.parentOffset + this.offset - (s.offset + s.getParentOffset());
    }, skip: function(s) {
      this.offset += s;
    }, branch: function(s, e) {
      return e = typeof e == "number" ? e : this.arrayBuffer.byteLength - (this.offset + s), new l(this.arrayBuffer, this.offset + s, e, !this.littleEndian, this.global, this.parentOffset);
    } }, d.exports = l;
  }, 3332: (d) => {
    d.exports = { exif: { 1: "InteropIndex", 2: "InteropVersion", 11: "ProcessingSoftware", 254: "SubfileType", 255: "OldSubfileType", 256: "ImageWidth", 257: "ImageHeight", 258: "BitsPerSample", 259: "Compression", 262: "PhotometricInterpretation", 263: "Thresholding", 264: "CellWidth", 265: "CellLength", 266: "FillOrder", 269: "DocumentName", 270: "ImageDescription", 271: "Make", 272: "Model", 273: "StripOffsets", 274: "Orientation", 277: "SamplesPerPixel", 278: "RowsPerStrip", 279: "StripByteCounts", 280: "MinSampleValue", 281: "MaxSampleValue", 282: "XResolution", 283: "YResolution", 284: "PlanarConfiguration", 285: "PageName", 286: "XPosition", 287: "YPosition", 288: "FreeOffsets", 289: "FreeByteCounts", 290: "GrayResponseUnit", 291: "GrayResponseCurve", 292: "T4Options", 293: "T6Options", 296: "ResolutionUnit", 297: "PageNumber", 300: "ColorResponseUnit", 301: "TransferFunction", 305: "Software", 306: "ModifyDate", 315: "Artist", 316: "HostComputer", 317: "Predictor", 318: "WhitePoint", 319: "PrimaryChromaticities", 320: "ColorMap", 321: "HalftoneHints", 322: "TileWidth", 323: "TileLength", 324: "TileOffsets", 325: "TileByteCounts", 326: "BadFaxLines", 327: "CleanFaxData", 328: "ConsecutiveBadFaxLines", 330: "SubIFD", 332: "InkSet", 333: "InkNames", 334: "NumberofInks", 336: "DotRange", 337: "TargetPrinter", 338: "ExtraSamples", 339: "SampleFormat", 340: "SMinSampleValue", 341: "SMaxSampleValue", 342: "TransferRange", 343: "ClipPath", 344: "XClipPathUnits", 345: "YClipPathUnits", 346: "Indexed", 347: "JPEGTables", 351: "OPIProxy", 400: "GlobalParametersIFD", 401: "ProfileType", 402: "FaxProfile", 403: "CodingMethods", 404: "VersionYear", 405: "ModeNumber", 433: "Decode", 434: "DefaultImageColor", 435: "T82Options", 437: "JPEGTables", 512: "JPEGProc", 513: "ThumbnailOffset", 514: "ThumbnailLength", 515: "JPEGRestartInterval", 517: "JPEGLosslessPredictors", 518: "JPEGPointTransforms", 519: "JPEGQTables", 520: "JPEGDCTables", 521: "JPEGACTables", 529: "YCbCrCoefficients", 530: "YCbCrSubSampling", 531: "YCbCrPositioning", 532: "ReferenceBlackWhite", 559: "StripRowCounts", 700: "ApplicationNotes", 999: "USPTOMiscellaneous", 4096: "RelatedImageFileFormat", 4097: "RelatedImageWidth", 4098: "RelatedImageHeight", 18246: "Rating", 18247: "XP_DIP_XML", 18248: "StitchInfo", 18249: "RatingPercent", 32781: "ImageID", 32931: "WangTag1", 32932: "WangAnnotation", 32933: "WangTag3", 32934: "WangTag4", 32995: "Matteing", 32996: "DataType", 32997: "ImageDepth", 32998: "TileDepth", 33405: "Model2", 33421: "CFARepeatPatternDim", 33422: "CFAPattern2", 33423: "BatteryLevel", 33424: "KodakIFD", 33432: "Copyright", 33434: "ExposureTime", 33437: "FNumber", 33445: "MDFileTag", 33446: "MDScalePixel", 33447: "MDColorTable", 33448: "MDLabName", 33449: "MDSampleInfo", 33450: "MDPrepDate", 33451: "MDPrepTime", 33452: "MDFileUnits", 33550: "PixelScale", 33589: "AdventScale", 33590: "AdventRevision", 33628: "UIC1Tag", 33629: "UIC2Tag", 33630: "UIC3Tag", 33631: "UIC4Tag", 33723: "IPTC-NAA", 33918: "IntergraphPacketData", 33919: "IntergraphFlagRegisters", 33920: "IntergraphMatrix", 33921: "INGRReserved", 33922: "ModelTiePoint", 34016: "Site", 34017: "ColorSequence", 34018: "IT8Header", 34019: "RasterPadding", 34020: "BitsPerRunLength", 34021: "BitsPerExtendedRunLength", 34022: "ColorTable", 34023: "ImageColorIndicator", 34024: "BackgroundColorIndicator", 34025: "ImageColorValue", 34026: "BackgroundColorValue", 34027: "PixelIntensityRange", 34028: "TransparencyIndicator", 34029: "ColorCharacterization", 34030: "HCUsage", 34031: "TrapIndicator", 34032: "CMYKEquivalent", 34118: "SEMInfo", 34152: "AFCP_IPTC", 34232: "PixelMagicJBIGOptions", 34264: "ModelTransform", 34306: "WB_GRGBLevels", 34310: "LeafData", 34377: "PhotoshopSettings", 34665: "ExifOffset", 34675: "ICC_Profile", 34687: "TIFF_FXExtensions", 34688: "MultiProfiles", 34689: "SharedData", 34690: "T88Options", 34732: "ImageLayer", 34735: "GeoTiffDirectory", 34736: "GeoTiffDoubleParams", 34737: "GeoTiffAsciiParams", 34850: "ExposureProgram", 34852: "SpectralSensitivity", 34853: "GPSInfo", 34855: "ISO", 34856: "Opto-ElectricConvFactor", 34857: "Interlace", 34858: "TimeZoneOffset", 34859: "SelfTimerMode", 34864: "SensitivityType", 34865: "StandardOutputSensitivity", 34866: "RecommendedExposureIndex", 34867: "ISOSpeed", 34868: "ISOSpeedLatitudeyyy", 34869: "ISOSpeedLatitudezzz", 34908: "FaxRecvParams", 34909: "FaxSubAddress", 34910: "FaxRecvTime", 34954: "LeafSubIFD", 36864: "ExifVersion", 36867: "DateTimeOriginal", 36868: "CreateDate", 37121: "ComponentsConfiguration", 37122: "CompressedBitsPerPixel", 37377: "ShutterSpeedValue", 37378: "ApertureValue", 37379: "BrightnessValue", 37380: "ExposureCompensation", 37381: "MaxApertureValue", 37382: "SubjectDistance", 37383: "MeteringMode", 37384: "LightSource", 37385: "Flash", 37386: "FocalLength", 37387: "FlashEnergy", 37388: "SpatialFrequencyResponse", 37389: "Noise", 37390: "FocalPlaneXResolution", 37391: "FocalPlaneYResolution", 37392: "FocalPlaneResolutionUnit", 37393: "ImageNumber", 37394: "SecurityClassification", 37395: "ImageHistory", 37396: "SubjectArea", 37397: "ExposureIndex", 37398: "TIFF-EPStandardID", 37399: "SensingMethod", 37434: "CIP3DataFile", 37435: "CIP3Sheet", 37436: "CIP3Side", 37439: "StoNits", 37500: "MakerNote", 37510: "UserComment", 37520: "SubSecTime", 37521: "SubSecTimeOriginal", 37522: "SubSecTimeDigitized", 37679: "MSDocumentText", 37680: "MSPropertySetStorage", 37681: "MSDocumentTextPosition", 37724: "ImageSourceData", 40091: "XPTitle", 40092: "XPComment", 40093: "XPAuthor", 40094: "XPKeywords", 40095: "XPSubject", 40960: "FlashpixVersion", 40961: "ColorSpace", 40962: "ExifImageWidth", 40963: "ExifImageHeight", 40964: "RelatedSoundFile", 40965: "InteropOffset", 41483: "FlashEnergy", 41484: "SpatialFrequencyResponse", 41485: "Noise", 41486: "FocalPlaneXResolution", 41487: "FocalPlaneYResolution", 41488: "FocalPlaneResolutionUnit", 41489: "ImageNumber", 41490: "SecurityClassification", 41491: "ImageHistory", 41492: "SubjectLocation", 41493: "ExposureIndex", 41494: "TIFF-EPStandardID", 41495: "SensingMethod", 41728: "FileSource", 41729: "SceneType", 41730: "CFAPattern", 41985: "CustomRendered", 41986: "ExposureMode", 41987: "WhiteBalance", 41988: "DigitalZoomRatio", 41989: "FocalLengthIn35mmFormat", 41990: "SceneCaptureType", 41991: "GainControl", 41992: "Contrast", 41993: "Saturation", 41994: "Sharpness", 41995: "DeviceSettingDescription", 41996: "SubjectDistanceRange", 42016: "ImageUniqueID", 42032: "OwnerName", 42033: "SerialNumber", 42034: "LensInfo", 42035: "LensMake", 42036: "LensModel", 42037: "LensSerialNumber", 42112: "GDALMetadata", 42113: "GDALNoData", 42240: "Gamma", 44992: "ExpandSoftware", 44993: "ExpandLens", 44994: "ExpandFilm", 44995: "ExpandFilterLens", 44996: "ExpandScanner", 44997: "ExpandFlashLamp", 48129: "PixelFormat", 48130: "Transformation", 48131: "Uncompressed", 48132: "ImageType", 48256: "ImageWidth", 48257: "ImageHeight", 48258: "WidthResolution", 48259: "HeightResolution", 48320: "ImageOffset", 48321: "ImageByteCount", 48322: "AlphaOffset", 48323: "AlphaByteCount", 48324: "ImageDataDiscard", 48325: "AlphaDataDiscard", 50215: "OceScanjobDesc", 50216: "OceApplicationSelector", 50217: "OceIDNumber", 50218: "OceImageLogic", 50255: "Annotations", 50341: "PrintIM", 50560: "USPTOOriginalContentType", 50706: "DNGVersion", 50707: "DNGBackwardVersion", 50708: "UniqueCameraModel", 50709: "LocalizedCameraModel", 50710: "CFAPlaneColor", 50711: "CFALayout", 50712: "LinearizationTable", 50713: "BlackLevelRepeatDim", 50714: "BlackLevel", 50715: "BlackLevelDeltaH", 50716: "BlackLevelDeltaV", 50717: "WhiteLevel", 50718: "DefaultScale", 50719: "DefaultCropOrigin", 50720: "DefaultCropSize", 50721: "ColorMatrix1", 50722: "ColorMatrix2", 50723: "CameraCalibration1", 50724: "CameraCalibration2", 50725: "ReductionMatrix1", 50726: "ReductionMatrix2", 50727: "AnalogBalance", 50728: "AsShotNeutral", 50729: "AsShotWhiteXY", 50730: "BaselineExposure", 50731: "BaselineNoise", 50732: "BaselineSharpness", 50733: "BayerGreenSplit", 50734: "LinearResponseLimit", 50735: "CameraSerialNumber", 50736: "DNGLensInfo", 50737: "ChromaBlurRadius", 50738: "AntiAliasStrength", 50739: "ShadowScale", 50740: "DNGPrivateData", 50741: "MakerNoteSafety", 50752: "RawImageSegmentation", 50778: "CalibrationIlluminant1", 50779: "CalibrationIlluminant2", 50780: "BestQualityScale", 50781: "RawDataUniqueID", 50784: "AliasLayerMetadata", 50827: "OriginalRawFileName", 50828: "OriginalRawFileData", 50829: "ActiveArea", 50830: "MaskedAreas", 50831: "AsShotICCProfile", 50832: "AsShotPreProfileMatrix", 50833: "CurrentICCProfile", 50834: "CurrentPreProfileMatrix", 50879: "ColorimetricReference", 50898: "PanasonicTitle", 50899: "PanasonicTitle2", 50931: "CameraCalibrationSig", 50932: "ProfileCalibrationSig", 50933: "ProfileIFD", 50934: "AsShotProfileName", 50935: "NoiseReductionApplied", 50936: "ProfileName", 50937: "ProfileHueSatMapDims", 50938: "ProfileHueSatMapData1", 50939: "ProfileHueSatMapData2", 50940: "ProfileToneCurve", 50941: "ProfileEmbedPolicy", 50942: "ProfileCopyright", 50964: "ForwardMatrix1", 50965: "ForwardMatrix2", 50966: "PreviewApplicationName", 50967: "PreviewApplicationVersion", 50968: "PreviewSettingsName", 50969: "PreviewSettingsDigest", 50970: "PreviewColorSpace", 50971: "PreviewDateTime", 50972: "RawImageDigest", 50973: "OriginalRawFileDigest", 50974: "SubTileBlockSize", 50975: "RowInterleaveFactor", 50981: "ProfileLookTableDims", 50982: "ProfileLookTableData", 51008: "OpcodeList1", 51009: "OpcodeList2", 51022: "OpcodeList3", 51041: "NoiseProfile", 51043: "TimeCodes", 51044: "FrameRate", 51058: "TStop", 51081: "ReelName", 51089: "OriginalDefaultFinalSize", 51090: "OriginalBestQualitySize", 51091: "OriginalDefaultCropSize", 51105: "CameraLabel", 51107: "ProfileHueSatMapEncoding", 51108: "ProfileLookTableEncoding", 51109: "BaselineExposureOffset", 51110: "DefaultBlackRender", 51111: "NewRawImageDigest", 51112: "RawToPreviewGain", 51125: "DefaultUserCrop", 59932: "Padding", 59933: "OffsetSchema", 65e3: "OwnerName", 65001: "SerialNumber", 65002: "Lens", 65024: "KDC_IFD", 65100: "RawFile", 65101: "Converter", 65102: "WhiteBalance", 65105: "Exposure", 65106: "Shadows", 65107: "Brightness", 65108: "Contrast", 65109: "Saturation", 65110: "Sharpness", 65111: "Smoothness", 65112: "MoireFilter" }, gps: { 0: "GPSVersionID", 1: "GPSLatitudeRef", 2: "GPSLatitude", 3: "GPSLongitudeRef", 4: "GPSLongitude", 5: "GPSAltitudeRef", 6: "GPSAltitude", 7: "GPSTimeStamp", 8: "GPSSatellites", 9: "GPSStatus", 10: "GPSMeasureMode", 11: "GPSDOP", 12: "GPSSpeedRef", 13: "GPSSpeed", 14: "GPSTrackRef", 15: "GPSTrack", 16: "GPSImgDirectionRef", 17: "GPSImgDirection", 18: "GPSMapDatum", 19: "GPSDestLatitudeRef", 20: "GPSDestLatitude", 21: "GPSDestLongitudeRef", 22: "GPSDestLongitude", 23: "GPSDestBearingRef", 24: "GPSDestBearing", 25: "GPSDestDistanceRef", 26: "GPSDestDistance", 27: "GPSProcessingMethod", 28: "GPSAreaInformation", 29: "GPSDateStamp", 30: "GPSDifferential", 31: "GPSHPositioningError" } };
  }, 592: (d) => {
    function l(f, i) {
      switch (f) {
        case 1:
          return i.nextUInt8();
        case 3:
        case 8:
          return i.nextUInt16();
        case 4:
        case 9:
          return i.nextUInt32();
        case 5:
          return [i.nextUInt32(), i.nextUInt32()];
        case 6:
          return i.nextInt8();
        case 10:
          return [i.nextInt32(), i.nextInt32()];
        case 11:
          return i.nextFloat();
        case 12:
          return i.nextDouble();
        default:
          throw new Error("Invalid format while decoding: " + f);
      }
    }
    function s(f, i) {
      var a, t, r = i.nextUInt16(), o = i.nextUInt16(), n = function(v) {
        switch (v) {
          case 1:
          case 2:
          case 6:
          case 7:
            return 1;
          case 3:
          case 8:
            return 2;
          case 4:
          case 9:
          case 11:
            return 4;
          case 5:
          case 10:
          case 12:
            return 8;
          default:
            return 0;
        }
      }(o), u = i.nextUInt32(), p = n * u;
      if (p > 4 && (i = f.openWithOffset(i.nextUInt32())), o === 2) {
        var g = (a = i.nextString(u)).indexOf("\0");
        g !== -1 && (a = a.substr(0, g));
      } else if (o === 7)
        a = i.nextBuffer(u);
      else if (o !== 0)
        for (a = [], t = 0; t < u; ++t)
          a.push(l(o, i));
      return p < 4 && i.skip(4 - p), [r, a, o];
    }
    function e(f, i, a) {
      var t, r, o = i.nextUInt16();
      for (r = 0; r < o; ++r)
        a((t = s(f, i))[0], t[1], t[2]);
    }
    d.exports = { IFD0: 1, IFD1: 2, GPSIFD: 3, SubIFD: 4, InteropIFD: 5, parseTags: function(f, i) {
      var a, t, r, o;
      try {
        a = function(M) {
          if (M.nextString(6) !== "Exif\0\0")
            throw new Error("Invalid EXIF header");
          var G = M.mark(), F = M.nextUInt16();
          if (F === 18761)
            M.setBigEndian(!1);
          else {
            if (F !== 19789)
              throw new Error("Invalid TIFF header");
            M.setBigEndian(!0);
          }
          if (M.nextUInt16() !== 42)
            throw new Error("Invalid TIFF data");
          return G;
        }(f);
      } catch {
        return !1;
      }
      var n = a.openWithOffset(f.nextUInt32()), u = this.IFD0;
      e(a, n, function(M, G, F) {
        switch (M) {
          case 34853:
            r = G[0];
            break;
          case 34665:
            t = G[0];
            break;
          default:
            i(u, M, G, F);
        }
      });
      var p = n.nextUInt32();
      if (p !== 0) {
        var g = a.openWithOffset(p);
        e(a, g, i.bind(null, this.IFD1));
      }
      if (r) {
        var v = a.openWithOffset(r);
        e(a, v, i.bind(null, this.GPSIFD));
      }
      if (t) {
        var x = a.openWithOffset(t), b = this.InteropIFD;
        e(a, x, function(M, G, F) {
          M === 40965 ? o = G[0] : i(b, M, G, F);
        });
      }
      if (o) {
        var w = a.openWithOffset(o);
        e(a, w, i.bind(null, this.InteropIFD));
      }
      return !0;
    } };
  }, 656: (d) => {
    d.exports = { parseSections: function(l, s) {
      var e, f;
      for (l.setBigEndian(!0); l.remainingLength() > 0 && f !== 218; ) {
        if (l.nextUInt8() !== 255)
          throw new Error("Invalid JPEG section offset");
        e = (f = l.nextUInt8()) >= 208 && f <= 217 || f === 218 ? 0 : l.nextUInt16() - 2, s(f, l.branch(0, e)), l.skip(e);
      }
    }, getSizeFromSOFSection: function(l) {
      return l.skip(1), { height: l.nextUInt16(), width: l.nextUInt16() };
    }, getSectionName: function(l) {
      var s, e;
      switch (l) {
        case 216:
          s = "SOI";
          break;
        case 196:
          s = "DHT";
          break;
        case 219:
          s = "DQT";
          break;
        case 221:
          s = "DRI";
          break;
        case 218:
          s = "SOS";
          break;
        case 254:
          s = "COM";
          break;
        case 217:
          s = "EOI";
          break;
        default:
          l >= 224 && l <= 239 ? (s = "APP", e = l - 224) : l >= 192 && l <= 207 && l !== 196 && l !== 200 && l !== 204 ? (s = "SOF", e = l - 192) : l >= 208 && l <= 215 && (s = "RST", e = l - 208);
      }
      var f = { name: s };
      return typeof e == "number" && (f.index = e), f;
    } };
  }, 453: (d, l, s) => {
    var e = s(656), f = s(592), i = s(3814);
    function a(r, o, n, u, p, g, v) {
      this.startMarker = r, this.tags = o, this.imageSize = n, this.thumbnailOffset = u, this.thumbnailLength = p, this.thumbnailType = g, this.app1Offset = v;
    }
    function t(r) {
      this.stream = r, this.flags = { readBinaryTags: !1, resolveTagNames: !0, simplifyValues: !0, imageSize: !0, hidePointers: !0, returnTags: !0 };
    }
    a.prototype = { hasThumbnail: function(r) {
      return !(!this.thumbnailOffset || !this.thumbnailLength || typeof r == "string" && (r.toLowerCase().trim() === "image/jpeg" ? this.thumbnailType !== 6 : r.toLowerCase().trim() !== "image/tiff" || this.thumbnailType !== 1));
    }, getThumbnailOffset: function() {
      return this.app1Offset + 6 + this.thumbnailOffset;
    }, getThumbnailLength: function() {
      return this.thumbnailLength;
    }, getThumbnailBuffer: function() {
      return this._getThumbnailStream().nextBuffer(this.thumbnailLength);
    }, _getThumbnailStream: function() {
      return this.startMarker.openWithOffset(this.getThumbnailOffset());
    }, getImageSize: function() {
      return this.imageSize;
    }, getThumbnailSize: function() {
      var r, o = this._getThumbnailStream();
      return e.parseSections(o, function(n, u) {
        e.getSectionName(n).name === "SOF" && (r = e.getSizeFromSOFSection(u));
      }), r;
    } }, t.prototype = { enableBinaryFields: function(r) {
      return this.flags.readBinaryTags = !!r, this;
    }, enablePointers: function(r) {
      return this.flags.hidePointers = !r, this;
    }, enableTagNames: function(r) {
      return this.flags.resolveTagNames = !!r, this;
    }, enableImageSize: function(r) {
      return this.flags.imageSize = !!r, this;
    }, enableReturnTags: function(r) {
      return this.flags.returnTags = !!r, this;
    }, enableSimpleValues: function(r) {
      return this.flags.simplifyValues = !!r, this;
    }, parse: function() {
      var r, o, n, u, p, g, v, x, b, w = this.stream.mark(), M = w.openWithOffset(0), G = this.flags;
      return G.resolveTagNames && (v = s(3332)), G.resolveTagNames ? (r = {}, x = function(F) {
        return r[F.name];
      }, b = function(F, V) {
        r[F.name] = V;
      }) : (r = [], x = function(F) {
        var V;
        for (V = 0; V < r.length; ++V)
          if (r[V].type === F.type && r[V].section === F.section)
            return r.value;
      }, b = function(F, V) {
        var q;
        for (q = 0; q < r.length; ++q)
          if (r[q].type === F.type && r[q].section === F.section)
            return void (r.value = V);
      }), e.parseSections(M, function(F, V) {
        var q = V.offsetFrom(w);
        F === 225 ? f.parseTags(V, function(I, _, R, W) {
          if (G.readBinaryTags || W !== 7) {
            if (_ === 513) {
              if (n = R[0], G.hidePointers)
                return;
            } else if (_ === 514) {
              if (u = R[0], G.hidePointers)
                return;
            } else if (_ === 259 && (p = R[0], G.hidePointers))
              return;
            if (G.returnTags)
              if (G.simplifyValues && (R = i.simplifyValue(R, W)), G.resolveTagNames) {
                var O = (I === f.GPSIFD ? v.gps : v.exif)[_];
                O || (O = v.exif[_]), r.hasOwnProperty(O) || (r[O] = R);
              } else
                r.push({ section: I, type: _, value: R });
          }
        }) && (g = q) : G.imageSize && e.getSectionName(F).name === "SOF" && (o = e.getSizeFromSOFSection(V));
      }), G.simplifyValues && (i.castDegreeValues(x, b), i.castDateValues(x, b)), new a(w, r, o, n, u, p, g);
    } }, d.exports = t;
  }, 3814: (d, l, s) => {
    var e = s(592), f = s(565), i = [{ section: e.GPSIFD, type: 2, name: "GPSLatitude", refType: 1, refName: "GPSLatitudeRef", posVal: "N" }, { section: e.GPSIFD, type: 4, name: "GPSLongitude", refType: 3, refName: "GPSLongitudeRef", posVal: "E" }], a = [{ section: e.SubIFD, type: 306, name: "ModifyDate" }, { section: e.SubIFD, type: 36867, name: "DateTimeOriginal" }, { section: e.SubIFD, type: 36868, name: "CreateDate" }, { section: e.SubIFD, type: 306, name: "ModifyDate" }];
    d.exports = { castDegreeValues: function(t, r) {
      i.forEach(function(o) {
        var n = t(o);
        if (n) {
          var u = t({ section: o.section, type: o.refType, name: o.refName }) === o.posVal ? 1 : -1, p = (n[0] + n[1] / 60 + n[2] / 3600) * u;
          r(o, p);
        }
      });
    }, castDateValues: function(t, r) {
      a.forEach(function(o) {
        var n = t(o);
        if (n) {
          var u = f.parseExifDate(n);
          u !== void 0 && r(o, u);
        }
      });
    }, simplifyValue: function(t, r) {
      return Array.isArray(t) && (t = t.map(function(o) {
        return r === 10 || r === 5 ? o[0] / o[1] : o;
      })).length === 1 && (t = t[0]), t;
    } };
  }, 8789: (module, __unused_webpack_exports, __webpack_require__) => {
    var Buffer = __webpack_require__(8834).lW;
    const Token = __webpack_require__(5010), strtok3 = __webpack_require__(7378), { stringToBytes, tarHeaderChecksumMatches, uint32SyncSafeToken } = __webpack_require__(7044), supported = __webpack_require__(4078), minimumBytes = 4100;
    async function fromStream(d) {
      const l = await strtok3.fromStream(d);
      try {
        return await fromTokenizer(l);
      } finally {
        await l.close();
      }
    }
    async function fromBuffer(d) {
      if (!(d instanceof Uint8Array || d instanceof ArrayBuffer || Buffer.isBuffer(d)))
        throw new TypeError(`Expected the \`input\` argument to be of type \`Uint8Array\` or \`Buffer\` or \`ArrayBuffer\`, got \`${typeof d}\``);
      const l = d instanceof Buffer ? d : Buffer.from(d);
      if (l && l.length > 1)
        return fromTokenizer(strtok3.fromBuffer(l));
    }
    function _check(d, l, s) {
      s = { offset: 0, ...s };
      for (const [e, f] of l.entries())
        if (s.mask) {
          if (f !== (s.mask[e] & d[e + s.offset]))
            return !1;
        } else if (f !== d[e + s.offset])
          return !1;
      return !0;
    }
    async function fromTokenizer(d) {
      try {
        return _fromTokenizer(d);
      } catch (l) {
        if (!(l instanceof strtok3.EndOfStreamError))
          throw l;
      }
    }
    async function _fromTokenizer(d) {
      let l = Buffer.alloc(minimumBytes);
      const s = (f, i) => _check(l, f, i), e = (f, i) => s(stringToBytes(f), i);
      if (d.fileInfo.size || (d.fileInfo.size = Number.MAX_SAFE_INTEGER), await d.peekBuffer(l, { length: 12, mayBeLess: !0 }), s([66, 77]))
        return { ext: "bmp", mime: "image/bmp" };
      if (s([11, 119]))
        return { ext: "ac3", mime: "audio/vnd.dolby.dd-raw" };
      if (s([120, 1]))
        return { ext: "dmg", mime: "application/x-apple-diskimage" };
      if (s([77, 90]))
        return { ext: "exe", mime: "application/x-msdownload" };
      if (s([37, 33]))
        return await d.peekBuffer(l, { length: 24, mayBeLess: !0 }), e("PS-Adobe-", { offset: 2 }) && e(" EPSF-", { offset: 14 }) ? { ext: "eps", mime: "application/eps" } : { ext: "ps", mime: "application/postscript" };
      if (s([31, 160]) || s([31, 157]))
        return { ext: "Z", mime: "application/x-compress" };
      if (s([255, 216, 255]))
        return { ext: "jpg", mime: "image/jpeg" };
      if (s([73, 73, 188]))
        return { ext: "jxr", mime: "image/vnd.ms-photo" };
      if (s([31, 139, 8]))
        return { ext: "gz", mime: "application/gzip" };
      if (s([66, 90, 104]))
        return { ext: "bz2", mime: "application/x-bzip2" };
      if (e("ID3")) {
        await d.ignore(6);
        const f = await d.readToken(uint32SyncSafeToken);
        return d.position + f > d.fileInfo.size ? { ext: "mp3", mime: "audio/mpeg" } : (await d.ignore(f), fromTokenizer(d));
      }
      if (e("MP+"))
        return { ext: "mpc", mime: "audio/x-musepack" };
      if ((l[0] === 67 || l[0] === 70) && s([87, 83], { offset: 1 }))
        return { ext: "swf", mime: "application/x-shockwave-flash" };
      if (s([71, 73, 70]))
        return { ext: "gif", mime: "image/gif" };
      if (e("FLIF"))
        return { ext: "flif", mime: "image/flif" };
      if (e("8BPS"))
        return { ext: "psd", mime: "image/vnd.adobe.photoshop" };
      if (e("WEBP", { offset: 8 }))
        return { ext: "webp", mime: "image/webp" };
      if (e("MPCK"))
        return { ext: "mpc", mime: "audio/x-musepack" };
      if (e("FORM"))
        return { ext: "aif", mime: "audio/aiff" };
      if (e("icns", { offset: 0 }))
        return { ext: "icns", mime: "image/icns" };
      if (s([80, 75, 3, 4])) {
        try {
          for (; d.position + 30 < d.fileInfo.size; ) {
            await d.readBuffer(l, { length: 30 });
            const f = { compressedSize: l.readUInt32LE(18), uncompressedSize: l.readUInt32LE(22), filenameLength: l.readUInt16LE(26), extraFieldLength: l.readUInt16LE(28) };
            if (f.filename = await d.readToken(new Token.StringType(f.filenameLength, "utf-8")), await d.ignore(f.extraFieldLength), f.filename === "META-INF/mozilla.rsa")
              return { ext: "xpi", mime: "application/x-xpinstall" };
            if (f.filename.endsWith(".rels") || f.filename.endsWith(".xml"))
              switch (f.filename.split("/")[0]) {
                case "_rels":
                default:
                  break;
                case "word":
                  return { ext: "docx", mime: "application/vnd.openxmlformats-officedocument.wordprocessingml.document" };
                case "ppt":
                  return { ext: "pptx", mime: "application/vnd.openxmlformats-officedocument.presentationml.presentation" };
                case "xl":
                  return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
              }
            if (f.filename.startsWith("xl/"))
              return { ext: "xlsx", mime: "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" };
            if (f.filename.startsWith("3D/") && f.filename.endsWith(".model"))
              return { ext: "3mf", mime: "model/3mf" };
            if (f.filename === "mimetype" && f.compressedSize === f.uncompressedSize)
              switch (await d.readToken(new Token.StringType(f.compressedSize, "utf-8"))) {
                case "application/epub+zip":
                  return { ext: "epub", mime: "application/epub+zip" };
                case "application/vnd.oasis.opendocument.text":
                  return { ext: "odt", mime: "application/vnd.oasis.opendocument.text" };
                case "application/vnd.oasis.opendocument.spreadsheet":
                  return { ext: "ods", mime: "application/vnd.oasis.opendocument.spreadsheet" };
                case "application/vnd.oasis.opendocument.presentation":
                  return { ext: "odp", mime: "application/vnd.oasis.opendocument.presentation" };
              }
            if (f.compressedSize === 0) {
              let i = -1;
              for (; i < 0 && d.position < d.fileInfo.size; )
                await d.peekBuffer(l, { mayBeLess: !0 }), i = l.indexOf("504B0304", 0, "hex"), await d.ignore(i >= 0 ? i : l.length);
            } else
              await d.ignore(f.compressedSize);
          }
        } catch (f) {
          if (!(f instanceof strtok3.EndOfStreamError))
            throw f;
        }
        return { ext: "zip", mime: "application/zip" };
      }
      if (e("OggS")) {
        await d.ignore(28);
        const f = Buffer.alloc(8);
        return await d.readBuffer(f), _check(f, [79, 112, 117, 115, 72, 101, 97, 100]) ? { ext: "opus", mime: "audio/opus" } : _check(f, [128, 116, 104, 101, 111, 114, 97]) ? { ext: "ogv", mime: "video/ogg" } : _check(f, [1, 118, 105, 100, 101, 111, 0]) ? { ext: "ogm", mime: "video/ogg" } : _check(f, [127, 70, 76, 65, 67]) ? { ext: "oga", mime: "audio/ogg" } : _check(f, [83, 112, 101, 101, 120, 32, 32]) ? { ext: "spx", mime: "audio/ogg" } : _check(f, [1, 118, 111, 114, 98, 105, 115]) ? { ext: "ogg", mime: "audio/ogg" } : { ext: "ogx", mime: "application/ogg" };
      }
      if (s([80, 75]) && (l[2] === 3 || l[2] === 5 || l[2] === 7) && (l[3] === 4 || l[3] === 6 || l[3] === 8))
        return { ext: "zip", mime: "application/zip" };
      if (e("ftyp", { offset: 4 }) && 96 & l[8]) {
        const f = l.toString("binary", 8, 12).replace("\0", " ").trim();
        switch (f) {
          case "avif":
            return { ext: "avif", mime: "image/avif" };
          case "mif1":
            return { ext: "heic", mime: "image/heif" };
          case "msf1":
            return { ext: "heic", mime: "image/heif-sequence" };
          case "heic":
          case "heix":
            return { ext: "heic", mime: "image/heic" };
          case "hevc":
          case "hevx":
            return { ext: "heic", mime: "image/heic-sequence" };
          case "qt":
            return { ext: "mov", mime: "video/quicktime" };
          case "M4V":
          case "M4VH":
          case "M4VP":
            return { ext: "m4v", mime: "video/x-m4v" };
          case "M4P":
            return { ext: "m4p", mime: "video/mp4" };
          case "M4B":
            return { ext: "m4b", mime: "audio/mp4" };
          case "M4A":
            return { ext: "m4a", mime: "audio/x-m4a" };
          case "F4V":
            return { ext: "f4v", mime: "video/mp4" };
          case "F4P":
            return { ext: "f4p", mime: "video/mp4" };
          case "F4A":
            return { ext: "f4a", mime: "audio/mp4" };
          case "F4B":
            return { ext: "f4b", mime: "audio/mp4" };
          case "crx":
            return { ext: "cr3", mime: "image/x-canon-cr3" };
          default:
            return f.startsWith("3g") ? f.startsWith("3g2") ? { ext: "3g2", mime: "video/3gpp2" } : { ext: "3gp", mime: "video/3gpp" } : { ext: "mp4", mime: "video/mp4" };
        }
      }
      if (e("MThd"))
        return { ext: "mid", mime: "audio/midi" };
      if (e("wOFF") && (s([0, 1, 0, 0], { offset: 4 }) || e("OTTO", { offset: 4 })))
        return { ext: "woff", mime: "font/woff" };
      if (e("wOF2") && (s([0, 1, 0, 0], { offset: 4 }) || e("OTTO", { offset: 4 })))
        return { ext: "woff2", mime: "font/woff2" };
      if (s([212, 195, 178, 161]) || s([161, 178, 195, 212]))
        return { ext: "pcap", mime: "application/vnd.tcpdump.pcap" };
      if (e("DSD "))
        return { ext: "dsf", mime: "audio/x-dsf" };
      if (e("LZIP"))
        return { ext: "lz", mime: "application/x-lzip" };
      if (e("fLaC"))
        return { ext: "flac", mime: "audio/x-flac" };
      if (s([66, 80, 71, 251]))
        return { ext: "bpg", mime: "image/bpg" };
      if (e("wvpk"))
        return { ext: "wv", mime: "audio/wavpack" };
      if (e("%PDF")) {
        await d.ignore(1350);
        const f = 10485760, i = Buffer.alloc(Math.min(f, d.fileInfo.size));
        return await d.readBuffer(i, { mayBeLess: !0 }), i.includes(Buffer.from("AIPrivateData")) ? { ext: "ai", mime: "application/postscript" } : { ext: "pdf", mime: "application/pdf" };
      }
      if (s([0, 97, 115, 109]))
        return { ext: "wasm", mime: "application/wasm" };
      if (s([73, 73, 42, 0]))
        return e("CR", { offset: 8 }) ? { ext: "cr2", mime: "image/x-canon-cr2" } : s([28, 0, 254, 0], { offset: 8 }) || s([31, 0, 11, 0], { offset: 8 }) ? { ext: "nef", mime: "image/x-nikon-nef" } : s([8, 0, 0, 0], { offset: 4 }) && (s([45, 0, 254, 0], { offset: 8 }) || s([39, 0, 254, 0], { offset: 8 })) ? { ext: "dng", mime: "image/x-adobe-dng" } : (l = Buffer.alloc(24), await d.peekBuffer(l), (s([16, 251, 134, 1], { offset: 4 }) || s([8, 0, 0, 0], { offset: 4 })) && s([0, 254, 0, 4, 0, 1, 0, 0, 0, 1, 0, 0, 0, 3, 1], { offset: 9 }) ? { ext: "arw", mime: "image/x-sony-arw" } : { ext: "tif", mime: "image/tiff" });
      if (s([77, 77, 0, 42]))
        return { ext: "tif", mime: "image/tiff" };
      if (e("MAC "))
        return { ext: "ape", mime: "audio/ape" };
      if (s([26, 69, 223, 163])) {
        async function f() {
          const r = await d.peekNumber(Token.UINT8);
          let o = 128, n = 0;
          for (; !(r & o) && o !== 0; )
            ++n, o >>= 1;
          const u = Buffer.alloc(n + 1);
          return await d.readBuffer(u), u;
        }
        async function i() {
          const r = await f(), o = await f();
          o[0] ^= 128 >> o.length - 1;
          const n = Math.min(6, o.length);
          return { id: r.readUIntBE(0, r.length), len: o.readUIntBE(o.length - n, n) };
        }
        async function a(r, o) {
          for (; o > 0; ) {
            const n = await i();
            if (n.id === 17026)
              return d.readToken(new Token.StringType(n.len, "utf-8"));
            await d.ignore(n.len), --o;
          }
        }
        const t = await i();
        switch (await a(0, t.len)) {
          case "webm":
            return { ext: "webm", mime: "video/webm" };
          case "matroska":
            return { ext: "mkv", mime: "video/x-matroska" };
          default:
            return;
        }
      }
      if (s([82, 73, 70, 70])) {
        if (s([65, 86, 73], { offset: 8 }))
          return { ext: "avi", mime: "video/vnd.avi" };
        if (s([87, 65, 86, 69], { offset: 8 }))
          return { ext: "wav", mime: "audio/vnd.wave" };
        if (s([81, 76, 67, 77], { offset: 8 }))
          return { ext: "qcp", mime: "audio/qcelp" };
      }
      if (e("SQLi"))
        return { ext: "sqlite", mime: "application/x-sqlite3" };
      if (s([78, 69, 83, 26]))
        return { ext: "nes", mime: "application/x-nintendo-nes-rom" };
      if (e("Cr24"))
        return { ext: "crx", mime: "application/x-google-chrome-extension" };
      if (e("MSCF") || e("ISc("))
        return { ext: "cab", mime: "application/vnd.ms-cab-compressed" };
      if (s([237, 171, 238, 219]))
        return { ext: "rpm", mime: "application/x-rpm" };
      if (s([197, 208, 211, 198]))
        return { ext: "eps", mime: "application/eps" };
      if (s([40, 181, 47, 253]))
        return { ext: "zst", mime: "application/zstd" };
      if (s([79, 84, 84, 79, 0]))
        return { ext: "otf", mime: "font/otf" };
      if (e("#!AMR"))
        return { ext: "amr", mime: "audio/amr" };
      if (e("{\\rtf"))
        return { ext: "rtf", mime: "application/rtf" };
      if (s([70, 76, 86, 1]))
        return { ext: "flv", mime: "video/x-flv" };
      if (e("IMPM"))
        return { ext: "it", mime: "audio/x-it" };
      if (e("-lh0-", { offset: 2 }) || e("-lh1-", { offset: 2 }) || e("-lh2-", { offset: 2 }) || e("-lh3-", { offset: 2 }) || e("-lh4-", { offset: 2 }) || e("-lh5-", { offset: 2 }) || e("-lh6-", { offset: 2 }) || e("-lh7-", { offset: 2 }) || e("-lzs-", { offset: 2 }) || e("-lz4-", { offset: 2 }) || e("-lz5-", { offset: 2 }) || e("-lhd-", { offset: 2 }))
        return { ext: "lzh", mime: "application/x-lzh-compressed" };
      if (s([0, 0, 1, 186])) {
        if (s([33], { offset: 4, mask: [241] }))
          return { ext: "mpg", mime: "video/MP1S" };
        if (s([68], { offset: 4, mask: [196] }))
          return { ext: "mpg", mime: "video/MP2P" };
      }
      if (e("ITSF"))
        return { ext: "chm", mime: "application/vnd.ms-htmlhelp" };
      if (s([253, 55, 122, 88, 90, 0]))
        return { ext: "xz", mime: "application/x-xz" };
      if (e("<?xml "))
        return { ext: "xml", mime: "application/xml" };
      if (s([55, 122, 188, 175, 39, 28]))
        return { ext: "7z", mime: "application/x-7z-compressed" };
      if (s([82, 97, 114, 33, 26, 7]) && (l[6] === 0 || l[6] === 1))
        return { ext: "rar", mime: "application/x-rar-compressed" };
      if (e("solid "))
        return { ext: "stl", mime: "model/stl" };
      if (e("BLENDER"))
        return { ext: "blend", mime: "application/x-blender" };
      if (e("!<arch>"))
        return await d.ignore(8), await d.readToken(new Token.StringType(13, "ascii")) === "debian-binary" ? { ext: "deb", mime: "application/x-deb" } : { ext: "ar", mime: "application/x-unix-archive" };
      if (s([137, 80, 78, 71, 13, 10, 26, 10])) {
        async function f() {
          return { length: await d.readToken(Token.INT32_BE), type: await d.readToken(new Token.StringType(4, "binary")) };
        }
        await d.ignore(8);
        do {
          const i = await f();
          if (i.length < 0)
            return;
          switch (i.type) {
            case "IDAT":
              return { ext: "png", mime: "image/png" };
            case "acTL":
              return { ext: "apng", mime: "image/apng" };
            default:
              await d.ignore(i.length + 4);
          }
        } while (d.position + 8 < d.fileInfo.size);
        return { ext: "png", mime: "image/png" };
      }
      if (s([65, 82, 82, 79, 87, 49, 0, 0]))
        return { ext: "arrow", mime: "application/x-apache-arrow" };
      if (s([103, 108, 84, 70, 2, 0, 0, 0]))
        return { ext: "glb", mime: "model/gltf-binary" };
      if (s([102, 114, 101, 101], { offset: 4 }) || s([109, 100, 97, 116], { offset: 4 }) || s([109, 111, 111, 118], { offset: 4 }) || s([119, 105, 100, 101], { offset: 4 }))
        return { ext: "mov", mime: "video/quicktime" };
      if (s([73, 73, 82, 79, 8, 0, 0, 0, 24]))
        return { ext: "orf", mime: "image/x-olympus-orf" };
      if (e("gimp xcf "))
        return { ext: "xcf", mime: "image/x-xcf" };
      if (s([73, 73, 85, 0, 24, 0, 0, 0, 136, 231, 116, 216]))
        return { ext: "rw2", mime: "image/x-panasonic-rw2" };
      if (s([48, 38, 178, 117, 142, 102, 207, 17, 166, 217])) {
        async function f() {
          const i = Buffer.alloc(16);
          return await d.readBuffer(i), { id: i, size: Number(await d.readToken(Token.UINT64_LE)) };
        }
        for (await d.ignore(30); d.position + 24 < d.fileInfo.size; ) {
          const i = await f();
          let a = i.size - 24;
          if (_check(i.id, [145, 7, 220, 183, 183, 169, 207, 17, 142, 230, 0, 192, 12, 32, 83, 101])) {
            const t = Buffer.alloc(16);
            if (a -= await d.readBuffer(t), _check(t, [64, 158, 105, 248, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
              return { ext: "asf", mime: "audio/x-ms-asf" };
            if (_check(t, [192, 239, 25, 188, 77, 91, 207, 17, 168, 253, 0, 128, 95, 92, 68, 43]))
              return { ext: "asf", mime: "video/x-ms-asf" };
            break;
          }
          await d.ignore(a);
        }
        return { ext: "asf", mime: "application/vnd.ms-asf" };
      }
      if (s([171, 75, 84, 88, 32, 49, 49, 187, 13, 10, 26, 10]))
        return { ext: "ktx", mime: "image/ktx" };
      if ((s([126, 16, 4]) || s([126, 24, 4])) && s([48, 77, 73, 69], { offset: 4 }))
        return { ext: "mie", mime: "application/x-mie" };
      if (s([39, 10, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], { offset: 2 }))
        return { ext: "shp", mime: "application/x-esri-shape" };
      if (s([0, 0, 0, 12, 106, 80, 32, 32, 13, 10, 135, 10]))
        switch (await d.ignore(20), await d.readToken(new Token.StringType(4, "ascii"))) {
          case "jp2 ":
            return { ext: "jp2", mime: "image/jp2" };
          case "jpx ":
            return { ext: "jpx", mime: "image/jpx" };
          case "jpm ":
            return { ext: "jpm", mime: "image/jpm" };
          case "mjp2":
            return { ext: "mj2", mime: "image/mj2" };
          default:
            return;
        }
      if (s([255, 10]) || s([0, 0, 0, 12, 74, 88, 76, 32, 13, 10, 135, 10]))
        return { ext: "jxl", mime: "image/jxl" };
      if (s([0, 0, 1, 186]) || s([0, 0, 1, 179]))
        return { ext: "mpg", mime: "video/mpeg" };
      if (s([0, 1, 0, 0, 0]))
        return { ext: "ttf", mime: "font/ttf" };
      if (s([0, 0, 1, 0]))
        return { ext: "ico", mime: "image/x-icon" };
      if (s([0, 0, 2, 0]))
        return { ext: "cur", mime: "image/x-icon" };
      if (s([208, 207, 17, 224, 161, 177, 26, 225]))
        return { ext: "cfb", mime: "application/x-cfb" };
      if (await d.peekBuffer(l, { length: Math.min(256, d.fileInfo.size), mayBeLess: !0 }), e("BEGIN:")) {
        if (e("VCARD", { offset: 6 }))
          return { ext: "vcf", mime: "text/vcard" };
        if (e("VCALENDAR", { offset: 6 }))
          return { ext: "ics", mime: "text/calendar" };
      }
      if (e("FUJIFILMCCD-RAW"))
        return { ext: "raf", mime: "image/x-fujifilm-raf" };
      if (e("Extended Module:"))
        return { ext: "xm", mime: "audio/x-xm" };
      if (e("Creative Voice File"))
        return { ext: "voc", mime: "audio/x-voc" };
      if (s([4, 0, 0, 0]) && l.length >= 16) {
        const f = l.readUInt32LE(12);
        if (f > 12 && l.length >= f + 16)
          try {
            const i = l.slice(16, f + 16).toString();
            if (JSON.parse(i).files)
              return { ext: "asar", mime: "application/x-asar" };
          } catch {
          }
      }
      if (s([6, 14, 43, 52, 2, 5, 1, 1, 13, 1, 2, 1, 1, 2]))
        return { ext: "mxf", mime: "application/mxf" };
      if (e("SCRM", { offset: 44 }))
        return { ext: "s3m", mime: "audio/x-s3m" };
      if (s([71], { offset: 4 }) && (s([71], { offset: 192 }) || s([71], { offset: 196 })))
        return { ext: "mts", mime: "video/mp2t" };
      if (s([66, 79, 79, 75, 77, 79, 66, 73], { offset: 60 }))
        return { ext: "mobi", mime: "application/x-mobipocket-ebook" };
      if (s([68, 73, 67, 77], { offset: 128 }))
        return { ext: "dcm", mime: "application/dicom" };
      if (s([76, 0, 0, 0, 1, 20, 2, 0, 0, 0, 0, 0, 192, 0, 0, 0, 0, 0, 0, 70]))
        return { ext: "lnk", mime: "application/x.ms.shortcut" };
      if (s([98, 111, 111, 107, 0, 0, 0, 0, 109, 97, 114, 107, 0, 0, 0, 0]))
        return { ext: "alias", mime: "application/x.apple.alias" };
      if (s([76, 80], { offset: 34 }) && (s([0, 0, 1], { offset: 8 }) || s([1, 0, 2], { offset: 8 }) || s([2, 0, 2], { offset: 8 })))
        return { ext: "eot", mime: "application/vnd.ms-fontobject" };
      if (s([6, 6, 237, 245, 216, 29, 70, 229, 189, 49, 239, 231, 254, 116, 183, 29]))
        return { ext: "indd", mime: "application/x-indesign" };
      if (await d.peekBuffer(l, { length: Math.min(512, d.fileInfo.size), mayBeLess: !0 }), tarHeaderChecksumMatches(l))
        return { ext: "tar", mime: "application/x-tar" };
      if (s([255, 254, 255, 14, 83, 0, 107, 0, 101, 0, 116, 0, 99, 0, 104, 0, 85, 0, 112, 0, 32, 0, 77, 0, 111, 0, 100, 0, 101, 0, 108, 0]))
        return { ext: "skp", mime: "application/vnd.sketchup.skp" };
      if (e("-----BEGIN PGP MESSAGE-----"))
        return { ext: "pgp", mime: "application/pgp-encrypted" };
      if (l.length >= 2 && s([255, 224], { offset: 0, mask: [255, 224] })) {
        if (s([16], { offset: 1, mask: [22] }))
          return s([8], { offset: 1, mask: [8] }), { ext: "aac", mime: "audio/aac" };
        if (s([2], { offset: 1, mask: [6] }))
          return { ext: "mp3", mime: "audio/mpeg" };
        if (s([4], { offset: 1, mask: [6] }))
          return { ext: "mp2", mime: "audio/mpeg" };
        if (s([6], { offset: 1, mask: [6] }))
          return { ext: "mp1", mime: "audio/mpeg" };
      }
    }
    const stream = (readableStream) => new Promise((resolve, reject) => {
      const stream = eval("require")("stream");
      readableStream.on("error", reject), readableStream.once("readable", async () => {
        const d = new stream.PassThrough();
        let l;
        l = stream.pipeline ? stream.pipeline(readableStream, d, () => {
        }) : readableStream.pipe(d);
        const s = readableStream.read(minimumBytes) || readableStream.read() || Buffer.alloc(0);
        try {
          const e = await fromBuffer(s);
          d.fileType = e;
        } catch (e) {
          reject(e);
        }
        resolve(l);
      });
    }), fileType = { fromStream, fromTokenizer, fromBuffer, stream };
    Object.defineProperty(fileType, "extensions", { get: () => new Set(supported.extensions) }), Object.defineProperty(fileType, "mimeTypes", { get: () => new Set(supported.mimeTypes) }), module.exports = fileType;
  }, 5025: (d, l, s) => {
    const e = s(3569), f = s(8789), i = { fromFile: async function(a) {
      const t = await e.fromFile(a);
      try {
        return await f.fromTokenizer(t);
      } finally {
        await t.close();
      }
    } };
    Object.assign(i, f), Object.defineProperty(i, "extensions", { get: () => f.extensions }), Object.defineProperty(i, "mimeTypes", { get: () => f.mimeTypes }), d.exports = i;
  }, 4078: (d) => {
    d.exports = { extensions: ["jpg", "png", "apng", "gif", "webp", "flif", "xcf", "cr2", "cr3", "orf", "arw", "dng", "nef", "rw2", "raf", "tif", "bmp", "icns", "jxr", "psd", "indd", "zip", "tar", "rar", "gz", "bz2", "7z", "dmg", "mp4", "mid", "mkv", "webm", "mov", "avi", "mpg", "mp2", "mp3", "m4a", "oga", "ogg", "ogv", "opus", "flac", "wav", "spx", "amr", "pdf", "epub", "exe", "swf", "rtf", "wasm", "woff", "woff2", "eot", "ttf", "otf", "ico", "flv", "ps", "xz", "sqlite", "nes", "crx", "xpi", "cab", "deb", "ar", "rpm", "Z", "lz", "cfb", "mxf", "mts", "blend", "bpg", "docx", "pptx", "xlsx", "3gp", "3g2", "jp2", "jpm", "jpx", "mj2", "aif", "qcp", "odt", "ods", "odp", "xml", "mobi", "heic", "cur", "ktx", "ape", "wv", "dcm", "ics", "glb", "pcap", "dsf", "lnk", "alias", "voc", "ac3", "m4v", "m4p", "m4b", "f4v", "f4p", "f4b", "f4a", "mie", "asf", "ogm", "ogx", "mpc", "arrow", "shp", "aac", "mp1", "it", "s3m", "xm", "ai", "skp", "avif", "eps", "lzh", "pgp", "asar", "stl", "chm", "3mf", "zst", "jxl", "vcf"], mimeTypes: ["image/jpeg", "image/png", "image/gif", "image/webp", "image/flif", "image/x-xcf", "image/x-canon-cr2", "image/x-canon-cr3", "image/tiff", "image/bmp", "image/vnd.ms-photo", "image/vnd.adobe.photoshop", "application/x-indesign", "application/epub+zip", "application/x-xpinstall", "application/vnd.oasis.opendocument.text", "application/vnd.oasis.opendocument.spreadsheet", "application/vnd.oasis.opendocument.presentation", "application/vnd.openxmlformats-officedocument.wordprocessingml.document", "application/vnd.openxmlformats-officedocument.presentationml.presentation", "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet", "application/zip", "application/x-tar", "application/x-rar-compressed", "application/gzip", "application/x-bzip2", "application/x-7z-compressed", "application/x-apple-diskimage", "application/x-apache-arrow", "video/mp4", "audio/midi", "video/x-matroska", "video/webm", "video/quicktime", "video/vnd.avi", "audio/vnd.wave", "audio/qcelp", "audio/x-ms-asf", "video/x-ms-asf", "application/vnd.ms-asf", "video/mpeg", "video/3gpp", "audio/mpeg", "audio/mp4", "audio/opus", "video/ogg", "audio/ogg", "application/ogg", "audio/x-flac", "audio/ape", "audio/wavpack", "audio/amr", "application/pdf", "application/x-msdownload", "application/x-shockwave-flash", "application/rtf", "application/wasm", "font/woff", "font/woff2", "application/vnd.ms-fontobject", "font/ttf", "font/otf", "image/x-icon", "video/x-flv", "application/postscript", "application/eps", "application/x-xz", "application/x-sqlite3", "application/x-nintendo-nes-rom", "application/x-google-chrome-extension", "application/vnd.ms-cab-compressed", "application/x-deb", "application/x-unix-archive", "application/x-rpm", "application/x-compress", "application/x-lzip", "application/x-cfb", "application/x-mie", "application/mxf", "video/mp2t", "application/x-blender", "image/bpg", "image/jp2", "image/jpx", "image/jpm", "image/mj2", "audio/aiff", "application/xml", "application/x-mobipocket-ebook", "image/heif", "image/heif-sequence", "image/heic", "image/heic-sequence", "image/icns", "image/ktx", "application/dicom", "audio/x-musepack", "text/calendar", "text/vcard", "model/gltf-binary", "application/vnd.tcpdump.pcap", "audio/x-dsf", "application/x.ms.shortcut", "application/x.apple.alias", "audio/x-voc", "audio/vnd.dolby.dd-raw", "audio/x-m4a", "image/apng", "image/x-olympus-orf", "image/x-sony-arw", "image/x-adobe-dng", "image/x-nikon-nef", "image/x-panasonic-rw2", "image/x-fujifilm-raf", "video/x-m4v", "video/3gpp2", "application/x-esri-shape", "audio/aac", "audio/x-it", "audio/x-s3m", "audio/x-xm", "video/MP1S", "video/MP2P", "application/vnd.sketchup.skp", "image/avif", "application/x-lzh-compressed", "application/pgp-encrypted", "application/x-asar", "model/stl", "application/vnd.ms-htmlhelp", "model/3mf", "image/jxl", "application/zstd"] };
  }, 7044: (d, l) => {
    l.stringToBytes = (s) => [...s].map((e) => e.charCodeAt(0)), l.tarHeaderChecksumMatches = (s, e = 0) => {
      const f = parseInt(s.toString("utf8", 148, 154).replace(/\0.*$/, "").trim(), 8);
      if (isNaN(f))
        return !1;
      let i = 256;
      for (let a = e; a < e + 148; a++)
        i += s[a];
      for (let a = e + 156; a < e + 512; a++)
        i += s[a];
      return f === i;
    }, l.uint32SyncSafeToken = { get: (s, e) => 127 & s[e + 3] | s[e + 2] << 7 | s[e + 1] << 14 | s[e] << 21, len: 4 };
  }, 3243: (d, l, s) => {
    var e = s(9680), f = Object.prototype.toString, i = Object.prototype.hasOwnProperty, a = function(o, n, u) {
      for (var p = 0, g = o.length; p < g; p++)
        i.call(o, p) && (u == null ? n(o[p], p, o) : n.call(u, o[p], p, o));
    }, t = function(o, n, u) {
      for (var p = 0, g = o.length; p < g; p++)
        u == null ? n(o.charAt(p), p, o) : n.call(u, o.charAt(p), p, o);
    }, r = function(o, n, u) {
      for (var p in o)
        i.call(o, p) && (u == null ? n(o[p], p, o) : n.call(u, o[p], p, o));
    };
    d.exports = function(o, n, u) {
      if (!e(n))
        throw new TypeError("iterator must be a function");
      var p;
      arguments.length >= 3 && (p = u), f.call(o) === "[object Array]" ? a(o, n, p) : typeof o == "string" ? t(o, n, p) : r(o, n, p);
    };
  }, 2855: (d, l) => {
    function s(e, f, i, a) {
      for (var t = e[f++], r = 1 << t, o = r + 1, n = o + 1, u = t + 1, p = (1 << u) - 1, g = 0, v = 0, x = 0, b = e[f++], w = new Int32Array(4096), M = null; ; ) {
        for (; g < 16 && b !== 0; )
          v |= e[f++] << g, g += 8, b === 1 ? b = e[f++] : --b;
        if (g < u)
          break;
        var G = v & p;
        if (v >>= u, g -= u, G !== r) {
          if (G === o)
            break;
          for (var F = G < n ? G : M, V = 0, q = F; q > r; )
            q = w[q] >> 8, ++V;
          var I = q;
          if (x + V + (F !== G ? 1 : 0) > a)
            return void console.log("Warning, gif stream longer than expected.");
          i[x++] = I;
          var _ = x += V;
          for (F !== G && (i[x++] = I), q = F; V--; )
            q = w[q], i[--_] = 255 & q, q >>= 8;
          M !== null && n < 4096 && (w[n++] = M << 8 | I, n >= p + 1 && u < 12 && (++u, p = p << 1 | 1)), M = G;
        } else
          n = o + 1, p = (1 << (u = t + 1)) - 1, M = null;
      }
      return x !== a && console.log("Warning, gif stream shorter than expected."), i;
    }
    try {
      l.GifWriter = function(e, f, i, a) {
        var t = 0, r = (a = a === void 0 ? {} : a).loop === void 0 ? null : a.loop, o = a.palette === void 0 ? null : a.palette;
        if (f <= 0 || i <= 0 || f > 65535 || i > 65535)
          throw new Error("Width/Height invalid.");
        function n(M) {
          var G = M.length;
          if (G < 2 || G > 256 || G & G - 1)
            throw new Error("Invalid code/color length, must be power of 2 and 2 .. 256.");
          return G;
        }
        e[t++] = 71, e[t++] = 73, e[t++] = 70, e[t++] = 56, e[t++] = 57, e[t++] = 97;
        var u = 0, p = 0;
        if (o !== null) {
          for (var g = n(o); g >>= 1; )
            ++u;
          if (g = 1 << u, --u, a.background !== void 0) {
            if ((p = a.background) >= g)
              throw new Error("Background index out of range.");
            if (p === 0)
              throw new Error("Background index explicitly passed as 0.");
          }
        }
        if (e[t++] = 255 & f, e[t++] = f >> 8 & 255, e[t++] = 255 & i, e[t++] = i >> 8 & 255, e[t++] = (o !== null ? 128 : 0) | u, e[t++] = p, e[t++] = 0, o !== null)
          for (var v = 0, x = o.length; v < x; ++v) {
            var b = o[v];
            e[t++] = b >> 16 & 255, e[t++] = b >> 8 & 255, e[t++] = 255 & b;
          }
        if (r !== null) {
          if (r < 0 || r > 65535)
            throw new Error("Loop count invalid.");
          e[t++] = 33, e[t++] = 255, e[t++] = 11, e[t++] = 78, e[t++] = 69, e[t++] = 84, e[t++] = 83, e[t++] = 67, e[t++] = 65, e[t++] = 80, e[t++] = 69, e[t++] = 50, e[t++] = 46, e[t++] = 48, e[t++] = 3, e[t++] = 1, e[t++] = 255 & r, e[t++] = r >> 8 & 255, e[t++] = 0;
        }
        var w = !1;
        this.addFrame = function(M, G, F, V, q, I) {
          if (w === !0 && (--t, w = !1), I = I === void 0 ? {} : I, M < 0 || G < 0 || M > 65535 || G > 65535)
            throw new Error("x/y invalid.");
          if (F <= 0 || V <= 0 || F > 65535 || V > 65535)
            throw new Error("Width/Height invalid.");
          if (q.length < F * V)
            throw new Error("Not enough pixels for the frame size.");
          var _ = !0, R = I.palette;
          if (R == null && (_ = !1, R = o), R == null)
            throw new Error("Must supply either a local or global palette.");
          for (var W = n(R), O = 0; W >>= 1; )
            ++O;
          W = 1 << O;
          var j = I.delay === void 0 ? 0 : I.delay, U = I.disposal === void 0 ? 0 : I.disposal;
          if (U < 0 || U > 3)
            throw new Error("Disposal out of range.");
          var C = !1, ae = 0;
          if (I.transparent !== void 0 && I.transparent !== null && (C = !0, (ae = I.transparent) < 0 || ae >= W))
            throw new Error("Transparent color index.");
          if ((U !== 0 || C || j !== 0) && (e[t++] = 33, e[t++] = 249, e[t++] = 4, e[t++] = U << 2 | (C === !0 ? 1 : 0), e[t++] = 255 & j, e[t++] = j >> 8 & 255, e[t++] = ae, e[t++] = 0), e[t++] = 44, e[t++] = 255 & M, e[t++] = M >> 8 & 255, e[t++] = 255 & G, e[t++] = G >> 8 & 255, e[t++] = 255 & F, e[t++] = F >> 8 & 255, e[t++] = 255 & V, e[t++] = V >> 8 & 255, e[t++] = _ === !0 ? 128 | O - 1 : 0, _ === !0)
            for (var J = 0, te = R.length; J < te; ++J) {
              var $ = R[J];
              e[t++] = $ >> 16 & 255, e[t++] = $ >> 8 & 255, e[t++] = 255 & $;
            }
          return t = function(L, re, z, N) {
            L[re++] = z;
            var ne = re++, le = 1 << z, he = le - 1, k = le + 1, T = k + 1, B = z + 1, K = 0, h = 0;
            function c(Ee) {
              for (; K >= Ee; )
                L[re++] = 255 & h, h >>= 8, K -= 8, re === ne + 256 && (L[ne] = 255, ne = re++);
            }
            function m(Ee) {
              h |= Ee << K, K += B, c(8);
            }
            var D = N[0] & he, ee = {};
            m(le);
            for (var E = 1, Q = N.length; E < Q; ++E) {
              var se = N[E] & he, Y = D << 8 | se, be = ee[Y];
              if (be === void 0) {
                for (h |= D << K, K += B; K >= 8; )
                  L[re++] = 255 & h, h >>= 8, K -= 8, re === ne + 256 && (L[ne] = 255, ne = re++);
                T === 4096 ? (m(le), T = k + 1, B = z + 1, ee = {}) : (T >= 1 << B && ++B, ee[Y] = T++), D = se;
              } else
                D = be;
            }
            return m(D), m(k), c(1), ne + 1 === re ? L[ne] = 0 : (L[ne] = re - ne - 1, L[re++] = 0), re;
          }(e, t, O < 2 ? 2 : O, q), t;
        }, this.end = function() {
          return w === !1 && (e[t++] = 59, w = !0), t;
        }, this.getOutputBuffer = function() {
          return e;
        }, this.setOutputBuffer = function(M) {
          e = M;
        }, this.getOutputBufferPosition = function() {
          return t;
        }, this.setOutputBufferPosition = function(M) {
          t = M;
        };
      }, l.GifReader = function(e) {
        var f = 0;
        if (e[f++] !== 71 || e[f++] !== 73 || e[f++] !== 70 || e[f++] !== 56 || (e[f++] + 1 & 253) != 56 || e[f++] !== 97)
          throw new Error("Invalid GIF 87a/89a header.");
        var i = e[f++] | e[f++] << 8, a = e[f++] | e[f++] << 8, t = e[f++], r = t >> 7, o = 1 << 1 + (7 & t);
        e[f++], e[f++];
        var n = null, u = null;
        r && (n = f, u = o, f += 3 * o);
        var p = !0, g = [], v = 0, x = null, b = 0, w = null;
        for (this.width = i, this.height = a; p && f < e.length; )
          switch (e[f++]) {
            case 33:
              switch (e[f++]) {
                case 255:
                  if (e[f] !== 11 || e[f + 1] == 78 && e[f + 2] == 69 && e[f + 3] == 84 && e[f + 4] == 83 && e[f + 5] == 67 && e[f + 6] == 65 && e[f + 7] == 80 && e[f + 8] == 69 && e[f + 9] == 50 && e[f + 10] == 46 && e[f + 11] == 48 && e[f + 12] == 3 && e[f + 13] == 1 && e[f + 16] == 0)
                    f += 14, w = e[f++] | e[f++] << 8, f++;
                  else
                    for (f += 12; ; ) {
                      if (!((C = e[f++]) >= 0))
                        throw Error("Invalid block size");
                      if (C === 0)
                        break;
                      f += C;
                    }
                  break;
                case 249:
                  if (e[f++] !== 4 || e[f + 4] !== 0)
                    throw new Error("Invalid graphics extension block.");
                  var M = e[f++];
                  v = e[f++] | e[f++] << 8, x = e[f++], !(1 & M) && (x = null), b = M >> 2 & 7, f++;
                  break;
                case 254:
                  for (; ; ) {
                    if (!((C = e[f++]) >= 0))
                      throw Error("Invalid block size");
                    if (C === 0)
                      break;
                    f += C;
                  }
                  break;
                default:
                  throw new Error("Unknown graphic control label: 0x" + e[f - 1].toString(16));
              }
              break;
            case 44:
              var G = e[f++] | e[f++] << 8, F = e[f++] | e[f++] << 8, V = e[f++] | e[f++] << 8, q = e[f++] | e[f++] << 8, I = e[f++], _ = I >> 6 & 1, R = 1 << 1 + (7 & I), W = n, O = u, j = !1;
              I >> 7 && (j = !0, W = f, O = R, f += 3 * R);
              var U = f;
              for (f++; ; ) {
                var C;
                if (!((C = e[f++]) >= 0))
                  throw Error("Invalid block size");
                if (C === 0)
                  break;
                f += C;
              }
              g.push({ x: G, y: F, width: V, height: q, has_local_palette: j, palette_offset: W, palette_size: O, data_offset: U, data_length: f - U, transparent_index: x, interlaced: !!_, delay: v, disposal: b });
              break;
            case 59:
              p = !1;
              break;
            default:
              throw new Error("Unknown gif block: 0x" + e[f - 1].toString(16));
          }
        this.numFrames = function() {
          return g.length;
        }, this.loopCount = function() {
          return w;
        }, this.frameInfo = function(ae) {
          if (ae < 0 || ae >= g.length)
            throw new Error("Frame index out of range.");
          return g[ae];
        }, this.decodeAndBlitFrameBGRA = function(ae, J) {
          var te = this.frameInfo(ae), $ = te.width * te.height, L = new Uint8Array($);
          s(e, te.data_offset, L, $);
          var re = te.palette_offset, z = te.transparent_index;
          z === null && (z = 256);
          var N = te.width, ne = i - N, le = N, he = 4 * (te.y * i + te.x), k = 4 * ((te.y + te.height) * i + te.x), T = he, B = 4 * ne;
          te.interlaced === !0 && (B += 4 * i * 7);
          for (var K = 8, h = 0, c = L.length; h < c; ++h) {
            var m = L[h];
            if (le === 0 && (le = N, (T += B) >= k && (B = 4 * ne + 4 * i * (K - 1), T = he + (N + ne) * (K << 1), K >>= 1)), m === z)
              T += 4;
            else {
              var D = e[re + 3 * m], ee = e[re + 3 * m + 1], E = e[re + 3 * m + 2];
              J[T++] = E, J[T++] = ee, J[T++] = D, J[T++] = 255;
            }
            --le;
          }
        }, this.decodeAndBlitFrameRGBA = function(ae, J) {
          var te = this.frameInfo(ae), $ = te.width * te.height, L = new Uint8Array($);
          s(e, te.data_offset, L, $);
          var re = te.palette_offset, z = te.transparent_index;
          z === null && (z = 256);
          var N = te.width, ne = i - N, le = N, he = 4 * (te.y * i + te.x), k = 4 * ((te.y + te.height) * i + te.x), T = he, B = 4 * ne;
          te.interlaced === !0 && (B += 4 * i * 7);
          for (var K = 8, h = 0, c = L.length; h < c; ++h) {
            var m = L[h];
            if (le === 0 && (le = N, (T += B) >= k && (B = 4 * ne + 4 * i * (K - 1), T = he + (N + ne) * (K << 1), K >>= 1)), m === z)
              T += 4;
            else {
              var D = e[re + 3 * m], ee = e[re + 3 * m + 1], E = e[re + 3 * m + 2];
              J[T++] = D, J[T++] = ee, J[T++] = E, J[T++] = 255;
            }
            --le;
          }
        };
      };
    } catch {
    }
  }, 7604: (d, l, s) => {
    var e = s(8834).lW;
    class f {
      constructor(...a) {
        if (a.length === 0)
          throw new Error("constructor requires parameters");
        const t = a[0];
        if (t !== null && typeof t == "object")
          if (t instanceof f) {
            const r = t.bitmap;
            this.bitmap = { width: r.width, height: r.height, data: new e(r.width * r.height * 4) }, r.data.copy(this.bitmap.data);
          } else {
            if (!(t.width && t.height && t.data))
              throw new Error("unrecognized constructor parameters");
            this.bitmap = t;
          }
        else {
          if (typeof t != "number" || typeof a[1] != "number")
            throw new Error("unrecognized constructor parameters");
          {
            const r = t, o = a[1], n = a[2];
            this.bitmap = { width: r, height: o }, e.isBuffer(n) ? this.bitmap.data = n : (this.bitmap.data = new e(r * o * 4), typeof n == "number" && this.fillRGBA(n));
          }
        }
      }
      blit(a, t, r, o, n, u, p) {
        if (o + u > this.bitmap.width)
          throw new Error("copy exceeds width of source bitmap");
        if (t + u > a.bitmap.width)
          throw new Error("copy exceeds width of target bitmap");
        if (n + p > this.bitmap.height)
          throw new Error("copy exceeds height of source bitmap");
        if (r + p > a.bitmap.height)
          throw new Erro("copy exceeds height of target bitmap");
        const g = this.bitmap.data, v = a.bitmap.data, x = 4 * this.bitmap.width, b = 4 * a.bitmap.width, w = 4 * u;
        let M = n * x + 4 * o, G = r * b + 4 * t;
        for (; --p >= 0; )
          g.copy(v, G, M, M + w), M += x, G += b;
        return this;
      }
      fillRGBA(a) {
        const t = this.bitmap.data, r = 4 * this.bitmap.height;
        let o = 0;
        for (; o < r; )
          t.writeUInt32BE(a, o), o += 4;
        for (; o < t.length; )
          t.copy(t, o, 0, r), o += r;
        return this;
      }
      getRGBA(a, t) {
        const r = 4 * (t * this.bitmap.width + a);
        return this.bitmap.data.readUInt32BE(r);
      }
      getRGBASet() {
        const a = /* @__PURE__ */ new Set(), t = this.bitmap.data;
        for (let r = 0; r < t.length; r += 4)
          a.add(t.readUInt32BE(r, !0));
        return a;
      }
      greyscale() {
        const a = this.bitmap.data;
        return this.scan(0, 0, this.bitmap.width, this.bitmap.height, (t, r, o) => {
          const n = Math.round(0.299 * a[o] + 0.587 * a[o + 1] + 0.114 * a[o + 2]);
          a[o] = n, a[o + 1] = n, a[o + 2] = n;
        }), this;
      }
      reframe(a, t, r, o, n) {
        const u = a < 0 ? 0 : a, p = t < 0 ? 0 : t, g = r + u > this.bitmap.width ? this.bitmap.width - u : r, v = o + p > this.bitmap.height ? this.bitmap.height - p : o, x = a < 0 ? -a : 0, b = t < 0 ? -t : 0;
        let w;
        if (n === void 0) {
          if (u !== a || p != t || g !== r || v !== o)
            throw new GifError("fillRGBA required for this reframing");
          w = new f(r, o);
        } else
          w = new f(r, o, n);
        return this.blit(w, x, b, u, p, g, v), this.bitmap = w.bitmap, this;
      }
      scale(a) {
        if (a === 1)
          return;
        if (!Number.isInteger(a) || a < 1)
          throw new Error("the scale must be an integer >= 1");
        const t = this.bitmap.width, r = this.bitmap.height, o = t * a * 4, n = this.bitmap.data, u = new e(r * o * a);
        let p, g = 0, v = 0;
        for (let x = 0; x < r; ++x) {
          p = v;
          for (let b = 0; b < t; ++b) {
            const w = n.readUInt32BE(g, !0);
            for (let M = 0; M < a; ++M)
              u.writeUInt32BE(w, v), v += 4;
            g += 4;
          }
          for (let b = 1; b < a; ++b)
            u.copy(u, v, p, v), v += o, p += o;
        }
        return this.bitmap = { width: t * a, height: r * a, data: u }, this;
      }
      scanAllCoords(a) {
        const t = this.bitmap.width, r = this.bitmap.data.length;
        let o = 0, n = 0;
        for (let u = 0; u < r; u += 4)
          a(o, n, u), ++o === t && (o = 0, ++n);
      }
      scanAllIndexes(a) {
        const t = this.bitmap.data.length;
        for (let r = 0; r < t; r += 4)
          a(r);
      }
    }
    d.exports = f;
  }, 4364: (d, l) => {
    class s {
      constructor(i, a, t) {
        this.width = t.width, this.height = t.height, this.loops = t.loops, this.usesTransparency = t.usesTransparency, this.colorScope = t.colorScope, this.frames = a, this.buffer = i;
      }
    }
    s.GlobalColorsPreferred = 0, s.GlobalColorsOnly = 1, s.LocalColorsOnly = 2;
    class e extends Error {
      constructor(i) {
        super(i), i instanceof Error && (this.stack = "Gif" + i.stack);
      }
    }
    l.Gif = s, l.GifError = e;
  }, 6512: (d, l, s) => {
    var e = s(8834).lW;
    const f = s(2855), { Gif: i, GifError: a } = s(4364);
    function t() {
      const b = s(4602);
      return t = function() {
        return b;
      }, b;
    }
    const { GifFrame: r } = s(5585), o = 100;
    function n(b, w) {
      const M = b.indexOf(w);
      return M === -1 ? null : M;
    }
    function u(b, w) {
      for (var M, G = 0, F = b.length - 1; G <= F; )
        if (b[M = Math.floor((G + F) / 2)] > w)
          F = M - 1;
        else {
          if (!(b[M] < w))
            return M;
          G = M + 1;
        }
      return null;
    }
    function p(b) {
      const w = b.colors;
      b.usesTransparency && w.push(0);
      const M = w.length;
      let G = 2;
      for (; M > G; )
        G <<= 1;
      w.length = G, w.fill(0, M);
    }
    function g(b, w) {
      let M = b.bitmap.width * b.bitmap.height;
      return M = Math.ceil(M * w / 8), M += Math.ceil(M / 255), o + M + 768;
    }
    function v(b) {
      let w = b.indexCount, M = 0;
      for (--w; w; )
        ++M, w >>= 1;
      return M > 0 ? M : 1;
    }
    function x(b, w, M, G, F) {
      if (M.interlaced)
        throw new a("writing interlaced GIFs is not supported");
      const V = function(I, _, R) {
        const W = R.colors, O = W.length <= 8 ? n : u, j = _.bitmap.data, U = new e(j.length / 4);
        let C = W.length, ae = 0, J = 0;
        for (; ae < j.length; ) {
          if (j[ae + 3] !== 0) {
            const te = j.readUInt32BE(ae, !0) >> 8 & 16777215;
            U[J] = O(W, te);
          } else
            U[J] = C;
          ae += 4, ++J;
        }
        if (R.usesTransparency) {
          if (C === 256)
            throw new a(`Frame ${I} already has 256 colorsand so can't use transparency`);
        } else
          C = null;
        return { buffer: U, transparentIndex: C };
      }(w, M, G), q = { delay: M.delayCentisecs, disposal: M.disposalMethod, transparent: V.transparentIndex };
      F && (p(G), q.palette = G.colors);
      try {
        let I, _ = b.getOutputBuffer(), R = b.getOutputBufferPosition(), W = !0;
        for (; W; )
          if (I = b.addFrame(M.xOffset, M.yOffset, M.bitmap.width, M.bitmap.height, V.buffer, q), W = !1, I >= _.length - 1) {
            const O = new e(1.5 * _.length);
            _.copy(O), b.setOutputBuffer(O), b.setOutputBufferPosition(R), _ = O, W = !0;
          }
        return _;
      } catch (I) {
        throw new a(I);
      }
    }
    l.GifCodec = class {
      constructor(b = {}) {
        this._transparentRGB = null, typeof b.transparentRGB == "number" && b.transparentRGB !== 0 && (this._transparentRGBA = 256 * b.transparentRGB), this._testInitialBufferSize = 0;
      }
      decodeGif(b) {
        try {
          let w;
          try {
            w = new f.GifReader(b);
          } catch (V) {
            throw new a(V);
          }
          const M = w.numFrames(), G = [], F = { width: w.width, height: w.height, loops: w.loopCount(), usesTransparency: !1 };
          for (let V = 0; V < M; ++V) {
            const q = this._decodeFrame(w, V, F.usesTransparency);
            G.push(q.frame), q.usesTransparency && (F.usesTransparency = !0);
          }
          return Promise.resolve(new i(b, G, F));
        } catch (w) {
          return Promise.reject(w);
        }
      }
      encodeGif(b, w = {}) {
        try {
          if (b === null || b.length === 0)
            throw new a("there are no frames");
          const M = t().getMaxDimensions(b);
          return (w = Object.assign({}, w)).width = M.maxWidth, w.height = M.maxHeight, w.loops === void 0 && (w.loops = 0), w.colorScope = w.colorScope || i.GlobalColorsPreferred, Promise.resolve(this._encodeGif(b, w));
        } catch (M) {
          return Promise.reject(M);
        }
      }
      _decodeFrame(b, w, M) {
        let G, F;
        try {
          if (G = b.frameInfo(w), F = new e(b.width * b.height * 4), b.decodeAndBlitFrameRGBA(w, F), G.width !== b.width || G.height !== b.height) {
            if (G.y && (F = F.slice(G.y * b.width * 4)), b.width > G.width)
              for (let q = 0; q < G.height; ++q)
                F.copy(F, q * G.width * 4, 4 * (G.x + q * b.width), 4 * (G.x + q * b.width) + 4 * G.width);
            F = F.slice(0, G.width * G.height * 4);
          }
        } catch (q) {
          throw new a(q);
        }
        let V = !1;
        if (this._transparentRGBA === null) {
          if (!M)
            for (let q = 3; q < F.length; q += 4)
              F[q] === 0 && (V = !0, q = F.length);
        } else
          for (let q = 3; q < F.length; q += 4)
            F[q] === 0 && (F.writeUInt32BE(this._transparentRGBA, q - 3), V = !0);
        return { frame: new r(G.width, G.height, F, { xOffset: G.x, yOffset: G.y, disposalMethod: G.disposal, interlaced: G.interlaced, delayCentisecs: G.delay }), usesTransparency: V };
      }
      _encodeGif(b, w) {
        let M;
        if (w.colorScope === i.LocalColorsOnly)
          M = t().getColorInfo(b, 0);
        else if (M = t().getColorInfo(b, 256), !M.colors) {
          if (w.colorScope === i.GlobalColorsOnly)
            throw new a("Too many color indexes for global color table");
          w.colorScope = i.LocalColorsOnly;
        }
        w.usesTransparency = M.usesTransparency;
        const G = M.palettes;
        return w.colorScope === i.LocalColorsOnly ? function(F, V, q, I) {
          const _ = { loop: V.loops };
          let R, W = new e(2e3);
          try {
            R = new f.GifWriter(W, V.width, V.height, _);
          } catch (O) {
            throw new a(O);
          }
          for (let O = 0; O < F.length; ++O)
            W = x(R, O, F[O], I[O], !0);
          return new i(W.slice(0, R.end()), F, V);
        }(b, w, 0, G) : function(F, V, q, I) {
          const _ = { colors: I.colors.slice(), usesTransparency: I.usesTransparency };
          p(_);
          const R = { palette: _.colors, loop: V.loops };
          let W, O = new e(2e3);
          try {
            W = new f.GifWriter(O, V.width, V.height, R);
          } catch (j) {
            throw new a(j);
          }
          for (let j = 0; j < F.length; ++j)
            O = x(W, j, F[j], I, !1);
          return new i(O.slice(0, W.end()), F, V);
        }(b, w, 0, M);
      }
      _getSizeEstimateGlobal(b, w) {
        if (this._testInitialBufferSize > 0)
          return this._testInitialBufferSize;
        let M = 968;
        const G = v(b);
        return w.forEach((F) => {
          M += g(F, G);
        }), M;
      }
      _getSizeEstimateLocal(b, w) {
        if (this._testInitialBufferSize > 0)
          return this._testInitialBufferSize;
        let M = 200;
        for (let G = 0; G < w.length; ++G) {
          const F = v(b[G]);
          M += g(w[G], F);
        }
        return M;
      }
    };
  }, 5585: (d, l, s) => {
    const e = s(7604);
    s(4364);
    class f extends e {
      constructor(...a) {
        if (super(...a), a[0] instanceof f) {
          const t = a[0];
          this.xOffset = t.xOffset, this.yOffset = t.yOffset, this.disposalMethod = t.disposalMethod, this.delayCentisecs = t.delayCentisecs, this.interlaced = t.interlaced;
        } else {
          const t = a[a.length - 1];
          let r = {};
          typeof t != "object" || t instanceof e || (r = t), this.xOffset = r.xOffset || 0, this.yOffset = r.yOffset || 0, this.disposalMethod = r.disposalMethod !== void 0 ? r.disposalMethod : f.DisposeToBackgroundColor, this.delayCentisecs = r.delayCentisecs || 8, this.interlaced = r.interlaced || !1;
        }
      }
      getPalette() {
        const a = /* @__PURE__ */ new Set(), t = this.bitmap.data;
        let r = 0, o = !1;
        for (; r < t.length; ) {
          if (t[r + 3] === 0)
            o = !0;
          else {
            const g = t.readUInt32BE(r, !0) >> 8 & 16777215;
            a.add(g);
          }
          r += 4;
        }
        const n = new Array(a.size), u = a.values();
        for (r = 0; r < n.length; ++r)
          n[r] = u.next().value;
        n.sort((g, v) => g - v);
        let p = n.length;
        return o && ++p, { colors: n, usesTransparency: o, indexCount: p };
      }
    }
    f.DisposeToAnything = 0, f.DisposeNothing = 1, f.DisposeToBackgroundColor = 2, f.DisposeToPrevious = 3, l.GifFrame = f;
  }, 4602: (d, l, s) => {
    var e = s(8834).lW;
    const f = s(8522), i = s(2460), a = s(7604), { GifFrame: t } = s(5585), { GifError: r } = s(4364), { GifCodec: o } = s(6512), n = [".jpg", ".jpeg", ".png", ".bmp"], u = new o();
    function p(g, v, x, b, w) {
      const M = Array.isArray(g) ? g : [g];
      if (w) {
        if (["FloydSteinberg", "FalseFloydSteinberg", "Stucki", "Atkinson", "Jarvis", "Burkes", "Sierra", "TwoSierra", "SierraLite"].indexOf(w.ditherAlgorithm) < 0)
          throw new Error(`Invalid ditherAlgorithm '${w.ditherAlgorithm}'`);
        w.serpentine === void 0 && (w.serpentine = !0), w.minimumColorDistanceToDither === void 0 && (w.minimumColorDistanceToDither = 0), w.calculateErrorLikeGIMP === void 0 && (w.calculateErrorLikeGIMP = !1);
      }
      const G = new i.distance.Euclidean(), F = new i.palette[v](G, x, b);
      let V;
      V = w ? new i.image.ErrorDiffusionArray(G, i.image.ErrorDiffusionArrayKernel[w.ditherAlgorithm], w.serpentine, w.minimumColorDistanceToDither, w.calculateErrorLikeGIMP) : new i.image.NearestColor(G);
      const q = [];
      M.forEach((_) => {
        const R = _.bitmap.data, W = new ArrayBuffer(R.length), O = new Uint32Array(W);
        for (let U = 0, C = 0; U < R.length; U += 4, ++C)
          O[C] = R.readUInt32LE(U, !0);
        const j = i.utils.PointContainer.fromUint32Array(O, _.bitmap.width, _.bitmap.height);
        F.sample(j), q.push(j);
      });
      const I = F.quantizeSync();
      for (let _ = 0; _ < M.length; ++_) {
        const R = M[_].bitmap.data, W = V.quantizeSync(q[_], I).toUint32Array();
        for (let O = 0, j = 0; O < R.length; O += 4, ++j)
          R.writeUInt32LE(W[j], O);
      }
    }
    l.cloneFrames = function(g) {
      let v = [];
      return g.forEach((x) => {
        v.push(new t(x));
      }), v;
    }, l.getColorInfo = function(g, v) {
      let x = !1;
      const b = [];
      for (let V = 0; V < g.length; ++V) {
        let q = g[V].getPalette();
        if (q.usesTransparency && (x = !0), q.indexCount > 256)
          throw new r(`Frame ${V} uses more than 256 color indexes`);
        b.push(q);
      }
      if (v === 0)
        return { usesTransparency: x, palettes: b };
      const w = /* @__PURE__ */ new Set();
      b.forEach((V) => {
        V.colors.forEach((q) => {
          w.add(q);
        });
      });
      let M = w.size;
      if (x && ++M, v && M > v)
        return { usesTransparency: x, palettes: b };
      const G = new Array(w.size), F = w.values();
      for (let V = 0; V < G.length; ++V)
        G[V] = F.next().value;
      return G.sort((V, q) => V - q), { colors: G, indexCount: M, usesTransparency: x, palettes: b };
    }, l.copyAsJimp = function(g, v) {
      return l.shareAsJimp(g, new a(v));
    }, l.getMaxDimensions = function(g) {
      let v = 0, x = 0;
      return g.forEach((b) => {
        const w = b.xOffset + b.bitmap.width;
        w > v && (v = w);
        const M = b.yOffset + b.bitmap.height;
        M > x && (x = M);
      }), { maxWidth: v, maxHeight: x };
    }, l.quantizeDekker = function(g, v, x) {
      p(g, "NeuQuantFloat", v = v || 256, 0, x);
    }, l.quantizeSorokin = function(g, v, x, b) {
      let w;
      switch (v = v || 256, x = x || "min-pop") {
        case "min-pop":
          w = 2;
          break;
        case "top-pop":
          w = 1;
          break;
        default:
          throw new Error(`Invalid quantizeSorokin histogram '${x}'`);
      }
      p(g, "RGBQuant", v, w, b);
    }, l.quantizeWu = function(g, v, x, b) {
      if (v = v || 256, (x = x || 5) < 1 || x > 8)
        throw new Error("Invalid quantization quality");
      p(g, "WuQuant", v, x, b);
    }, l.read = function(g, v) {
      return v = v || u, e.isBuffer(g) ? v.decodeGif(g) : (x = g, new Promise((b, w) => {
        f.readFile(x, (M, G) => M ? w(M) : b(G));
      })).then((b) => v.decodeGif(b));
      var x;
    }, l.shareAsJimp = function(g, v) {
      const x = new g(v.bitmap.width, v.bitmap.height, 0);
      return x.bitmap.data = v.bitmap.data, x;
    }, l.write = function(g, v, x, b) {
      b = b || u;
      const w = g.match(/\.[a-zA-Z]+$/);
      if (w !== null && n.includes(w[0].toLowerCase()))
        throw new Error(`GIF '${g}' has an unexpected suffix`);
      return b.encodeGif(v, x).then((M) => function(G, F) {
        return new Promise((V, q) => {
          f.writeFile(G, F, (I) => I ? q(I) : V());
        });
      }(g, M.buffer).then(() => M));
    };
  }, 9455: (d, l, s) => {
    const e = s(7604), { Gif: f, GifError: i } = s(4364), { GifCodec: a } = s(6512), { GifFrame: t } = s(5585), r = s(4602);
    d.exports = { BitmapImage: e, Gif: f, GifCodec: a, GifFrame: t, GifUtil: r, GifError: i };
  }, 5048: (d, l, s) => {
    var e;
    e = typeof window < "u" ? window : s.g !== void 0 ? s.g : typeof self < "u" ? self : {}, d.exports = e;
  }, 2333: (d, l) => {
    l.read = function(s, e, f, i, a) {
      var t, r, o = 8 * a - i - 1, n = (1 << o) - 1, u = n >> 1, p = -7, g = f ? a - 1 : 0, v = f ? -1 : 1, x = s[e + g];
      for (g += v, t = x & (1 << -p) - 1, x >>= -p, p += o; p > 0; t = 256 * t + s[e + g], g += v, p -= 8)
        ;
      for (r = t & (1 << -p) - 1, t >>= -p, p += i; p > 0; r = 256 * r + s[e + g], g += v, p -= 8)
        ;
      if (t === 0)
        t = 1 - u;
      else {
        if (t === n)
          return r ? NaN : 1 / 0 * (x ? -1 : 1);
        r += Math.pow(2, i), t -= u;
      }
      return (x ? -1 : 1) * r * Math.pow(2, t - i);
    }, l.write = function(s, e, f, i, a, t) {
      var r, o, n, u = 8 * t - a - 1, p = (1 << u) - 1, g = p >> 1, v = a === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, x = i ? 0 : t - 1, b = i ? 1 : -1, w = e < 0 || e === 0 && 1 / e < 0 ? 1 : 0;
      for (e = Math.abs(e), isNaN(e) || e === 1 / 0 ? (o = isNaN(e) ? 1 : 0, r = p) : (r = Math.floor(Math.log(e) / Math.LN2), e * (n = Math.pow(2, -r)) < 1 && (r--, n *= 2), (e += r + g >= 1 ? v / n : v * Math.pow(2, 1 - g)) * n >= 2 && (r++, n /= 2), r + g >= p ? (o = 0, r = p) : r + g >= 1 ? (o = (e * n - 1) * Math.pow(2, a), r += g) : (o = e * Math.pow(2, g - 1) * Math.pow(2, a), r = 0)); a >= 8; s[f + x] = 255 & o, x += b, o /= 256, a -= 8)
        ;
      for (r = r << a | o, u += a; u > 0; s[f + x] = 255 & r, x += b, r /= 256, u -= 8)
        ;
      s[f + x - b] |= 128 * w;
    };
  }, 9680: (d) => {
    var l = Function.prototype.toString, s = /^\s*class\b/, e = function(a) {
      try {
        var t = l.call(a);
        return s.test(t);
      } catch {
        return !1;
      }
    }, f = Object.prototype.toString, i = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol";
    d.exports = function(a) {
      if (!a || typeof a != "function" && typeof a != "object")
        return !1;
      if (typeof a == "function" && !a.prototype)
        return !0;
      if (i)
        return function(r) {
          try {
            return !e(r) && (l.call(r), !0);
          } catch {
            return !1;
          }
        }(a);
      if (e(a))
        return !1;
      var t = f.call(a);
      return t === "[object Function]" || t === "[object GeneratorFunction]";
    };
  }, 9748: (d) => {
    d.exports = function(s) {
      var e = l.call(s);
      return e === "[object Function]" || typeof s == "function" && e !== "[object RegExp]" || typeof window < "u" && (s === window.setTimeout || s === window.alert || s === window.confirm || s === window.prompt);
    };
    var l = Object.prototype.toString;
  }, 9307: (d, l, s) => {
    s(6168), d.exports = self.fetch.bind(self);
  }, 2691: (d, l, s) => {
    var e = s(706), f = s(770);
    d.exports = { encode: e, decode: f };
  }, 770: (d, l, s) => {
    var e = s(8834).lW, f = function() {
      var i = new Int32Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), a = 4017, t = 799, r = 3406, o = 2276, n = 1567, u = 3784, p = 5793, g = 2896;
      function v() {
      }
      function x(q, I) {
        for (var _, R, W = 0, O = [], j = 16; j > 0 && !q[j - 1]; )
          j--;
        O.push({ children: [], index: 0 });
        var U, C = O[0];
        for (_ = 0; _ < j; _++) {
          for (R = 0; R < q[_]; R++) {
            for ((C = O.pop()).children[C.index] = I[W]; C.index > 0; ) {
              if (O.length === 0)
                throw new Error("Could not recreate Huffman Table");
              C = O.pop();
            }
            for (C.index++, O.push(C); O.length <= _; )
              O.push(U = { children: [], index: 0 }), C.children[C.index] = U.children, C = U;
            W++;
          }
          _ + 1 < j && (O.push(U = { children: [], index: 0 }), C.children[C.index] = U.children, C = U);
        }
        return O[0].children;
      }
      function b(q, I, _, R, W, O, j, U, C, ae) {
        _.precision, _.samplesPerLine, _.scanLines;
        var J = _.mcusPerLine, te = _.progressive, $ = (_.maxH, _.maxV, I), L = 0, re = 0;
        function z() {
          if (re > 0)
            return re--, L >> re & 1;
          if ((L = q[I++]) == 255) {
            var ke = q[I++];
            if (ke)
              throw new Error("unexpected marker: " + (L << 8 | ke).toString(16));
          }
          return re = 7, L >>> 7;
        }
        function N(ke) {
          for (var oe, ce = ke; (oe = z()) !== null; ) {
            if (typeof (ce = ce[oe]) == "number")
              return ce;
            if (typeof ce != "object")
              throw new Error("invalid huffman sequence");
          }
          return null;
        }
        function ne(ke) {
          for (var oe = 0; ke > 0; ) {
            var ce = z();
            if (ce === null)
              return;
            oe = oe << 1 | ce, ke--;
          }
          return oe;
        }
        function le(ke) {
          var oe = ne(ke);
          return oe >= 1 << ke - 1 ? oe : oe + (-1 << ke) + 1;
        }
        var he, k = 0, T = 0;
        function B(ke, oe, ce, xe, Ce) {
          var _e = ce % J, Be = (ce / J | 0) * ke.v + xe, Pe = _e * ke.h + Ce;
          ke.blocks[Be] === void 0 && ae.tolerantDecoding || oe(ke, ke.blocks[Be][Pe]);
        }
        function K(ke, oe, ce) {
          var xe = ce / ke.blocksPerLine | 0, Ce = ce % ke.blocksPerLine;
          ke.blocks[xe] === void 0 && ae.tolerantDecoding || oe(ke, ke.blocks[xe][Ce]);
        }
        var h, c, m, D, ee, E, Q = R.length;
        E = te ? O === 0 ? U === 0 ? function(ke, oe) {
          var ce = N(ke.huffmanTableDC), xe = ce === 0 ? 0 : le(ce) << C;
          oe[0] = ke.pred += xe;
        } : function(ke, oe) {
          oe[0] |= z() << C;
        } : U === 0 ? function(ke, oe) {
          if (k > 0)
            k--;
          else
            for (var ce = O, xe = j; ce <= xe; ) {
              var Ce = N(ke.huffmanTableAC), _e = 15 & Ce, Be = Ce >> 4;
              if (_e !== 0)
                oe[i[ce += Be]] = le(_e) * (1 << C), ce++;
              else {
                if (Be < 15) {
                  k = ne(Be) + (1 << Be) - 1;
                  break;
                }
                ce += 16;
              }
            }
        } : function(ke, oe) {
          for (var ce = O, xe = j, Ce = 0; ce <= xe; ) {
            var _e = i[ce], Be = oe[_e] < 0 ? -1 : 1;
            switch (T) {
              case 0:
                var Pe = N(ke.huffmanTableAC), Fe = 15 & Pe;
                if (Ce = Pe >> 4, Fe === 0)
                  Ce < 15 ? (k = ne(Ce) + (1 << Ce), T = 4) : (Ce = 16, T = 1);
                else {
                  if (Fe !== 1)
                    throw new Error("invalid ACn encoding");
                  he = le(Fe), T = Ce ? 2 : 3;
                }
                continue;
              case 1:
              case 2:
                oe[_e] ? oe[_e] += (z() << C) * Be : --Ce == 0 && (T = T == 2 ? 3 : 0);
                break;
              case 3:
                oe[_e] ? oe[_e] += (z() << C) * Be : (oe[_e] = he << C, T = 0);
                break;
              case 4:
                oe[_e] && (oe[_e] += (z() << C) * Be);
            }
            ce++;
          }
          T === 4 && --k == 0 && (T = 0);
        } : function(ke, oe) {
          var ce = N(ke.huffmanTableDC), xe = ce === 0 ? 0 : le(ce);
          oe[0] = ke.pred += xe;
          for (var Ce = 1; Ce < 64; ) {
            var _e = N(ke.huffmanTableAC), Be = 15 & _e, Pe = _e >> 4;
            if (Be !== 0)
              oe[i[Ce += Pe]] = le(Be), Ce++;
            else {
              if (Pe < 15)
                break;
              Ce += 16;
            }
          }
        };
        var se, Y, be, Ee, Me = 0;
        for (Y = Q == 1 ? R[0].blocksPerLine * R[0].blocksPerColumn : J * _.mcusPerColumn, W || (W = Y); Me < Y; ) {
          for (c = 0; c < Q; c++)
            R[c].pred = 0;
          if (k = 0, Q == 1)
            for (h = R[0], ee = 0; ee < W; ee++)
              K(h, E, Me), Me++;
          else
            for (ee = 0; ee < W; ee++) {
              for (c = 0; c < Q; c++)
                for (be = (h = R[c]).h, Ee = h.v, m = 0; m < Ee; m++)
                  for (D = 0; D < be; D++)
                    B(h, E, Me, m, D);
              if (++Me === Y)
                break;
            }
          if (Me === Y)
            do {
              if (q[I] === 255 && q[I + 1] !== 0)
                break;
              I += 1;
            } while (I < q.length - 2);
          if (re = 0, (se = q[I] << 8 | q[I + 1]) < 65280)
            throw new Error("marker was not found");
          if (!(se >= 65488 && se <= 65495))
            break;
          I += 2;
        }
        return I - $;
      }
      function w(q, I) {
        var _, R, W = [], O = I.blocksPerLine, j = I.blocksPerColumn, U = O << 3, C = new Int32Array(64), ae = new Uint8Array(64);
        function J(ne, le, he) {
          var k, T, B, K, h, c, m, D, ee, E, Q = I.quantizationTable, se = he;
          for (E = 0; E < 64; E++)
            se[E] = ne[E] * Q[E];
          for (E = 0; E < 8; ++E) {
            var Y = 8 * E;
            se[1 + Y] != 0 || se[2 + Y] != 0 || se[3 + Y] != 0 || se[4 + Y] != 0 || se[5 + Y] != 0 || se[6 + Y] != 0 || se[7 + Y] != 0 ? (k = p * se[0 + Y] + 128 >> 8, T = p * se[4 + Y] + 128 >> 8, B = se[2 + Y], K = se[6 + Y], h = g * (se[1 + Y] - se[7 + Y]) + 128 >> 8, D = g * (se[1 + Y] + se[7 + Y]) + 128 >> 8, c = se[3 + Y] << 4, m = se[5 + Y] << 4, ee = k - T + 1 >> 1, k = k + T + 1 >> 1, T = ee, ee = B * u + K * n + 128 >> 8, B = B * n - K * u + 128 >> 8, K = ee, ee = h - m + 1 >> 1, h = h + m + 1 >> 1, m = ee, ee = D + c + 1 >> 1, c = D - c + 1 >> 1, D = ee, ee = k - K + 1 >> 1, k = k + K + 1 >> 1, K = ee, ee = T - B + 1 >> 1, T = T + B + 1 >> 1, B = ee, ee = h * o + D * r + 2048 >> 12, h = h * r - D * o + 2048 >> 12, D = ee, ee = c * t + m * a + 2048 >> 12, c = c * a - m * t + 2048 >> 12, m = ee, se[0 + Y] = k + D, se[7 + Y] = k - D, se[1 + Y] = T + m, se[6 + Y] = T - m, se[2 + Y] = B + c, se[5 + Y] = B - c, se[3 + Y] = K + h, se[4 + Y] = K - h) : (ee = p * se[0 + Y] + 512 >> 10, se[0 + Y] = ee, se[1 + Y] = ee, se[2 + Y] = ee, se[3 + Y] = ee, se[4 + Y] = ee, se[5 + Y] = ee, se[6 + Y] = ee, se[7 + Y] = ee);
          }
          for (E = 0; E < 8; ++E) {
            var be = E;
            se[8 + be] != 0 || se[16 + be] != 0 || se[24 + be] != 0 || se[32 + be] != 0 || se[40 + be] != 0 || se[48 + be] != 0 || se[56 + be] != 0 ? (k = p * se[0 + be] + 2048 >> 12, T = p * se[32 + be] + 2048 >> 12, B = se[16 + be], K = se[48 + be], h = g * (se[8 + be] - se[56 + be]) + 2048 >> 12, D = g * (se[8 + be] + se[56 + be]) + 2048 >> 12, c = se[24 + be], m = se[40 + be], ee = k - T + 1 >> 1, k = k + T + 1 >> 1, T = ee, ee = B * u + K * n + 2048 >> 12, B = B * n - K * u + 2048 >> 12, K = ee, ee = h - m + 1 >> 1, h = h + m + 1 >> 1, m = ee, ee = D + c + 1 >> 1, c = D - c + 1 >> 1, D = ee, ee = k - K + 1 >> 1, k = k + K + 1 >> 1, K = ee, ee = T - B + 1 >> 1, T = T + B + 1 >> 1, B = ee, ee = h * o + D * r + 2048 >> 12, h = h * r - D * o + 2048 >> 12, D = ee, ee = c * t + m * a + 2048 >> 12, c = c * a - m * t + 2048 >> 12, m = ee, se[0 + be] = k + D, se[56 + be] = k - D, se[8 + be] = T + m, se[48 + be] = T - m, se[16 + be] = B + c, se[40 + be] = B - c, se[24 + be] = K + h, se[32 + be] = K - h) : (ee = p * he[E + 0] + 8192 >> 14, se[0 + be] = ee, se[8 + be] = ee, se[16 + be] = ee, se[24 + be] = ee, se[32 + be] = ee, se[40 + be] = ee, se[48 + be] = ee, se[56 + be] = ee);
          }
          for (E = 0; E < 64; ++E) {
            var Ee = 128 + (se[E] + 8 >> 4);
            le[E] = Ee < 0 ? 0 : Ee > 255 ? 255 : Ee;
          }
        }
        V(U * j * 8);
        for (var te = 0; te < j; te++) {
          var $ = te << 3;
          for (_ = 0; _ < 8; _++)
            W.push(new Uint8Array(U));
          for (var L = 0; L < O; L++) {
            J(I.blocks[te][L], ae, C);
            var re = 0, z = L << 3;
            for (R = 0; R < 8; R++) {
              var N = W[$ + R];
              for (_ = 0; _ < 8; _++)
                N[z + _] = ae[re++];
            }
          }
        }
        return W;
      }
      function M(q) {
        return q < 0 ? 0 : q > 255 ? 255 : q;
      }
      v.prototype = { load: function(q) {
        var I = new XMLHttpRequest();
        I.open("GET", q, !0), I.responseType = "arraybuffer", I.onload = (function() {
          var _ = new Uint8Array(I.response || I.mozResponseArrayBuffer);
          this.parse(_), this.onload && this.onload();
        }).bind(this), I.send(null);
      }, parse: function(q) {
        var I = 1e3 * this.opts.maxResolutionInMP * 1e3, _ = 0;
        function R() {
          var We = q[_] << 8 | q[_ + 1];
          return _ += 2, We;
        }
        function W(We) {
          var Qe, lt, P = 1, we = 1;
          for (lt in We.components)
            We.components.hasOwnProperty(lt) && (P < (Qe = We.components[lt]).h && (P = Qe.h), we < Qe.v && (we = Qe.v));
          var X = Math.ceil(We.samplesPerLine / 8 / P), de = Math.ceil(We.scanLines / 8 / we);
          for (lt in We.components)
            if (We.components.hasOwnProperty(lt)) {
              Qe = We.components[lt];
              var Ze = Math.ceil(Math.ceil(We.samplesPerLine / 8) * Qe.h / P), Re = Math.ceil(Math.ceil(We.scanLines / 8) * Qe.v / we), rt = X * Qe.h, De = de * Qe.v, Je = [];
              V(De * rt * 256);
              for (var Ne = 0; Ne < De; Ne++) {
                for (var Ie = [], at = 0; at < rt; at++)
                  Ie.push(new Int32Array(64));
                Je.push(Ie);
              }
              Qe.blocksPerLine = Ze, Qe.blocksPerColumn = Re, Qe.blocks = Je;
            }
          We.maxH = P, We.maxV = we, We.mcusPerLine = X, We.mcusPerColumn = de;
        }
        q.length;
        var O, j, U, C, ae = null, J = null, te = [], $ = [], L = [], re = [], z = R(), N = -1;
        if (this.comments = [], z != 65496)
          throw new Error("SOI not found");
        for (z = R(); z != 65497; ) {
          switch (z) {
            case 65280:
              break;
            case 65504:
            case 65505:
            case 65506:
            case 65507:
            case 65508:
            case 65509:
            case 65510:
            case 65511:
            case 65512:
            case 65513:
            case 65514:
            case 65515:
            case 65516:
            case 65517:
            case 65518:
            case 65519:
            case 65534:
              var ne = (U = void 0, C = void 0, U = R(), C = q.subarray(_, _ + U - 2), _ += C.length, C);
              if (z === 65534) {
                var le = String.fromCharCode.apply(null, ne);
                this.comments.push(le);
              }
              z === 65504 && ne[0] === 74 && ne[1] === 70 && ne[2] === 73 && ne[3] === 70 && ne[4] === 0 && (ae = { version: { major: ne[5], minor: ne[6] }, densityUnits: ne[7], xDensity: ne[8] << 8 | ne[9], yDensity: ne[10] << 8 | ne[11], thumbWidth: ne[12], thumbHeight: ne[13], thumbData: ne.subarray(14, 14 + 3 * ne[12] * ne[13]) }), z === 65505 && ne[0] === 69 && ne[1] === 120 && ne[2] === 105 && ne[3] === 102 && ne[4] === 0 && (this.exifBuffer = ne.subarray(5, ne.length)), z === 65518 && ne[0] === 65 && ne[1] === 100 && ne[2] === 111 && ne[3] === 98 && ne[4] === 101 && ne[5] === 0 && (J = { version: ne[6], flags0: ne[7] << 8 | ne[8], flags1: ne[9] << 8 | ne[10], transformCode: ne[11] });
              break;
            case 65499:
              for (var he = R() + _ - 2; _ < he; ) {
                var k = q[_++];
                V(256);
                var T = new Int32Array(64);
                if (k >> 4) {
                  if (k >> 4 != 1)
                    throw new Error("DQT: invalid table spec");
                  for (Pe = 0; Pe < 64; Pe++)
                    T[i[Pe]] = R();
                } else
                  for (Pe = 0; Pe < 64; Pe++)
                    T[i[Pe]] = q[_++];
                te[15 & k] = T;
              }
              break;
            case 65472:
            case 65473:
            case 65474:
              R(), (O = {}).extended = z === 65473, O.progressive = z === 65474, O.precision = q[_++], O.scanLines = R(), O.samplesPerLine = R(), O.components = {}, O.componentsOrder = [];
              var B = O.scanLines * O.samplesPerLine;
              if (B > I) {
                var K = Math.ceil((B - I) / 1e6);
                throw new Error(`maxResolutionInMP limit exceeded by ${K}MP`);
              }
              var h, c = q[_++];
              for (_e = 0; _e < c; _e++) {
                h = q[_];
                var m = q[_ + 1] >> 4, D = 15 & q[_ + 1], ee = q[_ + 2];
                if (m <= 0 || D <= 0)
                  throw new Error("Invalid sampling factor, expected values above 0");
                O.componentsOrder.push(h), O.components[h] = { h: m, v: D, quantizationIdx: ee }, _ += 3;
              }
              W(O), $.push(O);
              break;
            case 65476:
              var E = R();
              for (_e = 2; _e < E; ) {
                var Q = q[_++], se = new Uint8Array(16), Y = 0;
                for (Pe = 0; Pe < 16; Pe++, _++)
                  Y += se[Pe] = q[_];
                V(16 + Y);
                var be = new Uint8Array(Y);
                for (Pe = 0; Pe < Y; Pe++, _++)
                  be[Pe] = q[_];
                _e += 17 + Y, (Q >> 4 ? L : re)[15 & Q] = x(se, be);
              }
              break;
            case 65501:
              R(), j = R();
              break;
            case 65500:
              R(), R();
              break;
            case 65498:
              R();
              var Ee = q[_++], Me = [];
              for (_e = 0; _e < Ee; _e++) {
                Fe = O.components[q[_++]];
                var ke = q[_++];
                Fe.huffmanTableDC = re[ke >> 4], Fe.huffmanTableAC = L[15 & ke], Me.push(Fe);
              }
              var oe = q[_++], ce = q[_++], xe = q[_++], Ce = b(q, _, O, Me, j, oe, ce, xe >> 4, 15 & xe, this.opts);
              _ += Ce;
              break;
            case 65535:
              q[_] !== 255 && _--;
              break;
            default:
              if (q[_ - 3] == 255 && q[_ - 2] >= 192 && q[_ - 2] <= 254) {
                _ -= 3;
                break;
              }
              if (z === 224 || z == 225) {
                if (N !== -1)
                  throw new Error(`first unknown JPEG marker at offset ${N.toString(16)}, second unknown JPEG marker ${z.toString(16)} at offset ${(_ - 1).toString(16)}`);
                N = _ - 1;
                const We = R();
                if (q[_ + We - 2] === 255) {
                  _ += We - 2;
                  break;
                }
              }
              throw new Error("unknown JPEG marker " + z.toString(16));
          }
          z = R();
        }
        if ($.length != 1)
          throw new Error("only single frame JPEGs supported");
        for (var _e = 0; _e < $.length; _e++) {
          var Be = $[_e].components;
          for (var Pe in Be)
            Be[Pe].quantizationTable = te[Be[Pe].quantizationIdx], delete Be[Pe].quantizationIdx;
        }
        for (this.width = O.samplesPerLine, this.height = O.scanLines, this.jfif = ae, this.adobe = J, this.components = [], _e = 0; _e < O.componentsOrder.length; _e++) {
          var Fe = O.components[O.componentsOrder[_e]];
          this.components.push({ lines: w(0, Fe), scaleX: Fe.h / O.maxH, scaleY: Fe.v / O.maxV });
        }
      }, getData: function(q, I) {
        var _, R, W, O, j, U, C, ae, J, te, $, L, re, z, N, ne, le, he, k, T, B, K = this.width / q, h = this.height / I, c = 0, m = q * I * this.components.length;
        V(m);
        var D = new Uint8Array(m);
        switch (this.components.length) {
          case 1:
            for (_ = this.components[0], te = 0; te < I; te++)
              for (j = _.lines[0 | te * _.scaleY * h], J = 0; J < q; J++)
                $ = j[0 | J * _.scaleX * K], D[c++] = $;
            break;
          case 2:
            for (_ = this.components[0], R = this.components[1], te = 0; te < I; te++)
              for (j = _.lines[0 | te * _.scaleY * h], U = R.lines[0 | te * R.scaleY * h], J = 0; J < q; J++)
                $ = j[0 | J * _.scaleX * K], D[c++] = $, $ = U[0 | J * R.scaleX * K], D[c++] = $;
            break;
          case 3:
            for (B = !0, this.adobe && this.adobe.transformCode ? B = !0 : this.opts.colorTransform !== void 0 && (B = !!this.opts.colorTransform), _ = this.components[0], R = this.components[1], W = this.components[2], te = 0; te < I; te++)
              for (j = _.lines[0 | te * _.scaleY * h], U = R.lines[0 | te * R.scaleY * h], C = W.lines[0 | te * W.scaleY * h], J = 0; J < q; J++)
                B ? ($ = j[0 | J * _.scaleX * K], L = U[0 | J * R.scaleX * K], he = M($ + 1.402 * ((re = C[0 | J * W.scaleX * K]) - 128)), k = M($ - 0.3441363 * (L - 128) - 0.71413636 * (re - 128)), T = M($ + 1.772 * (L - 128))) : (he = j[0 | J * _.scaleX * K], k = U[0 | J * R.scaleX * K], T = C[0 | J * W.scaleX * K]), D[c++] = he, D[c++] = k, D[c++] = T;
            break;
          case 4:
            if (!this.adobe)
              throw new Error("Unsupported color mode (4 components)");
            for (B = !1, this.adobe && this.adobe.transformCode ? B = !0 : this.opts.colorTransform !== void 0 && (B = !!this.opts.colorTransform), _ = this.components[0], R = this.components[1], W = this.components[2], O = this.components[3], te = 0; te < I; te++)
              for (j = _.lines[0 | te * _.scaleY * h], U = R.lines[0 | te * R.scaleY * h], C = W.lines[0 | te * W.scaleY * h], ae = O.lines[0 | te * O.scaleY * h], J = 0; J < q; J++)
                B ? ($ = j[0 | J * _.scaleX * K], L = U[0 | J * R.scaleX * K], re = C[0 | J * W.scaleX * K], z = ae[0 | J * O.scaleX * K], N = 255 - M($ + 1.402 * (re - 128)), ne = 255 - M($ - 0.3441363 * (L - 128) - 0.71413636 * (re - 128)), le = 255 - M($ + 1.772 * (L - 128))) : (N = j[0 | J * _.scaleX * K], ne = U[0 | J * R.scaleX * K], le = C[0 | J * W.scaleX * K], z = ae[0 | J * O.scaleX * K]), D[c++] = 255 - N, D[c++] = 255 - ne, D[c++] = 255 - le, D[c++] = 255 - z;
            break;
          default:
            throw new Error("Unsupported color mode");
        }
        return D;
      }, copyToImageData: function(q, I) {
        var _, R, W, O, j, U, C, ae, J, te = q.width, $ = q.height, L = q.data, re = this.getData(te, $), z = 0, N = 0;
        switch (this.components.length) {
          case 1:
            for (R = 0; R < $; R++)
              for (_ = 0; _ < te; _++)
                W = re[z++], L[N++] = W, L[N++] = W, L[N++] = W, I && (L[N++] = 255);
            break;
          case 3:
            for (R = 0; R < $; R++)
              for (_ = 0; _ < te; _++)
                C = re[z++], ae = re[z++], J = re[z++], L[N++] = C, L[N++] = ae, L[N++] = J, I && (L[N++] = 255);
            break;
          case 4:
            for (R = 0; R < $; R++)
              for (_ = 0; _ < te; _++)
                j = re[z++], U = re[z++], W = re[z++], C = 255 - M(j * (1 - (O = re[z++]) / 255) + O), ae = 255 - M(U * (1 - O / 255) + O), J = 255 - M(W * (1 - O / 255) + O), L[N++] = C, L[N++] = ae, L[N++] = J, I && (L[N++] = 255);
            break;
          default:
            throw new Error("Unsupported color mode");
        }
      } };
      var G = 0, F = 0;
      function V(q = 0) {
        var I = G + q;
        if (I > F) {
          var _ = Math.ceil((I - F) / 1024 / 1024);
          throw new Error(`maxMemoryUsageInMB limit exceeded by at least ${_}MB`);
        }
        G = I;
      }
      return v.resetMaxMemoryUsage = function(q) {
        G = 0, F = q;
      }, v.getBytesAllocated = function() {
        return G;
      }, v.requestMemoryAllocation = V, v;
    }();
    d.exports = function(i, a = {}) {
      var t = { colorTransform: void 0, useTArray: !1, formatAsRGBA: !0, tolerantDecoding: !0, maxResolutionInMP: 100, maxMemoryUsageInMB: 512, ...a }, r = new Uint8Array(i), o = new f();
      o.opts = t, f.resetMaxMemoryUsage(1024 * t.maxMemoryUsageInMB * 1024), o.parse(r);
      var n = t.formatAsRGBA ? 4 : 3, u = o.width * o.height * n;
      try {
        f.requestMemoryAllocation(u);
        var p = { width: o.width, height: o.height, exifBuffer: o.exifBuffer, data: t.useTArray ? new Uint8Array(u) : e.alloc(u) };
        o.comments.length > 0 && (p.comments = o.comments);
      } catch (g) {
        throw g instanceof RangeError ? new Error("Could not allocate enough memory for the image. Required: " + u) : g instanceof ReferenceError && g.message === "Buffer is not defined" ? new Error("Buffer is not globally defined in this environment. Consider setting useTArray to true") : g;
      }
      return o.copyToImageData(p, t.formatAsRGBA), p;
    };
  }, 706: (d, l, s) => {
    var e = s(8834).lW;
    function f(i) {
      var a, t, r, o, n, u = Math.floor, p = new Array(64), g = new Array(64), v = new Array(64), x = new Array(64), b = new Array(65535), w = new Array(65535), M = new Array(64), G = new Array(64), F = [], V = 0, q = 7, I = new Array(64), _ = new Array(64), R = new Array(64), W = new Array(256), O = new Array(2048), j = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53, 10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63], U = [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0], C = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], ae = [0, 0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125], J = [1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250], te = [0, 0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0], $ = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], L = [0, 0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119], re = [0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250];
      function z(T, B) {
        for (var K = 0, h = 0, c = new Array(), m = 1; m <= 16; m++) {
          for (var D = 1; D <= T[m]; D++)
            c[B[h]] = [], c[B[h]][0] = K, c[B[h]][1] = m, h++, K++;
          K *= 2;
        }
        return c;
      }
      function N(T) {
        for (var B = T[0], K = T[1] - 1; K >= 0; )
          B & 1 << K && (V |= 1 << q), K--, --q < 0 && (V == 255 ? (ne(255), ne(0)) : ne(V), q = 7, V = 0);
      }
      function ne(T) {
        F.push(T);
      }
      function le(T) {
        ne(T >> 8 & 255), ne(255 & T);
      }
      function he(T, B, K, h, c) {
        for (var m, D = c[0], ee = c[240], E = function(ce, xe) {
          var Ce, _e, Be, Pe, Fe, We, Qe, lt, P, we, X = 0;
          for (P = 0; P < 8; ++P) {
            Ce = ce[X], _e = ce[X + 1], Be = ce[X + 2], Pe = ce[X + 3], Fe = ce[X + 4], We = ce[X + 5], Qe = ce[X + 6];
            var de = Ce + (lt = ce[X + 7]), Ze = Ce - lt, Re = _e + Qe, rt = _e - Qe, De = Be + We, Je = Be - We, Ne = Pe + Fe, Ie = Pe - Fe, at = de + Ne, st = de - Ne, tt = Re + De, mt = Re - De;
            ce[X] = at + tt, ce[X + 4] = at - tt;
            var It = 0.707106781 * (mt + st);
            ce[X + 2] = st + It, ce[X + 6] = st - It;
            var wt = 0.382683433 * ((at = Ie + Je) - (mt = rt + Ze)), ot = 0.5411961 * at + wt, kt = 1.306562965 * mt + wt, Ft = 0.707106781 * (tt = Je + rt), Rt = Ze + Ft, qt = Ze - Ft;
            ce[X + 5] = qt + ot, ce[X + 3] = qt - ot, ce[X + 1] = Rt + kt, ce[X + 7] = Rt - kt, X += 8;
          }
          for (X = 0, P = 0; P < 8; ++P) {
            Ce = ce[X], _e = ce[X + 8], Be = ce[X + 16], Pe = ce[X + 24], Fe = ce[X + 32], We = ce[X + 40], Qe = ce[X + 48];
            var Lt = Ce + (lt = ce[X + 56]), Se = Ce - lt, Ye = _e + Qe, Ke = _e - Qe, ut = Be + We, bt = Be - We, At = Pe + Fe, Ct = Pe - Fe, vt = Lt + At, Dt = Lt - At, Nt = Ye + ut, Ut = Ye - ut;
            ce[X] = vt + Nt, ce[X + 32] = vt - Nt;
            var Gt = 0.707106781 * (Ut + Dt);
            ce[X + 16] = Dt + Gt, ce[X + 48] = Dt - Gt;
            var Jt = 0.382683433 * ((vt = Ct + bt) - (Ut = Ke + Se)), er = 0.5411961 * vt + Jt, Xt = 1.306562965 * Ut + Jt, or = 0.707106781 * (Nt = bt + Ke), Tt = Se + or, nr = Se - or;
            ce[X + 40] = nr + er, ce[X + 24] = nr - er, ce[X + 8] = Tt + Xt, ce[X + 56] = Tt - Xt, X++;
          }
          for (P = 0; P < 64; ++P)
            we = ce[P] * xe[P], M[P] = we > 0 ? we + 0.5 | 0 : we - 0.5 | 0;
          return M;
        }(T, B), Q = 0; Q < 64; ++Q)
          G[j[Q]] = E[Q];
        var se = G[0] - K;
        K = G[0], se == 0 ? N(h[0]) : (N(h[w[m = 32767 + se]]), N(b[m]));
        for (var Y = 63; Y > 0 && G[Y] == 0; Y--)
          ;
        if (Y == 0)
          return N(D), K;
        for (var be, Ee = 1; Ee <= Y; ) {
          for (var Me = Ee; G[Ee] == 0 && Ee <= Y; ++Ee)
            ;
          var ke = Ee - Me;
          if (ke >= 16) {
            be = ke >> 4;
            for (var oe = 1; oe <= be; ++oe)
              N(ee);
            ke &= 15;
          }
          m = 32767 + G[Ee], N(c[(ke << 4) + w[m]]), N(b[m]), Ee++;
        }
        return Y != 63 && N(D), K;
      }
      function k(T) {
        T <= 0 && (T = 1), T > 100 && (T = 100), n != T && (function(B) {
          for (var K = [16, 11, 10, 16, 24, 40, 51, 61, 12, 12, 14, 19, 26, 58, 60, 55, 14, 13, 16, 24, 40, 57, 69, 56, 14, 17, 22, 29, 51, 87, 80, 62, 18, 22, 37, 56, 68, 109, 103, 77, 24, 35, 55, 64, 81, 104, 113, 92, 49, 64, 78, 87, 103, 121, 120, 101, 72, 92, 95, 98, 112, 100, 103, 99], h = 0; h < 64; h++) {
            var c = u((K[h] * B + 50) / 100);
            c < 1 ? c = 1 : c > 255 && (c = 255), p[j[h]] = c;
          }
          for (var m = [17, 18, 24, 47, 99, 99, 99, 99, 18, 21, 26, 66, 99, 99, 99, 99, 24, 26, 56, 99, 99, 99, 99, 99, 47, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99], D = 0; D < 64; D++) {
            var ee = u((m[D] * B + 50) / 100);
            ee < 1 ? ee = 1 : ee > 255 && (ee = 255), g[j[D]] = ee;
          }
          for (var E = [1, 1.387039845, 1.306562965, 1.175875602, 1, 0.785694958, 0.5411961, 0.275899379], Q = 0, se = 0; se < 8; se++)
            for (var Y = 0; Y < 8; Y++)
              v[Q] = 1 / (p[j[Q]] * E[se] * E[Y] * 8), x[Q] = 1 / (g[j[Q]] * E[se] * E[Y] * 8), Q++;
        }(T < 50 ? Math.floor(5e3 / T) : Math.floor(200 - 2 * T)), n = T);
      }
      this.encode = function(T, B) {
        var K;
        (/* @__PURE__ */ new Date()).getTime(), B && k(B), F = new Array(), V = 0, q = 7, le(65496), le(65504), le(16), ne(74), ne(70), ne(73), ne(70), ne(0), ne(1), ne(1), ne(0), le(1), le(1), ne(0), ne(0), (K = T.comments) !== void 0 && K.constructor === Array && K.forEach((Be) => {
          if (typeof Be == "string") {
            le(65534);
            var Pe, Fe = Be.length;
            for (le(Fe + 2), Pe = 0; Pe < Fe; Pe++)
              ne(Be.charCodeAt(Pe));
          }
        }), function(Be) {
          if (Be) {
            le(65505), Be[0] === 69 && Be[1] === 120 && Be[2] === 105 && Be[3] === 102 ? le(Be.length + 2) : (le(Be.length + 5 + 2), ne(69), ne(120), ne(105), ne(102), ne(0));
            for (var Pe = 0; Pe < Be.length; Pe++)
              ne(Be[Pe]);
          }
        }(T.exifBuffer), function() {
          le(65499), le(132), ne(0);
          for (var Be = 0; Be < 64; Be++)
            ne(p[Be]);
          ne(1);
          for (var Pe = 0; Pe < 64; Pe++)
            ne(g[Pe]);
        }(), function(Be, Pe) {
          le(65472), le(17), ne(8), le(Pe), le(Be), ne(3), ne(1), ne(17), ne(0), ne(2), ne(17), ne(1), ne(3), ne(17), ne(1);
        }(T.width, T.height), function() {
          le(65476), le(418), ne(0);
          for (var Be = 0; Be < 16; Be++)
            ne(U[Be + 1]);
          for (var Pe = 0; Pe <= 11; Pe++)
            ne(C[Pe]);
          ne(16);
          for (var Fe = 0; Fe < 16; Fe++)
            ne(ae[Fe + 1]);
          for (var We = 0; We <= 161; We++)
            ne(J[We]);
          ne(1);
          for (var Qe = 0; Qe < 16; Qe++)
            ne(te[Qe + 1]);
          for (var lt = 0; lt <= 11; lt++)
            ne($[lt]);
          ne(17);
          for (var P = 0; P < 16; P++)
            ne(L[P + 1]);
          for (var we = 0; we <= 161; we++)
            ne(re[we]);
        }(), le(65498), le(12), ne(3), ne(1), ne(0), ne(2), ne(17), ne(3), ne(17), ne(0), ne(63), ne(0);
        var h = 0, c = 0, m = 0;
        V = 0, q = 7, this.encode.displayName = "_encode_";
        for (var D, ee, E, Q, se, Y, be, Ee, Me, ke = T.data, oe = T.width, ce = T.height, xe = 4 * oe, Ce = 0; Ce < ce; ) {
          for (D = 0; D < xe; ) {
            for (Y = se = xe * Ce + D, be = -1, Ee = 0, Me = 0; Me < 64; Me++)
              Y = se + (Ee = Me >> 3) * xe + (be = 4 * (7 & Me)), Ce + Ee >= ce && (Y -= xe * (Ce + 1 + Ee - ce)), D + be >= xe && (Y -= D + be - xe + 4), ee = ke[Y++], E = ke[Y++], Q = ke[Y++], I[Me] = (O[ee] + O[E + 256 >> 0] + O[Q + 512 >> 0] >> 16) - 128, _[Me] = (O[ee + 768 >> 0] + O[E + 1024 >> 0] + O[Q + 1280 >> 0] >> 16) - 128, R[Me] = (O[ee + 1280 >> 0] + O[E + 1536 >> 0] + O[Q + 1792 >> 0] >> 16) - 128;
            h = he(I, v, h, a, r), c = he(_, x, c, t, o), m = he(R, x, m, t, o), D += 32;
          }
          Ce += 8;
        }
        if (q >= 0) {
          var _e = [];
          _e[1] = q + 1, _e[0] = (1 << q + 1) - 1, N(_e);
        }
        return le(65497), e.from(F);
      }, (/* @__PURE__ */ new Date()).getTime(), i || (i = 50), function() {
        for (var T = String.fromCharCode, B = 0; B < 256; B++)
          W[B] = T(B);
      }(), a = z(U, C), t = z(te, $), r = z(ae, J), o = z(L, re), function() {
        for (var T = 1, B = 2, K = 1; K <= 15; K++) {
          for (var h = T; h < B; h++)
            w[32767 + h] = K, b[32767 + h] = [], b[32767 + h][1] = K, b[32767 + h][0] = h;
          for (var c = -(B - 1); c <= -T; c++)
            w[32767 + c] = K, b[32767 + c] = [], b[32767 + c][1] = K, b[32767 + c][0] = B - 1 + c;
          T <<= 1, B <<= 1;
        }
      }(), function() {
        for (var T = 0; T < 256; T++)
          O[T] = 19595 * T, O[T + 256 >> 0] = 38470 * T, O[T + 512 >> 0] = 7471 * T + 32768, O[T + 768 >> 0] = -11059 * T, O[T + 1024 >> 0] = -21709 * T, O[T + 1280 >> 0] = 32768 * T + 8421375, O[T + 1536 >> 0] = -27439 * T, O[T + 1792 >> 0] = -5329 * T;
      }(), k(i), (/* @__PURE__ */ new Date()).getTime();
    }
    d.exports = function(i, a) {
      return a === void 0 && (a = 50), { data: new f(a).encode(i, a), width: i.width, height: i.height };
    };
  }, 8058: (d, l, s) => {
    var e = s(8834).lW, f = s(6290), i = function() {
    }, a = s(4398), t = s(5947), r = s(8438), o = s(5565), n = s(1960), u = self.XMLHttpRequest && "withCredentials" in new XMLHttpRequest();
    d.exports = function(p, g) {
      g = typeof g == "function" ? g : i, typeof p == "string" ? p = { uri: p } : p || (p = {}), p.binary && (p = function(v) {
        if (u)
          return n(v, { responseType: "arraybuffer" });
        if (self.XMLHttpRequest === void 0)
          throw new Error("your browser does not support XHR loading");
        var x = new self.XMLHttpRequest();
        return x.overrideMimeType("text/plain; charset=x-user-defined"), n({ xhr: x }, v);
      }(p)), f(p, function(v, x, b) {
        if (v)
          return g(v);
        if (!/^2/.test(x.statusCode))
          return g(new Error("http status code: " + x.statusCode));
        if (!b)
          return g(new Error("no body result"));
        var w, M, G = !1;
        if (w = b, Object.prototype.toString.call(w) === "[object ArrayBuffer]") {
          var F = new Uint8Array(b);
          b = e.from(F, "binary");
        }
        o(b) && (G = !0, typeof b == "string" && (b = e.from(b, "binary"))), G || (e.isBuffer(b) && (b = b.toString(p.encoding)), b = b.trim());
        try {
          var V = x.headers["content-type"];
          M = G ? r(b) : /json/.test(V) || b.charAt(0) === "{" ? JSON.parse(b) : /xml/.test(V) || b.charAt(0) === "<" ? t(b) : a(b);
        } catch (q) {
          g(new Error("error parsing font " + q.message)), g = i;
        }
        g(null, M);
      });
    };
  }, 5565: (d, l, s) => {
    var e = s(8834).lW, f = s(5137), i = e.from([66, 77, 70, 3]);
    d.exports = function(a) {
      return typeof a == "string" ? a.substring(0, 3) === "BMF" : a.length > 4 && f(a.slice(0, 4), i);
    };
  }, 63: (d, l) => {
    function s(e, f, i, a) {
      for (var t = e[f++], r = 1 << t, o = r + 1, n = o + 1, u = t + 1, p = (1 << u) - 1, g = 0, v = 0, x = 0, b = e[f++], w = new Int32Array(4096), M = null; ; ) {
        for (; g < 16 && b !== 0; )
          v |= e[f++] << g, g += 8, b === 1 ? b = e[f++] : --b;
        if (g < u)
          break;
        var G = v & p;
        if (v >>= u, g -= u, G !== r) {
          if (G === o)
            break;
          for (var F = G < n ? G : M, V = 0, q = F; q > r; )
            q = w[q] >> 8, ++V;
          var I = q;
          if (x + V + (F !== G ? 1 : 0) > a)
            return void console.log("Warning, gif stream longer than expected.");
          i[x++] = I;
          var _ = x += V;
          for (F !== G && (i[x++] = I), q = F; V--; )
            q = w[q], i[--_] = 255 & q, q >>= 8;
          M !== null && n < 4096 && (w[n++] = M << 8 | I, n >= p + 1 && u < 12 && (++u, p = p << 1 | 1)), M = G;
        } else
          n = o + 1, p = (1 << (u = t + 1)) - 1, M = null;
      }
      return x !== a && console.log("Warning, gif stream shorter than expected."), i;
    }
    try {
      l.N = function(e) {
        var f = 0;
        if (e[f++] !== 71 || e[f++] !== 73 || e[f++] !== 70 || e[f++] !== 56 || (e[f++] + 1 & 253) != 56 || e[f++] !== 97)
          throw new Error("Invalid GIF 87a/89a header.");
        var i = e[f++] | e[f++] << 8, a = e[f++] | e[f++] << 8, t = e[f++], r = t >> 7, o = 1 << 1 + (7 & t);
        e[f++], e[f++];
        var n = null, u = null;
        r && (n = f, u = o, f += 3 * o);
        var p = !0, g = [], v = 0, x = null, b = 0, w = null;
        for (this.width = i, this.height = a; p && f < e.length; )
          switch (e[f++]) {
            case 33:
              switch (e[f++]) {
                case 255:
                  if (e[f] !== 11 || e[f + 1] == 78 && e[f + 2] == 69 && e[f + 3] == 84 && e[f + 4] == 83 && e[f + 5] == 67 && e[f + 6] == 65 && e[f + 7] == 80 && e[f + 8] == 69 && e[f + 9] == 50 && e[f + 10] == 46 && e[f + 11] == 48 && e[f + 12] == 3 && e[f + 13] == 1 && e[f + 16] == 0)
                    f += 14, w = e[f++] | e[f++] << 8, f++;
                  else
                    for (f += 12; ; ) {
                      if (!((C = e[f++]) >= 0))
                        throw Error("Invalid block size");
                      if (C === 0)
                        break;
                      f += C;
                    }
                  break;
                case 249:
                  if (e[f++] !== 4 || e[f + 4] !== 0)
                    throw new Error("Invalid graphics extension block.");
                  var M = e[f++];
                  v = e[f++] | e[f++] << 8, x = e[f++], !(1 & M) && (x = null), b = M >> 2 & 7, f++;
                  break;
                case 254:
                  for (; ; ) {
                    if (!((C = e[f++]) >= 0))
                      throw Error("Invalid block size");
                    if (C === 0)
                      break;
                    f += C;
                  }
                  break;
                default:
                  throw new Error("Unknown graphic control label: 0x" + e[f - 1].toString(16));
              }
              break;
            case 44:
              var G = e[f++] | e[f++] << 8, F = e[f++] | e[f++] << 8, V = e[f++] | e[f++] << 8, q = e[f++] | e[f++] << 8, I = e[f++], _ = I >> 6 & 1, R = 1 << 1 + (7 & I), W = n, O = u, j = !1;
              I >> 7 && (j = !0, W = f, O = R, f += 3 * R);
              var U = f;
              for (f++; ; ) {
                var C;
                if (!((C = e[f++]) >= 0))
                  throw Error("Invalid block size");
                if (C === 0)
                  break;
                f += C;
              }
              g.push({ x: G, y: F, width: V, height: q, has_local_palette: j, palette_offset: W, palette_size: O, data_offset: U, data_length: f - U, transparent_index: x, interlaced: !!_, delay: v, disposal: b });
              break;
            case 59:
              p = !1;
              break;
            default:
              throw new Error("Unknown gif block: 0x" + e[f - 1].toString(16));
          }
        this.numFrames = function() {
          return g.length;
        }, this.loopCount = function() {
          return w;
        }, this.frameInfo = function(ae) {
          if (ae < 0 || ae >= g.length)
            throw new Error("Frame index out of range.");
          return g[ae];
        }, this.decodeAndBlitFrameBGRA = function(ae, J) {
          var te = this.frameInfo(ae), $ = te.width * te.height, L = new Uint8Array($);
          s(e, te.data_offset, L, $);
          var re = te.palette_offset, z = te.transparent_index;
          z === null && (z = 256);
          var N = te.width, ne = i - N, le = N, he = 4 * (te.y * i + te.x), k = 4 * ((te.y + te.height) * i + te.x), T = he, B = 4 * ne;
          te.interlaced === !0 && (B += 4 * i * 7);
          for (var K = 8, h = 0, c = L.length; h < c; ++h) {
            var m = L[h];
            if (le === 0 && (le = N, (T += B) >= k && (B = 4 * ne + 4 * i * (K - 1), T = he + (N + ne) * (K << 1), K >>= 1)), m === z)
              T += 4;
            else {
              var D = e[re + 3 * m], ee = e[re + 3 * m + 1], E = e[re + 3 * m + 2];
              J[T++] = E, J[T++] = ee, J[T++] = D, J[T++] = 255;
            }
            --le;
          }
        }, this.decodeAndBlitFrameRGBA = function(ae, J) {
          var te = this.frameInfo(ae), $ = te.width * te.height, L = new Uint8Array($);
          s(e, te.data_offset, L, $);
          var re = te.palette_offset, z = te.transparent_index;
          z === null && (z = 256);
          var N = te.width, ne = i - N, le = N, he = 4 * (te.y * i + te.x), k = 4 * ((te.y + te.height) * i + te.x), T = he, B = 4 * ne;
          te.interlaced === !0 && (B += 4 * i * 7);
          for (var K = 8, h = 0, c = L.length; h < c; ++h) {
            var m = L[h];
            if (le === 0 && (le = N, (T += B) >= k && (B = 4 * ne + 4 * i * (K - 1), T = he + (N + ne) * (K << 1), K >>= 1)), m === z)
              T += 4;
            else {
              var D = e[re + 3 * m], ee = e[re + 3 * m + 1], E = e[re + 3 * m + 2];
              J[T++] = D, J[T++] = ee, J[T++] = E, J[T++] = 255;
            }
            --le;
          }
        };
      };
    } catch {
    }
  }, 2845: (d, l, s) => {
    var e = {};
    (0, s(9761).assign)(e, s(9880), s(1380), s(1271)), d.exports = e;
  }, 9880: (d, l, s) => {
    var e = s(5789), f = s(9761), i = s(7944), a = s(2950), t = s(744), r = Object.prototype.toString, o = 0, n = -1, u = 0, p = 8;
    function g(x) {
      if (!(this instanceof g))
        return new g(x);
      this.options = f.assign({ level: n, method: p, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: u, to: "" }, x || {});
      var b = this.options;
      b.raw && b.windowBits > 0 ? b.windowBits = -b.windowBits : b.gzip && b.windowBits > 0 && b.windowBits < 16 && (b.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new t(), this.strm.avail_out = 0;
      var w = e.deflateInit2(this.strm, b.level, b.method, b.windowBits, b.memLevel, b.strategy);
      if (w !== o)
        throw new Error(a[w]);
      if (b.header && e.deflateSetHeader(this.strm, b.header), b.dictionary) {
        var M;
        if (M = typeof b.dictionary == "string" ? i.string2buf(b.dictionary) : r.call(b.dictionary) === "[object ArrayBuffer]" ? new Uint8Array(b.dictionary) : b.dictionary, (w = e.deflateSetDictionary(this.strm, M)) !== o)
          throw new Error(a[w]);
        this._dict_set = !0;
      }
    }
    function v(x, b) {
      var w = new g(b);
      if (w.push(x, !0), w.err)
        throw w.msg || a[w.err];
      return w.result;
    }
    g.prototype.push = function(x, b) {
      var w, M, G = this.strm, F = this.options.chunkSize;
      if (this.ended)
        return !1;
      M = b === ~~b ? b : b === !0 ? 4 : 0, typeof x == "string" ? G.input = i.string2buf(x) : r.call(x) === "[object ArrayBuffer]" ? G.input = new Uint8Array(x) : G.input = x, G.next_in = 0, G.avail_in = G.input.length;
      do {
        if (G.avail_out === 0 && (G.output = new f.Buf8(F), G.next_out = 0, G.avail_out = F), (w = e.deflate(G, M)) !== 1 && w !== o)
          return this.onEnd(w), this.ended = !0, !1;
        G.avail_out !== 0 && (G.avail_in !== 0 || M !== 4 && M !== 2) || (this.options.to === "string" ? this.onData(i.buf2binstring(f.shrinkBuf(G.output, G.next_out))) : this.onData(f.shrinkBuf(G.output, G.next_out)));
      } while ((G.avail_in > 0 || G.avail_out === 0) && w !== 1);
      return M === 4 ? (w = e.deflateEnd(this.strm), this.onEnd(w), this.ended = !0, w === o) : M !== 2 || (this.onEnd(o), G.avail_out = 0, !0);
    }, g.prototype.onData = function(x) {
      this.chunks.push(x);
    }, g.prototype.onEnd = function(x) {
      x === o && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = x, this.msg = this.strm.msg;
    }, l.Deflate = g, l.deflate = v, l.deflateRaw = function(x, b) {
      return (b = b || {}).raw = !0, v(x, b);
    }, l.gzip = function(x, b) {
      return (b = b || {}).gzip = !0, v(x, b);
    };
  }, 1380: (d, l, s) => {
    var e = s(5020), f = s(9761), i = s(7944), a = s(1271), t = s(2950), r = s(744), o = s(7357), n = Object.prototype.toString;
    function u(g) {
      if (!(this instanceof u))
        return new u(g);
      this.options = f.assign({ chunkSize: 16384, windowBits: 0, to: "" }, g || {});
      var v = this.options;
      v.raw && v.windowBits >= 0 && v.windowBits < 16 && (v.windowBits = -v.windowBits, v.windowBits === 0 && (v.windowBits = -15)), !(v.windowBits >= 0 && v.windowBits < 16) || g && g.windowBits || (v.windowBits += 32), v.windowBits > 15 && v.windowBits < 48 && !(15 & v.windowBits) && (v.windowBits |= 15), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new r(), this.strm.avail_out = 0;
      var x = e.inflateInit2(this.strm, v.windowBits);
      if (x !== a.Z_OK)
        throw new Error(t[x]);
      if (this.header = new o(), e.inflateGetHeader(this.strm, this.header), v.dictionary && (typeof v.dictionary == "string" ? v.dictionary = i.string2buf(v.dictionary) : n.call(v.dictionary) === "[object ArrayBuffer]" && (v.dictionary = new Uint8Array(v.dictionary)), v.raw && (x = e.inflateSetDictionary(this.strm, v.dictionary)) !== a.Z_OK))
        throw new Error(t[x]);
    }
    function p(g, v) {
      var x = new u(v);
      if (x.push(g, !0), x.err)
        throw x.msg || t[x.err];
      return x.result;
    }
    u.prototype.push = function(g, v) {
      var x, b, w, M, G, F = this.strm, V = this.options.chunkSize, q = this.options.dictionary, I = !1;
      if (this.ended)
        return !1;
      b = v === ~~v ? v : v === !0 ? a.Z_FINISH : a.Z_NO_FLUSH, typeof g == "string" ? F.input = i.binstring2buf(g) : n.call(g) === "[object ArrayBuffer]" ? F.input = new Uint8Array(g) : F.input = g, F.next_in = 0, F.avail_in = F.input.length;
      do {
        if (F.avail_out === 0 && (F.output = new f.Buf8(V), F.next_out = 0, F.avail_out = V), (x = e.inflate(F, a.Z_NO_FLUSH)) === a.Z_NEED_DICT && q && (x = e.inflateSetDictionary(this.strm, q)), x === a.Z_BUF_ERROR && I === !0 && (x = a.Z_OK, I = !1), x !== a.Z_STREAM_END && x !== a.Z_OK)
          return this.onEnd(x), this.ended = !0, !1;
        F.next_out && (F.avail_out !== 0 && x !== a.Z_STREAM_END && (F.avail_in !== 0 || b !== a.Z_FINISH && b !== a.Z_SYNC_FLUSH) || (this.options.to === "string" ? (w = i.utf8border(F.output, F.next_out), M = F.next_out - w, G = i.buf2string(F.output, w), F.next_out = M, F.avail_out = V - M, M && f.arraySet(F.output, F.output, w, M, 0), this.onData(G)) : this.onData(f.shrinkBuf(F.output, F.next_out)))), F.avail_in === 0 && F.avail_out === 0 && (I = !0);
      } while ((F.avail_in > 0 || F.avail_out === 0) && x !== a.Z_STREAM_END);
      return x === a.Z_STREAM_END && (b = a.Z_FINISH), b === a.Z_FINISH ? (x = e.inflateEnd(this.strm), this.onEnd(x), this.ended = !0, x === a.Z_OK) : b !== a.Z_SYNC_FLUSH || (this.onEnd(a.Z_OK), F.avail_out = 0, !0);
    }, u.prototype.onData = function(g) {
      this.chunks.push(g);
    }, u.prototype.onEnd = function(g) {
      g === a.Z_OK && (this.options.to === "string" ? this.result = this.chunks.join("") : this.result = f.flattenChunks(this.chunks)), this.chunks = [], this.err = g, this.msg = this.strm.msg;
    }, l.Inflate = u, l.inflate = p, l.inflateRaw = function(g, v) {
      return (v = v || {}).raw = !0, p(g, v);
    }, l.ungzip = p;
  }, 9761: (d, l) => {
    var s = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
    function e(a, t) {
      return Object.prototype.hasOwnProperty.call(a, t);
    }
    l.assign = function(a) {
      for (var t = Array.prototype.slice.call(arguments, 1); t.length; ) {
        var r = t.shift();
        if (r) {
          if (typeof r != "object")
            throw new TypeError(r + "must be non-object");
          for (var o in r)
            e(r, o) && (a[o] = r[o]);
        }
      }
      return a;
    }, l.shrinkBuf = function(a, t) {
      return a.length === t ? a : a.subarray ? a.subarray(0, t) : (a.length = t, a);
    };
    var f = { arraySet: function(a, t, r, o, n) {
      if (t.subarray && a.subarray)
        a.set(t.subarray(r, r + o), n);
      else
        for (var u = 0; u < o; u++)
          a[n + u] = t[r + u];
    }, flattenChunks: function(a) {
      var t, r, o, n, u, p;
      for (o = 0, t = 0, r = a.length; t < r; t++)
        o += a[t].length;
      for (p = new Uint8Array(o), n = 0, t = 0, r = a.length; t < r; t++)
        u = a[t], p.set(u, n), n += u.length;
      return p;
    } }, i = { arraySet: function(a, t, r, o, n) {
      for (var u = 0; u < o; u++)
        a[n + u] = t[r + u];
    }, flattenChunks: function(a) {
      return [].concat.apply([], a);
    } };
    l.setTyped = function(a) {
      a ? (l.Buf8 = Uint8Array, l.Buf16 = Uint16Array, l.Buf32 = Int32Array, l.assign(l, f)) : (l.Buf8 = Array, l.Buf16 = Array, l.Buf32 = Array, l.assign(l, i));
    }, l.setTyped(s);
  }, 7944: (d, l, s) => {
    var e = s(9761), f = !0, i = !0;
    try {
      String.fromCharCode.apply(null, [0]);
    } catch {
      f = !1;
    }
    try {
      String.fromCharCode.apply(null, new Uint8Array(1));
    } catch {
      i = !1;
    }
    for (var a = new e.Buf8(256), t = 0; t < 256; t++)
      a[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1;
    function r(o, n) {
      if (n < 65534 && (o.subarray && i || !o.subarray && f))
        return String.fromCharCode.apply(null, e.shrinkBuf(o, n));
      for (var u = "", p = 0; p < n; p++)
        u += String.fromCharCode(o[p]);
      return u;
    }
    a[254] = a[254] = 1, l.string2buf = function(o) {
      var n, u, p, g, v, x = o.length, b = 0;
      for (g = 0; g < x; g++)
        (64512 & (u = o.charCodeAt(g))) == 55296 && g + 1 < x && (64512 & (p = o.charCodeAt(g + 1))) == 56320 && (u = 65536 + (u - 55296 << 10) + (p - 56320), g++), b += u < 128 ? 1 : u < 2048 ? 2 : u < 65536 ? 3 : 4;
      for (n = new e.Buf8(b), v = 0, g = 0; v < b; g++)
        (64512 & (u = o.charCodeAt(g))) == 55296 && g + 1 < x && (64512 & (p = o.charCodeAt(g + 1))) == 56320 && (u = 65536 + (u - 55296 << 10) + (p - 56320), g++), u < 128 ? n[v++] = u : u < 2048 ? (n[v++] = 192 | u >>> 6, n[v++] = 128 | 63 & u) : u < 65536 ? (n[v++] = 224 | u >>> 12, n[v++] = 128 | u >>> 6 & 63, n[v++] = 128 | 63 & u) : (n[v++] = 240 | u >>> 18, n[v++] = 128 | u >>> 12 & 63, n[v++] = 128 | u >>> 6 & 63, n[v++] = 128 | 63 & u);
      return n;
    }, l.buf2binstring = function(o) {
      return r(o, o.length);
    }, l.binstring2buf = function(o) {
      for (var n = new e.Buf8(o.length), u = 0, p = n.length; u < p; u++)
        n[u] = o.charCodeAt(u);
      return n;
    }, l.buf2string = function(o, n) {
      var u, p, g, v, x = n || o.length, b = new Array(2 * x);
      for (p = 0, u = 0; u < x; )
        if ((g = o[u++]) < 128)
          b[p++] = g;
        else if ((v = a[g]) > 4)
          b[p++] = 65533, u += v - 1;
        else {
          for (g &= v === 2 ? 31 : v === 3 ? 15 : 7; v > 1 && u < x; )
            g = g << 6 | 63 & o[u++], v--;
          v > 1 ? b[p++] = 65533 : g < 65536 ? b[p++] = g : (g -= 65536, b[p++] = 55296 | g >> 10 & 1023, b[p++] = 56320 | 1023 & g);
        }
      return r(b, p);
    }, l.utf8border = function(o, n) {
      var u;
      for ((n = n || o.length) > o.length && (n = o.length), u = n - 1; u >= 0 && (192 & o[u]) == 128; )
        u--;
      return u < 0 || u === 0 ? n : u + a[o[u]] > n ? u : n;
    };
  }, 5562: (d) => {
    d.exports = function(l, s, e, f) {
      for (var i = 65535 & l | 0, a = l >>> 16 & 65535 | 0, t = 0; e !== 0; ) {
        e -= t = e > 2e3 ? 2e3 : e;
        do
          a = a + (i = i + s[f++] | 0) | 0;
        while (--t);
        i %= 65521, a %= 65521;
      }
      return i | a << 16 | 0;
    };
  }, 1271: (d) => {
    d.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
  }, 4299: (d) => {
    var l = function() {
      for (var s, e = [], f = 0; f < 256; f++) {
        s = f;
        for (var i = 0; i < 8; i++)
          s = 1 & s ? 3988292384 ^ s >>> 1 : s >>> 1;
        e[f] = s;
      }
      return e;
    }();
    d.exports = function(s, e, f, i) {
      var a = l, t = i + f;
      s ^= -1;
      for (var r = i; r < t; r++)
        s = s >>> 8 ^ a[255 & (s ^ e[r])];
      return -1 ^ s;
    };
  }, 5789: (d, l, s) => {
    var e, f = s(9761), i = s(9564), a = s(5562), t = s(4299), r = s(2950), o = 0, n = 4, u = 0, p = -2, g = -1, v = 1, x = 4, b = 2, w = 8, M = 9, G = 286, F = 30, V = 19, q = 2 * G + 1, I = 15, _ = 3, R = 258, W = R + _ + 1, O = 42, j = 103, U = 113, C = 666, ae = 1, J = 2, te = 3, $ = 4;
    function L(E, Q) {
      return E.msg = r[Q], Q;
    }
    function re(E) {
      return (E << 1) - (E > 4 ? 9 : 0);
    }
    function z(E) {
      for (var Q = E.length; --Q >= 0; )
        E[Q] = 0;
    }
    function N(E) {
      var Q = E.state, se = Q.pending;
      se > E.avail_out && (se = E.avail_out), se !== 0 && (f.arraySet(E.output, Q.pending_buf, Q.pending_out, se, E.next_out), E.next_out += se, Q.pending_out += se, E.total_out += se, E.avail_out -= se, Q.pending -= se, Q.pending === 0 && (Q.pending_out = 0));
    }
    function ne(E, Q) {
      i._tr_flush_block(E, E.block_start >= 0 ? E.block_start : -1, E.strstart - E.block_start, Q), E.block_start = E.strstart, N(E.strm);
    }
    function le(E, Q) {
      E.pending_buf[E.pending++] = Q;
    }
    function he(E, Q) {
      E.pending_buf[E.pending++] = Q >>> 8 & 255, E.pending_buf[E.pending++] = 255 & Q;
    }
    function k(E, Q) {
      var se, Y, be = E.max_chain_length, Ee = E.strstart, Me = E.prev_length, ke = E.nice_match, oe = E.strstart > E.w_size - W ? E.strstart - (E.w_size - W) : 0, ce = E.window, xe = E.w_mask, Ce = E.prev, _e = E.strstart + R, Be = ce[Ee + Me - 1], Pe = ce[Ee + Me];
      E.prev_length >= E.good_match && (be >>= 2), ke > E.lookahead && (ke = E.lookahead);
      do
        if (ce[(se = Q) + Me] === Pe && ce[se + Me - 1] === Be && ce[se] === ce[Ee] && ce[++se] === ce[Ee + 1]) {
          Ee += 2, se++;
          do
            ;
          while (ce[++Ee] === ce[++se] && ce[++Ee] === ce[++se] && ce[++Ee] === ce[++se] && ce[++Ee] === ce[++se] && ce[++Ee] === ce[++se] && ce[++Ee] === ce[++se] && ce[++Ee] === ce[++se] && ce[++Ee] === ce[++se] && Ee < _e);
          if (Y = R - (_e - Ee), Ee = _e - R, Y > Me) {
            if (E.match_start = Q, Me = Y, Y >= ke)
              break;
            Be = ce[Ee + Me - 1], Pe = ce[Ee + Me];
          }
        }
      while ((Q = Ce[Q & xe]) > oe && --be != 0);
      return Me <= E.lookahead ? Me : E.lookahead;
    }
    function T(E) {
      var Q, se, Y, be, Ee, Me, ke, oe, ce, xe, Ce = E.w_size;
      do {
        if (be = E.window_size - E.lookahead - E.strstart, E.strstart >= Ce + (Ce - W)) {
          f.arraySet(E.window, E.window, Ce, Ce, 0), E.match_start -= Ce, E.strstart -= Ce, E.block_start -= Ce, Q = se = E.hash_size;
          do
            Y = E.head[--Q], E.head[Q] = Y >= Ce ? Y - Ce : 0;
          while (--se);
          Q = se = Ce;
          do
            Y = E.prev[--Q], E.prev[Q] = Y >= Ce ? Y - Ce : 0;
          while (--se);
          be += Ce;
        }
        if (E.strm.avail_in === 0)
          break;
        if (Me = E.strm, ke = E.window, oe = E.strstart + E.lookahead, ce = be, xe = void 0, (xe = Me.avail_in) > ce && (xe = ce), se = xe === 0 ? 0 : (Me.avail_in -= xe, f.arraySet(ke, Me.input, Me.next_in, xe, oe), Me.state.wrap === 1 ? Me.adler = a(Me.adler, ke, xe, oe) : Me.state.wrap === 2 && (Me.adler = t(Me.adler, ke, xe, oe)), Me.next_in += xe, Me.total_in += xe, xe), E.lookahead += se, E.lookahead + E.insert >= _)
          for (Ee = E.strstart - E.insert, E.ins_h = E.window[Ee], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[Ee + 1]) & E.hash_mask; E.insert && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[Ee + _ - 1]) & E.hash_mask, E.prev[Ee & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = Ee, Ee++, E.insert--, !(E.lookahead + E.insert < _)); )
            ;
      } while (E.lookahead < W && E.strm.avail_in !== 0);
    }
    function B(E, Q) {
      for (var se, Y; ; ) {
        if (E.lookahead < W) {
          if (T(E), E.lookahead < W && Q === o)
            return ae;
          if (E.lookahead === 0)
            break;
        }
        if (se = 0, E.lookahead >= _ && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + _ - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), se !== 0 && E.strstart - se <= E.w_size - W && (E.match_length = k(E, se)), E.match_length >= _)
          if (Y = i._tr_tally(E, E.strstart - E.match_start, E.match_length - _), E.lookahead -= E.match_length, E.match_length <= E.max_lazy_match && E.lookahead >= _) {
            E.match_length--;
            do
              E.strstart++, E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + _ - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart;
            while (--E.match_length != 0);
            E.strstart++;
          } else
            E.strstart += E.match_length, E.match_length = 0, E.ins_h = E.window[E.strstart], E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + 1]) & E.hash_mask;
        else
          Y = i._tr_tally(E, 0, E.window[E.strstart]), E.lookahead--, E.strstart++;
        if (Y && (ne(E, !1), E.strm.avail_out === 0))
          return ae;
      }
      return E.insert = E.strstart < _ - 1 ? E.strstart : _ - 1, Q === n ? (ne(E, !0), E.strm.avail_out === 0 ? te : $) : E.last_lit && (ne(E, !1), E.strm.avail_out === 0) ? ae : J;
    }
    function K(E, Q) {
      for (var se, Y, be; ; ) {
        if (E.lookahead < W) {
          if (T(E), E.lookahead < W && Q === o)
            return ae;
          if (E.lookahead === 0)
            break;
        }
        if (se = 0, E.lookahead >= _ && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + _ - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart), E.prev_length = E.match_length, E.prev_match = E.match_start, E.match_length = _ - 1, se !== 0 && E.prev_length < E.max_lazy_match && E.strstart - se <= E.w_size - W && (E.match_length = k(E, se), E.match_length <= 5 && (E.strategy === v || E.match_length === _ && E.strstart - E.match_start > 4096) && (E.match_length = _ - 1)), E.prev_length >= _ && E.match_length <= E.prev_length) {
          be = E.strstart + E.lookahead - _, Y = i._tr_tally(E, E.strstart - 1 - E.prev_match, E.prev_length - _), E.lookahead -= E.prev_length - 1, E.prev_length -= 2;
          do
            ++E.strstart <= be && (E.ins_h = (E.ins_h << E.hash_shift ^ E.window[E.strstart + _ - 1]) & E.hash_mask, se = E.prev[E.strstart & E.w_mask] = E.head[E.ins_h], E.head[E.ins_h] = E.strstart);
          while (--E.prev_length != 0);
          if (E.match_available = 0, E.match_length = _ - 1, E.strstart++, Y && (ne(E, !1), E.strm.avail_out === 0))
            return ae;
        } else if (E.match_available) {
          if ((Y = i._tr_tally(E, 0, E.window[E.strstart - 1])) && ne(E, !1), E.strstart++, E.lookahead--, E.strm.avail_out === 0)
            return ae;
        } else
          E.match_available = 1, E.strstart++, E.lookahead--;
      }
      return E.match_available && (Y = i._tr_tally(E, 0, E.window[E.strstart - 1]), E.match_available = 0), E.insert = E.strstart < _ - 1 ? E.strstart : _ - 1, Q === n ? (ne(E, !0), E.strm.avail_out === 0 ? te : $) : E.last_lit && (ne(E, !1), E.strm.avail_out === 0) ? ae : J;
    }
    function h(E, Q, se, Y, be) {
      this.good_length = E, this.max_lazy = Q, this.nice_length = se, this.max_chain = Y, this.func = be;
    }
    function c() {
      this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = w, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new f.Buf16(2 * q), this.dyn_dtree = new f.Buf16(2 * (2 * F + 1)), this.bl_tree = new f.Buf16(2 * (2 * V + 1)), z(this.dyn_ltree), z(this.dyn_dtree), z(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new f.Buf16(I + 1), this.heap = new f.Buf16(2 * G + 1), z(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new f.Buf16(2 * G + 1), z(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
    }
    function m(E) {
      var Q;
      return E && E.state ? (E.total_in = E.total_out = 0, E.data_type = b, (Q = E.state).pending = 0, Q.pending_out = 0, Q.wrap < 0 && (Q.wrap = -Q.wrap), Q.status = Q.wrap ? O : U, E.adler = Q.wrap === 2 ? 0 : 1, Q.last_flush = o, i._tr_init(Q), u) : L(E, p);
    }
    function D(E) {
      var Q, se = m(E);
      return se === u && ((Q = E.state).window_size = 2 * Q.w_size, z(Q.head), Q.max_lazy_match = e[Q.level].max_lazy, Q.good_match = e[Q.level].good_length, Q.nice_match = e[Q.level].nice_length, Q.max_chain_length = e[Q.level].max_chain, Q.strstart = 0, Q.block_start = 0, Q.lookahead = 0, Q.insert = 0, Q.match_length = Q.prev_length = _ - 1, Q.match_available = 0, Q.ins_h = 0), se;
    }
    function ee(E, Q, se, Y, be, Ee) {
      if (!E)
        return p;
      var Me = 1;
      if (Q === g && (Q = 6), Y < 0 ? (Me = 0, Y = -Y) : Y > 15 && (Me = 2, Y -= 16), be < 1 || be > M || se !== w || Y < 8 || Y > 15 || Q < 0 || Q > 9 || Ee < 0 || Ee > x)
        return L(E, p);
      Y === 8 && (Y = 9);
      var ke = new c();
      return E.state = ke, ke.strm = E, ke.wrap = Me, ke.gzhead = null, ke.w_bits = Y, ke.w_size = 1 << ke.w_bits, ke.w_mask = ke.w_size - 1, ke.hash_bits = be + 7, ke.hash_size = 1 << ke.hash_bits, ke.hash_mask = ke.hash_size - 1, ke.hash_shift = ~~((ke.hash_bits + _ - 1) / _), ke.window = new f.Buf8(2 * ke.w_size), ke.head = new f.Buf16(ke.hash_size), ke.prev = new f.Buf16(ke.w_size), ke.lit_bufsize = 1 << be + 6, ke.pending_buf_size = 4 * ke.lit_bufsize, ke.pending_buf = new f.Buf8(ke.pending_buf_size), ke.d_buf = 1 * ke.lit_bufsize, ke.l_buf = 3 * ke.lit_bufsize, ke.level = Q, ke.strategy = Ee, ke.method = se, D(E);
    }
    e = [new h(0, 0, 0, 0, function(E, Q) {
      var se = 65535;
      for (se > E.pending_buf_size - 5 && (se = E.pending_buf_size - 5); ; ) {
        if (E.lookahead <= 1) {
          if (T(E), E.lookahead === 0 && Q === o)
            return ae;
          if (E.lookahead === 0)
            break;
        }
        E.strstart += E.lookahead, E.lookahead = 0;
        var Y = E.block_start + se;
        if ((E.strstart === 0 || E.strstart >= Y) && (E.lookahead = E.strstart - Y, E.strstart = Y, ne(E, !1), E.strm.avail_out === 0) || E.strstart - E.block_start >= E.w_size - W && (ne(E, !1), E.strm.avail_out === 0))
          return ae;
      }
      return E.insert = 0, Q === n ? (ne(E, !0), E.strm.avail_out === 0 ? te : $) : (E.strstart > E.block_start && (ne(E, !1), E.strm.avail_out), ae);
    }), new h(4, 4, 8, 4, B), new h(4, 5, 16, 8, B), new h(4, 6, 32, 32, B), new h(4, 4, 16, 16, K), new h(8, 16, 32, 32, K), new h(8, 16, 128, 128, K), new h(8, 32, 128, 256, K), new h(32, 128, 258, 1024, K), new h(32, 258, 258, 4096, K)], l.deflateInit = function(E, Q) {
      return ee(E, Q, w, 15, 8, 0);
    }, l.deflateInit2 = ee, l.deflateReset = D, l.deflateResetKeep = m, l.deflateSetHeader = function(E, Q) {
      return E && E.state ? E.state.wrap !== 2 ? p : (E.state.gzhead = Q, u) : p;
    }, l.deflate = function(E, Q) {
      var se, Y, be, Ee;
      if (!E || !E.state || Q > 5 || Q < 0)
        return E ? L(E, p) : p;
      if (Y = E.state, !E.output || !E.input && E.avail_in !== 0 || Y.status === C && Q !== n)
        return L(E, E.avail_out === 0 ? -5 : p);
      if (Y.strm = E, se = Y.last_flush, Y.last_flush = Q, Y.status === O)
        if (Y.wrap === 2)
          E.adler = 0, le(Y, 31), le(Y, 139), le(Y, 8), Y.gzhead ? (le(Y, (Y.gzhead.text ? 1 : 0) + (Y.gzhead.hcrc ? 2 : 0) + (Y.gzhead.extra ? 4 : 0) + (Y.gzhead.name ? 8 : 0) + (Y.gzhead.comment ? 16 : 0)), le(Y, 255 & Y.gzhead.time), le(Y, Y.gzhead.time >> 8 & 255), le(Y, Y.gzhead.time >> 16 & 255), le(Y, Y.gzhead.time >> 24 & 255), le(Y, Y.level === 9 ? 2 : Y.strategy >= 2 || Y.level < 2 ? 4 : 0), le(Y, 255 & Y.gzhead.os), Y.gzhead.extra && Y.gzhead.extra.length && (le(Y, 255 & Y.gzhead.extra.length), le(Y, Y.gzhead.extra.length >> 8 & 255)), Y.gzhead.hcrc && (E.adler = t(E.adler, Y.pending_buf, Y.pending, 0)), Y.gzindex = 0, Y.status = 69) : (le(Y, 0), le(Y, 0), le(Y, 0), le(Y, 0), le(Y, 0), le(Y, Y.level === 9 ? 2 : Y.strategy >= 2 || Y.level < 2 ? 4 : 0), le(Y, 3), Y.status = U);
        else {
          var Me = w + (Y.w_bits - 8 << 4) << 8;
          Me |= (Y.strategy >= 2 || Y.level < 2 ? 0 : Y.level < 6 ? 1 : Y.level === 6 ? 2 : 3) << 6, Y.strstart !== 0 && (Me |= 32), Me += 31 - Me % 31, Y.status = U, he(Y, Me), Y.strstart !== 0 && (he(Y, E.adler >>> 16), he(Y, 65535 & E.adler)), E.adler = 1;
        }
      if (Y.status === 69)
        if (Y.gzhead.extra) {
          for (be = Y.pending; Y.gzindex < (65535 & Y.gzhead.extra.length) && (Y.pending !== Y.pending_buf_size || (Y.gzhead.hcrc && Y.pending > be && (E.adler = t(E.adler, Y.pending_buf, Y.pending - be, be)), N(E), be = Y.pending, Y.pending !== Y.pending_buf_size)); )
            le(Y, 255 & Y.gzhead.extra[Y.gzindex]), Y.gzindex++;
          Y.gzhead.hcrc && Y.pending > be && (E.adler = t(E.adler, Y.pending_buf, Y.pending - be, be)), Y.gzindex === Y.gzhead.extra.length && (Y.gzindex = 0, Y.status = 73);
        } else
          Y.status = 73;
      if (Y.status === 73)
        if (Y.gzhead.name) {
          be = Y.pending;
          do {
            if (Y.pending === Y.pending_buf_size && (Y.gzhead.hcrc && Y.pending > be && (E.adler = t(E.adler, Y.pending_buf, Y.pending - be, be)), N(E), be = Y.pending, Y.pending === Y.pending_buf_size)) {
              Ee = 1;
              break;
            }
            Ee = Y.gzindex < Y.gzhead.name.length ? 255 & Y.gzhead.name.charCodeAt(Y.gzindex++) : 0, le(Y, Ee);
          } while (Ee !== 0);
          Y.gzhead.hcrc && Y.pending > be && (E.adler = t(E.adler, Y.pending_buf, Y.pending - be, be)), Ee === 0 && (Y.gzindex = 0, Y.status = 91);
        } else
          Y.status = 91;
      if (Y.status === 91)
        if (Y.gzhead.comment) {
          be = Y.pending;
          do {
            if (Y.pending === Y.pending_buf_size && (Y.gzhead.hcrc && Y.pending > be && (E.adler = t(E.adler, Y.pending_buf, Y.pending - be, be)), N(E), be = Y.pending, Y.pending === Y.pending_buf_size)) {
              Ee = 1;
              break;
            }
            Ee = Y.gzindex < Y.gzhead.comment.length ? 255 & Y.gzhead.comment.charCodeAt(Y.gzindex++) : 0, le(Y, Ee);
          } while (Ee !== 0);
          Y.gzhead.hcrc && Y.pending > be && (E.adler = t(E.adler, Y.pending_buf, Y.pending - be, be)), Ee === 0 && (Y.status = j);
        } else
          Y.status = j;
      if (Y.status === j && (Y.gzhead.hcrc ? (Y.pending + 2 > Y.pending_buf_size && N(E), Y.pending + 2 <= Y.pending_buf_size && (le(Y, 255 & E.adler), le(Y, E.adler >> 8 & 255), E.adler = 0, Y.status = U)) : Y.status = U), Y.pending !== 0) {
        if (N(E), E.avail_out === 0)
          return Y.last_flush = -1, u;
      } else if (E.avail_in === 0 && re(Q) <= re(se) && Q !== n)
        return L(E, -5);
      if (Y.status === C && E.avail_in !== 0)
        return L(E, -5);
      if (E.avail_in !== 0 || Y.lookahead !== 0 || Q !== o && Y.status !== C) {
        var ke = Y.strategy === 2 ? function(oe, ce) {
          for (var xe; ; ) {
            if (oe.lookahead === 0 && (T(oe), oe.lookahead === 0)) {
              if (ce === o)
                return ae;
              break;
            }
            if (oe.match_length = 0, xe = i._tr_tally(oe, 0, oe.window[oe.strstart]), oe.lookahead--, oe.strstart++, xe && (ne(oe, !1), oe.strm.avail_out === 0))
              return ae;
          }
          return oe.insert = 0, ce === n ? (ne(oe, !0), oe.strm.avail_out === 0 ? te : $) : oe.last_lit && (ne(oe, !1), oe.strm.avail_out === 0) ? ae : J;
        }(Y, Q) : Y.strategy === 3 ? function(oe, ce) {
          for (var xe, Ce, _e, Be, Pe = oe.window; ; ) {
            if (oe.lookahead <= R) {
              if (T(oe), oe.lookahead <= R && ce === o)
                return ae;
              if (oe.lookahead === 0)
                break;
            }
            if (oe.match_length = 0, oe.lookahead >= _ && oe.strstart > 0 && (Ce = Pe[_e = oe.strstart - 1]) === Pe[++_e] && Ce === Pe[++_e] && Ce === Pe[++_e]) {
              Be = oe.strstart + R;
              do
                ;
              while (Ce === Pe[++_e] && Ce === Pe[++_e] && Ce === Pe[++_e] && Ce === Pe[++_e] && Ce === Pe[++_e] && Ce === Pe[++_e] && Ce === Pe[++_e] && Ce === Pe[++_e] && _e < Be);
              oe.match_length = R - (Be - _e), oe.match_length > oe.lookahead && (oe.match_length = oe.lookahead);
            }
            if (oe.match_length >= _ ? (xe = i._tr_tally(oe, 1, oe.match_length - _), oe.lookahead -= oe.match_length, oe.strstart += oe.match_length, oe.match_length = 0) : (xe = i._tr_tally(oe, 0, oe.window[oe.strstart]), oe.lookahead--, oe.strstart++), xe && (ne(oe, !1), oe.strm.avail_out === 0))
              return ae;
          }
          return oe.insert = 0, ce === n ? (ne(oe, !0), oe.strm.avail_out === 0 ? te : $) : oe.last_lit && (ne(oe, !1), oe.strm.avail_out === 0) ? ae : J;
        }(Y, Q) : e[Y.level].func(Y, Q);
        if (ke !== te && ke !== $ || (Y.status = C), ke === ae || ke === te)
          return E.avail_out === 0 && (Y.last_flush = -1), u;
        if (ke === J && (Q === 1 ? i._tr_align(Y) : Q !== 5 && (i._tr_stored_block(Y, 0, 0, !1), Q === 3 && (z(Y.head), Y.lookahead === 0 && (Y.strstart = 0, Y.block_start = 0, Y.insert = 0))), N(E), E.avail_out === 0))
          return Y.last_flush = -1, u;
      }
      return Q !== n ? u : Y.wrap <= 0 ? 1 : (Y.wrap === 2 ? (le(Y, 255 & E.adler), le(Y, E.adler >> 8 & 255), le(Y, E.adler >> 16 & 255), le(Y, E.adler >> 24 & 255), le(Y, 255 & E.total_in), le(Y, E.total_in >> 8 & 255), le(Y, E.total_in >> 16 & 255), le(Y, E.total_in >> 24 & 255)) : (he(Y, E.adler >>> 16), he(Y, 65535 & E.adler)), N(E), Y.wrap > 0 && (Y.wrap = -Y.wrap), Y.pending !== 0 ? u : 1);
    }, l.deflateEnd = function(E) {
      var Q;
      return E && E.state ? (Q = E.state.status) !== O && Q !== 69 && Q !== 73 && Q !== 91 && Q !== j && Q !== U && Q !== C ? L(E, p) : (E.state = null, Q === U ? L(E, -3) : u) : p;
    }, l.deflateSetDictionary = function(E, Q) {
      var se, Y, be, Ee, Me, ke, oe, ce, xe = Q.length;
      if (!E || !E.state || (Ee = (se = E.state).wrap) === 2 || Ee === 1 && se.status !== O || se.lookahead)
        return p;
      for (Ee === 1 && (E.adler = a(E.adler, Q, xe, 0)), se.wrap = 0, xe >= se.w_size && (Ee === 0 && (z(se.head), se.strstart = 0, se.block_start = 0, se.insert = 0), ce = new f.Buf8(se.w_size), f.arraySet(ce, Q, xe - se.w_size, se.w_size, 0), Q = ce, xe = se.w_size), Me = E.avail_in, ke = E.next_in, oe = E.input, E.avail_in = xe, E.next_in = 0, E.input = Q, T(se); se.lookahead >= _; ) {
        Y = se.strstart, be = se.lookahead - (_ - 1);
        do
          se.ins_h = (se.ins_h << se.hash_shift ^ se.window[Y + _ - 1]) & se.hash_mask, se.prev[Y & se.w_mask] = se.head[se.ins_h], se.head[se.ins_h] = Y, Y++;
        while (--be);
        se.strstart = Y, se.lookahead = _ - 1, T(se);
      }
      return se.strstart += se.lookahead, se.block_start = se.strstart, se.insert = se.lookahead, se.lookahead = 0, se.match_length = se.prev_length = _ - 1, se.match_available = 0, E.next_in = ke, E.input = oe, E.avail_in = Me, se.wrap = Ee, u;
    }, l.deflateInfo = "pako deflate (from Nodeca project)";
  }, 7357: (d) => {
    d.exports = function() {
      this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1;
    };
  }, 4980: (d) => {
    d.exports = function(l, s) {
      var e, f, i, a, t, r, o, n, u, p, g, v, x, b, w, M, G, F, V, q, I, _, R, W, O;
      e = l.state, f = l.next_in, W = l.input, i = f + (l.avail_in - 5), a = l.next_out, O = l.output, t = a - (s - l.avail_out), r = a + (l.avail_out - 257), o = e.dmax, n = e.wsize, u = e.whave, p = e.wnext, g = e.window, v = e.hold, x = e.bits, b = e.lencode, w = e.distcode, M = (1 << e.lenbits) - 1, G = (1 << e.distbits) - 1;
      e:
        do {
          x < 15 && (v += W[f++] << x, x += 8, v += W[f++] << x, x += 8), F = b[v & M];
          t:
            for (; ; ) {
              if (v >>>= V = F >>> 24, x -= V, (V = F >>> 16 & 255) == 0)
                O[a++] = 65535 & F;
              else {
                if (!(16 & V)) {
                  if (!(64 & V)) {
                    F = b[(65535 & F) + (v & (1 << V) - 1)];
                    continue t;
                  }
                  if (32 & V) {
                    e.mode = 12;
                    break e;
                  }
                  l.msg = "invalid literal/length code", e.mode = 30;
                  break e;
                }
                q = 65535 & F, (V &= 15) && (x < V && (v += W[f++] << x, x += 8), q += v & (1 << V) - 1, v >>>= V, x -= V), x < 15 && (v += W[f++] << x, x += 8, v += W[f++] << x, x += 8), F = w[v & G];
                r:
                  for (; ; ) {
                    if (v >>>= V = F >>> 24, x -= V, !(16 & (V = F >>> 16 & 255))) {
                      if (!(64 & V)) {
                        F = w[(65535 & F) + (v & (1 << V) - 1)];
                        continue r;
                      }
                      l.msg = "invalid distance code", e.mode = 30;
                      break e;
                    }
                    if (I = 65535 & F, x < (V &= 15) && (v += W[f++] << x, (x += 8) < V && (v += W[f++] << x, x += 8)), (I += v & (1 << V) - 1) > o) {
                      l.msg = "invalid distance too far back", e.mode = 30;
                      break e;
                    }
                    if (v >>>= V, x -= V, I > (V = a - t)) {
                      if ((V = I - V) > u && e.sane) {
                        l.msg = "invalid distance too far back", e.mode = 30;
                        break e;
                      }
                      if (_ = 0, R = g, p === 0) {
                        if (_ += n - V, V < q) {
                          q -= V;
                          do
                            O[a++] = g[_++];
                          while (--V);
                          _ = a - I, R = O;
                        }
                      } else if (p < V) {
                        if (_ += n + p - V, (V -= p) < q) {
                          q -= V;
                          do
                            O[a++] = g[_++];
                          while (--V);
                          if (_ = 0, p < q) {
                            q -= V = p;
                            do
                              O[a++] = g[_++];
                            while (--V);
                            _ = a - I, R = O;
                          }
                        }
                      } else if (_ += p - V, V < q) {
                        q -= V;
                        do
                          O[a++] = g[_++];
                        while (--V);
                        _ = a - I, R = O;
                      }
                      for (; q > 2; )
                        O[a++] = R[_++], O[a++] = R[_++], O[a++] = R[_++], q -= 3;
                      q && (O[a++] = R[_++], q > 1 && (O[a++] = R[_++]));
                    } else {
                      _ = a - I;
                      do
                        O[a++] = O[_++], O[a++] = O[_++], O[a++] = O[_++], q -= 3;
                      while (q > 2);
                      q && (O[a++] = O[_++], q > 1 && (O[a++] = O[_++]));
                    }
                    break;
                  }
              }
              break;
            }
        } while (f < i && a < r);
      f -= q = x >> 3, v &= (1 << (x -= q << 3)) - 1, l.next_in = f, l.next_out = a, l.avail_in = f < i ? i - f + 5 : 5 - (f - i), l.avail_out = a < r ? r - a + 257 : 257 - (a - r), e.hold = v, e.bits = x;
    };
  }, 5020: (d, l, s) => {
    var e = s(9761), f = s(5562), i = s(4299), a = s(4980), t = s(881), r = 1, o = 2, n = 0, u = -2, p = 1, g = 12, v = 30, x = 852, b = 592;
    function w(j) {
      return (j >>> 24 & 255) + (j >>> 8 & 65280) + ((65280 & j) << 8) + ((255 & j) << 24);
    }
    function M() {
      this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new e.Buf16(320), this.work = new e.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
    }
    function G(j) {
      var U;
      return j && j.state ? (U = j.state, j.total_in = j.total_out = U.total = 0, j.msg = "", U.wrap && (j.adler = 1 & U.wrap), U.mode = p, U.last = 0, U.havedict = 0, U.dmax = 32768, U.head = null, U.hold = 0, U.bits = 0, U.lencode = U.lendyn = new e.Buf32(x), U.distcode = U.distdyn = new e.Buf32(b), U.sane = 1, U.back = -1, n) : u;
    }
    function F(j) {
      var U;
      return j && j.state ? ((U = j.state).wsize = 0, U.whave = 0, U.wnext = 0, G(j)) : u;
    }
    function V(j, U) {
      var C, ae;
      return j && j.state ? (ae = j.state, U < 0 ? (C = 0, U = -U) : (C = 1 + (U >> 4), U < 48 && (U &= 15)), U && (U < 8 || U > 15) ? u : (ae.window !== null && ae.wbits !== U && (ae.window = null), ae.wrap = C, ae.wbits = U, F(j))) : u;
    }
    function q(j, U) {
      var C, ae;
      return j ? (ae = new M(), j.state = ae, ae.window = null, (C = V(j, U)) !== n && (j.state = null), C) : u;
    }
    var I, _, R = !0;
    function W(j) {
      if (R) {
        var U;
        for (I = new e.Buf32(512), _ = new e.Buf32(32), U = 0; U < 144; )
          j.lens[U++] = 8;
        for (; U < 256; )
          j.lens[U++] = 9;
        for (; U < 280; )
          j.lens[U++] = 7;
        for (; U < 288; )
          j.lens[U++] = 8;
        for (t(r, j.lens, 0, 288, I, 0, j.work, { bits: 9 }), U = 0; U < 32; )
          j.lens[U++] = 5;
        t(o, j.lens, 0, 32, _, 0, j.work, { bits: 5 }), R = !1;
      }
      j.lencode = I, j.lenbits = 9, j.distcode = _, j.distbits = 5;
    }
    function O(j, U, C, ae) {
      var J, te = j.state;
      return te.window === null && (te.wsize = 1 << te.wbits, te.wnext = 0, te.whave = 0, te.window = new e.Buf8(te.wsize)), ae >= te.wsize ? (e.arraySet(te.window, U, C - te.wsize, te.wsize, 0), te.wnext = 0, te.whave = te.wsize) : ((J = te.wsize - te.wnext) > ae && (J = ae), e.arraySet(te.window, U, C - ae, J, te.wnext), (ae -= J) ? (e.arraySet(te.window, U, C - ae, ae, 0), te.wnext = ae, te.whave = te.wsize) : (te.wnext += J, te.wnext === te.wsize && (te.wnext = 0), te.whave < te.wsize && (te.whave += J))), 0;
    }
    l.inflateReset = F, l.inflateReset2 = V, l.inflateResetKeep = G, l.inflateInit = function(j) {
      return q(j, 15);
    }, l.inflateInit2 = q, l.inflate = function(j, U) {
      var C, ae, J, te, $, L, re, z, N, ne, le, he, k, T, B, K, h, c, m, D, ee, E, Q, se, Y = 0, be = new e.Buf8(4), Ee = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
      if (!j || !j.state || !j.output || !j.input && j.avail_in !== 0)
        return u;
      (C = j.state).mode === g && (C.mode = 13), $ = j.next_out, J = j.output, re = j.avail_out, te = j.next_in, ae = j.input, L = j.avail_in, z = C.hold, N = C.bits, ne = L, le = re, E = n;
      e:
        for (; ; )
          switch (C.mode) {
            case p:
              if (C.wrap === 0) {
                C.mode = 13;
                break;
              }
              for (; N < 16; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              if (2 & C.wrap && z === 35615) {
                C.check = 0, be[0] = 255 & z, be[1] = z >>> 8 & 255, C.check = i(C.check, be, 2, 0), z = 0, N = 0, C.mode = 2;
                break;
              }
              if (C.flags = 0, C.head && (C.head.done = !1), !(1 & C.wrap) || (((255 & z) << 8) + (z >> 8)) % 31) {
                j.msg = "incorrect header check", C.mode = v;
                break;
              }
              if ((15 & z) != 8) {
                j.msg = "unknown compression method", C.mode = v;
                break;
              }
              if (N -= 4, ee = 8 + (15 & (z >>>= 4)), C.wbits === 0)
                C.wbits = ee;
              else if (ee > C.wbits) {
                j.msg = "invalid window size", C.mode = v;
                break;
              }
              C.dmax = 1 << ee, j.adler = C.check = 1, C.mode = 512 & z ? 10 : g, z = 0, N = 0;
              break;
            case 2:
              for (; N < 16; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              if (C.flags = z, (255 & C.flags) != 8) {
                j.msg = "unknown compression method", C.mode = v;
                break;
              }
              if (57344 & C.flags) {
                j.msg = "unknown header flags set", C.mode = v;
                break;
              }
              C.head && (C.head.text = z >> 8 & 1), 512 & C.flags && (be[0] = 255 & z, be[1] = z >>> 8 & 255, C.check = i(C.check, be, 2, 0)), z = 0, N = 0, C.mode = 3;
            case 3:
              for (; N < 32; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              C.head && (C.head.time = z), 512 & C.flags && (be[0] = 255 & z, be[1] = z >>> 8 & 255, be[2] = z >>> 16 & 255, be[3] = z >>> 24 & 255, C.check = i(C.check, be, 4, 0)), z = 0, N = 0, C.mode = 4;
            case 4:
              for (; N < 16; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              C.head && (C.head.xflags = 255 & z, C.head.os = z >> 8), 512 & C.flags && (be[0] = 255 & z, be[1] = z >>> 8 & 255, C.check = i(C.check, be, 2, 0)), z = 0, N = 0, C.mode = 5;
            case 5:
              if (1024 & C.flags) {
                for (; N < 16; ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                C.length = z, C.head && (C.head.extra_len = z), 512 & C.flags && (be[0] = 255 & z, be[1] = z >>> 8 & 255, C.check = i(C.check, be, 2, 0)), z = 0, N = 0;
              } else
                C.head && (C.head.extra = null);
              C.mode = 6;
            case 6:
              if (1024 & C.flags && ((he = C.length) > L && (he = L), he && (C.head && (ee = C.head.extra_len - C.length, C.head.extra || (C.head.extra = new Array(C.head.extra_len)), e.arraySet(C.head.extra, ae, te, he, ee)), 512 & C.flags && (C.check = i(C.check, ae, he, te)), L -= he, te += he, C.length -= he), C.length))
                break e;
              C.length = 0, C.mode = 7;
            case 7:
              if (2048 & C.flags) {
                if (L === 0)
                  break e;
                he = 0;
                do
                  ee = ae[te + he++], C.head && ee && C.length < 65536 && (C.head.name += String.fromCharCode(ee));
                while (ee && he < L);
                if (512 & C.flags && (C.check = i(C.check, ae, he, te)), L -= he, te += he, ee)
                  break e;
              } else
                C.head && (C.head.name = null);
              C.length = 0, C.mode = 8;
            case 8:
              if (4096 & C.flags) {
                if (L === 0)
                  break e;
                he = 0;
                do
                  ee = ae[te + he++], C.head && ee && C.length < 65536 && (C.head.comment += String.fromCharCode(ee));
                while (ee && he < L);
                if (512 & C.flags && (C.check = i(C.check, ae, he, te)), L -= he, te += he, ee)
                  break e;
              } else
                C.head && (C.head.comment = null);
              C.mode = 9;
            case 9:
              if (512 & C.flags) {
                for (; N < 16; ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                if (z !== (65535 & C.check)) {
                  j.msg = "header crc mismatch", C.mode = v;
                  break;
                }
                z = 0, N = 0;
              }
              C.head && (C.head.hcrc = C.flags >> 9 & 1, C.head.done = !0), j.adler = C.check = 0, C.mode = g;
              break;
            case 10:
              for (; N < 32; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              j.adler = C.check = w(z), z = 0, N = 0, C.mode = 11;
            case 11:
              if (C.havedict === 0)
                return j.next_out = $, j.avail_out = re, j.next_in = te, j.avail_in = L, C.hold = z, C.bits = N, 2;
              j.adler = C.check = 1, C.mode = g;
            case g:
              if (U === 5 || U === 6)
                break e;
            case 13:
              if (C.last) {
                z >>>= 7 & N, N -= 7 & N, C.mode = 27;
                break;
              }
              for (; N < 3; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              switch (C.last = 1 & z, N -= 1, 3 & (z >>>= 1)) {
                case 0:
                  C.mode = 14;
                  break;
                case 1:
                  if (W(C), C.mode = 20, U === 6) {
                    z >>>= 2, N -= 2;
                    break e;
                  }
                  break;
                case 2:
                  C.mode = 17;
                  break;
                case 3:
                  j.msg = "invalid block type", C.mode = v;
              }
              z >>>= 2, N -= 2;
              break;
            case 14:
              for (z >>>= 7 & N, N -= 7 & N; N < 32; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              if ((65535 & z) != (z >>> 16 ^ 65535)) {
                j.msg = "invalid stored block lengths", C.mode = v;
                break;
              }
              if (C.length = 65535 & z, z = 0, N = 0, C.mode = 15, U === 6)
                break e;
            case 15:
              C.mode = 16;
            case 16:
              if (he = C.length) {
                if (he > L && (he = L), he > re && (he = re), he === 0)
                  break e;
                e.arraySet(J, ae, te, he, $), L -= he, te += he, re -= he, $ += he, C.length -= he;
                break;
              }
              C.mode = g;
              break;
            case 17:
              for (; N < 14; ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              if (C.nlen = 257 + (31 & z), z >>>= 5, N -= 5, C.ndist = 1 + (31 & z), z >>>= 5, N -= 5, C.ncode = 4 + (15 & z), z >>>= 4, N -= 4, C.nlen > 286 || C.ndist > 30) {
                j.msg = "too many length or distance symbols", C.mode = v;
                break;
              }
              C.have = 0, C.mode = 18;
            case 18:
              for (; C.have < C.ncode; ) {
                for (; N < 3; ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                C.lens[Ee[C.have++]] = 7 & z, z >>>= 3, N -= 3;
              }
              for (; C.have < 19; )
                C.lens[Ee[C.have++]] = 0;
              if (C.lencode = C.lendyn, C.lenbits = 7, Q = { bits: C.lenbits }, E = t(0, C.lens, 0, 19, C.lencode, 0, C.work, Q), C.lenbits = Q.bits, E) {
                j.msg = "invalid code lengths set", C.mode = v;
                break;
              }
              C.have = 0, C.mode = 19;
            case 19:
              for (; C.have < C.nlen + C.ndist; ) {
                for (; K = (Y = C.lencode[z & (1 << C.lenbits) - 1]) >>> 16 & 255, h = 65535 & Y, !((B = Y >>> 24) <= N); ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                if (h < 16)
                  z >>>= B, N -= B, C.lens[C.have++] = h;
                else {
                  if (h === 16) {
                    for (se = B + 2; N < se; ) {
                      if (L === 0)
                        break e;
                      L--, z += ae[te++] << N, N += 8;
                    }
                    if (z >>>= B, N -= B, C.have === 0) {
                      j.msg = "invalid bit length repeat", C.mode = v;
                      break;
                    }
                    ee = C.lens[C.have - 1], he = 3 + (3 & z), z >>>= 2, N -= 2;
                  } else if (h === 17) {
                    for (se = B + 3; N < se; ) {
                      if (L === 0)
                        break e;
                      L--, z += ae[te++] << N, N += 8;
                    }
                    N -= B, ee = 0, he = 3 + (7 & (z >>>= B)), z >>>= 3, N -= 3;
                  } else {
                    for (se = B + 7; N < se; ) {
                      if (L === 0)
                        break e;
                      L--, z += ae[te++] << N, N += 8;
                    }
                    N -= B, ee = 0, he = 11 + (127 & (z >>>= B)), z >>>= 7, N -= 7;
                  }
                  if (C.have + he > C.nlen + C.ndist) {
                    j.msg = "invalid bit length repeat", C.mode = v;
                    break;
                  }
                  for (; he--; )
                    C.lens[C.have++] = ee;
                }
              }
              if (C.mode === v)
                break;
              if (C.lens[256] === 0) {
                j.msg = "invalid code -- missing end-of-block", C.mode = v;
                break;
              }
              if (C.lenbits = 9, Q = { bits: C.lenbits }, E = t(r, C.lens, 0, C.nlen, C.lencode, 0, C.work, Q), C.lenbits = Q.bits, E) {
                j.msg = "invalid literal/lengths set", C.mode = v;
                break;
              }
              if (C.distbits = 6, C.distcode = C.distdyn, Q = { bits: C.distbits }, E = t(o, C.lens, C.nlen, C.ndist, C.distcode, 0, C.work, Q), C.distbits = Q.bits, E) {
                j.msg = "invalid distances set", C.mode = v;
                break;
              }
              if (C.mode = 20, U === 6)
                break e;
            case 20:
              C.mode = 21;
            case 21:
              if (L >= 6 && re >= 258) {
                j.next_out = $, j.avail_out = re, j.next_in = te, j.avail_in = L, C.hold = z, C.bits = N, a(j, le), $ = j.next_out, J = j.output, re = j.avail_out, te = j.next_in, ae = j.input, L = j.avail_in, z = C.hold, N = C.bits, C.mode === g && (C.back = -1);
                break;
              }
              for (C.back = 0; K = (Y = C.lencode[z & (1 << C.lenbits) - 1]) >>> 16 & 255, h = 65535 & Y, !((B = Y >>> 24) <= N); ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              if (K && !(240 & K)) {
                for (c = B, m = K, D = h; K = (Y = C.lencode[D + ((z & (1 << c + m) - 1) >> c)]) >>> 16 & 255, h = 65535 & Y, !(c + (B = Y >>> 24) <= N); ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                z >>>= c, N -= c, C.back += c;
              }
              if (z >>>= B, N -= B, C.back += B, C.length = h, K === 0) {
                C.mode = 26;
                break;
              }
              if (32 & K) {
                C.back = -1, C.mode = g;
                break;
              }
              if (64 & K) {
                j.msg = "invalid literal/length code", C.mode = v;
                break;
              }
              C.extra = 15 & K, C.mode = 22;
            case 22:
              if (C.extra) {
                for (se = C.extra; N < se; ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                C.length += z & (1 << C.extra) - 1, z >>>= C.extra, N -= C.extra, C.back += C.extra;
              }
              C.was = C.length, C.mode = 23;
            case 23:
              for (; K = (Y = C.distcode[z & (1 << C.distbits) - 1]) >>> 16 & 255, h = 65535 & Y, !((B = Y >>> 24) <= N); ) {
                if (L === 0)
                  break e;
                L--, z += ae[te++] << N, N += 8;
              }
              if (!(240 & K)) {
                for (c = B, m = K, D = h; K = (Y = C.distcode[D + ((z & (1 << c + m) - 1) >> c)]) >>> 16 & 255, h = 65535 & Y, !(c + (B = Y >>> 24) <= N); ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                z >>>= c, N -= c, C.back += c;
              }
              if (z >>>= B, N -= B, C.back += B, 64 & K) {
                j.msg = "invalid distance code", C.mode = v;
                break;
              }
              C.offset = h, C.extra = 15 & K, C.mode = 24;
            case 24:
              if (C.extra) {
                for (se = C.extra; N < se; ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                C.offset += z & (1 << C.extra) - 1, z >>>= C.extra, N -= C.extra, C.back += C.extra;
              }
              if (C.offset > C.dmax) {
                j.msg = "invalid distance too far back", C.mode = v;
                break;
              }
              C.mode = 25;
            case 25:
              if (re === 0)
                break e;
              if (he = le - re, C.offset > he) {
                if ((he = C.offset - he) > C.whave && C.sane) {
                  j.msg = "invalid distance too far back", C.mode = v;
                  break;
                }
                he > C.wnext ? (he -= C.wnext, k = C.wsize - he) : k = C.wnext - he, he > C.length && (he = C.length), T = C.window;
              } else
                T = J, k = $ - C.offset, he = C.length;
              he > re && (he = re), re -= he, C.length -= he;
              do
                J[$++] = T[k++];
              while (--he);
              C.length === 0 && (C.mode = 21);
              break;
            case 26:
              if (re === 0)
                break e;
              J[$++] = C.length, re--, C.mode = 21;
              break;
            case 27:
              if (C.wrap) {
                for (; N < 32; ) {
                  if (L === 0)
                    break e;
                  L--, z |= ae[te++] << N, N += 8;
                }
                if (le -= re, j.total_out += le, C.total += le, le && (j.adler = C.check = C.flags ? i(C.check, J, le, $ - le) : f(C.check, J, le, $ - le)), le = re, (C.flags ? z : w(z)) !== C.check) {
                  j.msg = "incorrect data check", C.mode = v;
                  break;
                }
                z = 0, N = 0;
              }
              C.mode = 28;
            case 28:
              if (C.wrap && C.flags) {
                for (; N < 32; ) {
                  if (L === 0)
                    break e;
                  L--, z += ae[te++] << N, N += 8;
                }
                if (z !== (4294967295 & C.total)) {
                  j.msg = "incorrect length check", C.mode = v;
                  break;
                }
                z = 0, N = 0;
              }
              C.mode = 29;
            case 29:
              E = 1;
              break e;
            case v:
              E = -3;
              break e;
            case 31:
              return -4;
            default:
              return u;
          }
      return j.next_out = $, j.avail_out = re, j.next_in = te, j.avail_in = L, C.hold = z, C.bits = N, (C.wsize || le !== j.avail_out && C.mode < v && (C.mode < 27 || U !== 4)) && O(j, j.output, j.next_out, le - j.avail_out) ? (C.mode = 31, -4) : (ne -= j.avail_in, le -= j.avail_out, j.total_in += ne, j.total_out += le, C.total += le, C.wrap && le && (j.adler = C.check = C.flags ? i(C.check, J, le, j.next_out - le) : f(C.check, J, le, j.next_out - le)), j.data_type = C.bits + (C.last ? 64 : 0) + (C.mode === g ? 128 : 0) + (C.mode === 20 || C.mode === 15 ? 256 : 0), (ne === 0 && le === 0 || U === 4) && E === n && (E = -5), E);
    }, l.inflateEnd = function(j) {
      if (!j || !j.state)
        return u;
      var U = j.state;
      return U.window && (U.window = null), j.state = null, n;
    }, l.inflateGetHeader = function(j, U) {
      var C;
      return j && j.state && 2 & (C = j.state).wrap ? (C.head = U, U.done = !1, n) : u;
    }, l.inflateSetDictionary = function(j, U) {
      var C, ae = U.length;
      return j && j.state ? (C = j.state).wrap !== 0 && C.mode !== 11 ? u : C.mode === 11 && f(1, U, ae, 0) !== C.check ? -3 : O(j, U, ae, ae) ? (C.mode = 31, -4) : (C.havedict = 1, n) : u;
    }, l.inflateInfo = "pako inflate (from Nodeca project)";
  }, 881: (d, l, s) => {
    var e = s(9761), f = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], i = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], a = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], t = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
    d.exports = function(r, o, n, u, p, g, v, x) {
      var b, w, M, G, F, V, q, I, _, R = x.bits, W = 0, O = 0, j = 0, U = 0, C = 0, ae = 0, J = 0, te = 0, $ = 0, L = 0, re = null, z = 0, N = new e.Buf16(16), ne = new e.Buf16(16), le = null, he = 0;
      for (W = 0; W <= 15; W++)
        N[W] = 0;
      for (O = 0; O < u; O++)
        N[o[n + O]]++;
      for (C = R, U = 15; U >= 1 && N[U] === 0; U--)
        ;
      if (C > U && (C = U), U === 0)
        return p[g++] = 20971520, p[g++] = 20971520, x.bits = 1, 0;
      for (j = 1; j < U && N[j] === 0; j++)
        ;
      for (C < j && (C = j), te = 1, W = 1; W <= 15; W++)
        if (te <<= 1, (te -= N[W]) < 0)
          return -1;
      if (te > 0 && (r === 0 || U !== 1))
        return -1;
      for (ne[1] = 0, W = 1; W < 15; W++)
        ne[W + 1] = ne[W] + N[W];
      for (O = 0; O < u; O++)
        o[n + O] !== 0 && (v[ne[o[n + O]]++] = O);
      if (r === 0 ? (re = le = v, V = 19) : r === 1 ? (re = f, z -= 257, le = i, he -= 257, V = 256) : (re = a, le = t, V = -1), L = 0, O = 0, W = j, F = g, ae = C, J = 0, M = -1, G = ($ = 1 << C) - 1, r === 1 && $ > 852 || r === 2 && $ > 592)
        return 1;
      for (; ; ) {
        q = W - J, v[O] < V ? (I = 0, _ = v[O]) : v[O] > V ? (I = le[he + v[O]], _ = re[z + v[O]]) : (I = 96, _ = 0), b = 1 << W - J, j = w = 1 << ae;
        do
          p[F + (L >> J) + (w -= b)] = q << 24 | I << 16 | _ | 0;
        while (w !== 0);
        for (b = 1 << W - 1; L & b; )
          b >>= 1;
        if (b !== 0 ? (L &= b - 1, L += b) : L = 0, O++, --N[W] == 0) {
          if (W === U)
            break;
          W = o[n + v[O]];
        }
        if (W > C && (L & G) !== M) {
          for (J === 0 && (J = C), F += j, te = 1 << (ae = W - J); ae + J < U && !((te -= N[ae + J]) <= 0); )
            ae++, te <<= 1;
          if ($ += 1 << ae, r === 1 && $ > 852 || r === 2 && $ > 592)
            return 1;
          p[M = L & G] = C << 24 | ae << 16 | F - g | 0;
        }
      }
      return L !== 0 && (p[F + L] = W - J << 24 | 4194304 | 0), x.bits = C, 0;
    };
  }, 2950: (d) => {
    d.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
  }, 9564: (d, l, s) => {
    var e = s(9761);
    function f(m) {
      for (var D = m.length; --D >= 0; )
        m[D] = 0;
    }
    var i = 0, a = 256, t = a + 1 + 29, r = 30, o = 19, n = 2 * t + 1, u = 15, p = 16, g = 256, v = 16, x = 17, b = 18, w = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], M = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], G = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], F = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], V = new Array(2 * (t + 2));
    f(V);
    var q = new Array(2 * r);
    f(q);
    var I = new Array(512);
    f(I);
    var _ = new Array(256);
    f(_);
    var R = new Array(29);
    f(R);
    var W, O, j, U = new Array(r);
    function C(m, D, ee, E, Q) {
      this.static_tree = m, this.extra_bits = D, this.extra_base = ee, this.elems = E, this.max_length = Q, this.has_stree = m && m.length;
    }
    function ae(m, D) {
      this.dyn_tree = m, this.max_code = 0, this.stat_desc = D;
    }
    function J(m) {
      return m < 256 ? I[m] : I[256 + (m >>> 7)];
    }
    function te(m, D) {
      m.pending_buf[m.pending++] = 255 & D, m.pending_buf[m.pending++] = D >>> 8 & 255;
    }
    function $(m, D, ee) {
      m.bi_valid > p - ee ? (m.bi_buf |= D << m.bi_valid & 65535, te(m, m.bi_buf), m.bi_buf = D >> p - m.bi_valid, m.bi_valid += ee - p) : (m.bi_buf |= D << m.bi_valid & 65535, m.bi_valid += ee);
    }
    function L(m, D, ee) {
      $(m, ee[2 * D], ee[2 * D + 1]);
    }
    function re(m, D) {
      var ee = 0;
      do
        ee |= 1 & m, m >>>= 1, ee <<= 1;
      while (--D > 0);
      return ee >>> 1;
    }
    function z(m, D, ee) {
      var E, Q, se = new Array(u + 1), Y = 0;
      for (E = 1; E <= u; E++)
        se[E] = Y = Y + ee[E - 1] << 1;
      for (Q = 0; Q <= D; Q++) {
        var be = m[2 * Q + 1];
        be !== 0 && (m[2 * Q] = re(se[be]++, be));
      }
    }
    function N(m) {
      var D;
      for (D = 0; D < t; D++)
        m.dyn_ltree[2 * D] = 0;
      for (D = 0; D < r; D++)
        m.dyn_dtree[2 * D] = 0;
      for (D = 0; D < o; D++)
        m.bl_tree[2 * D] = 0;
      m.dyn_ltree[2 * g] = 1, m.opt_len = m.static_len = 0, m.last_lit = m.matches = 0;
    }
    function ne(m) {
      m.bi_valid > 8 ? te(m, m.bi_buf) : m.bi_valid > 0 && (m.pending_buf[m.pending++] = m.bi_buf), m.bi_buf = 0, m.bi_valid = 0;
    }
    function le(m, D, ee, E) {
      var Q = 2 * D, se = 2 * ee;
      return m[Q] < m[se] || m[Q] === m[se] && E[D] <= E[ee];
    }
    function he(m, D, ee) {
      for (var E = m.heap[ee], Q = ee << 1; Q <= m.heap_len && (Q < m.heap_len && le(D, m.heap[Q + 1], m.heap[Q], m.depth) && Q++, !le(D, E, m.heap[Q], m.depth)); )
        m.heap[ee] = m.heap[Q], ee = Q, Q <<= 1;
      m.heap[ee] = E;
    }
    function k(m, D, ee) {
      var E, Q, se, Y, be = 0;
      if (m.last_lit !== 0)
        do
          E = m.pending_buf[m.d_buf + 2 * be] << 8 | m.pending_buf[m.d_buf + 2 * be + 1], Q = m.pending_buf[m.l_buf + be], be++, E === 0 ? L(m, Q, D) : (L(m, (se = _[Q]) + a + 1, D), (Y = w[se]) !== 0 && $(m, Q -= R[se], Y), L(m, se = J(--E), ee), (Y = M[se]) !== 0 && $(m, E -= U[se], Y));
        while (be < m.last_lit);
      L(m, g, D);
    }
    function T(m, D) {
      var ee, E, Q, se = D.dyn_tree, Y = D.stat_desc.static_tree, be = D.stat_desc.has_stree, Ee = D.stat_desc.elems, Me = -1;
      for (m.heap_len = 0, m.heap_max = n, ee = 0; ee < Ee; ee++)
        se[2 * ee] !== 0 ? (m.heap[++m.heap_len] = Me = ee, m.depth[ee] = 0) : se[2 * ee + 1] = 0;
      for (; m.heap_len < 2; )
        se[2 * (Q = m.heap[++m.heap_len] = Me < 2 ? ++Me : 0)] = 1, m.depth[Q] = 0, m.opt_len--, be && (m.static_len -= Y[2 * Q + 1]);
      for (D.max_code = Me, ee = m.heap_len >> 1; ee >= 1; ee--)
        he(m, se, ee);
      Q = Ee;
      do
        ee = m.heap[1], m.heap[1] = m.heap[m.heap_len--], he(m, se, 1), E = m.heap[1], m.heap[--m.heap_max] = ee, m.heap[--m.heap_max] = E, se[2 * Q] = se[2 * ee] + se[2 * E], m.depth[Q] = (m.depth[ee] >= m.depth[E] ? m.depth[ee] : m.depth[E]) + 1, se[2 * ee + 1] = se[2 * E + 1] = Q, m.heap[1] = Q++, he(m, se, 1);
      while (m.heap_len >= 2);
      m.heap[--m.heap_max] = m.heap[1], function(ke, oe) {
        var ce, xe, Ce, _e, Be, Pe, Fe = oe.dyn_tree, We = oe.max_code, Qe = oe.stat_desc.static_tree, lt = oe.stat_desc.has_stree, P = oe.stat_desc.extra_bits, we = oe.stat_desc.extra_base, X = oe.stat_desc.max_length, de = 0;
        for (_e = 0; _e <= u; _e++)
          ke.bl_count[_e] = 0;
        for (Fe[2 * ke.heap[ke.heap_max] + 1] = 0, ce = ke.heap_max + 1; ce < n; ce++)
          (_e = Fe[2 * Fe[2 * (xe = ke.heap[ce]) + 1] + 1] + 1) > X && (_e = X, de++), Fe[2 * xe + 1] = _e, xe > We || (ke.bl_count[_e]++, Be = 0, xe >= we && (Be = P[xe - we]), Pe = Fe[2 * xe], ke.opt_len += Pe * (_e + Be), lt && (ke.static_len += Pe * (Qe[2 * xe + 1] + Be)));
        if (de !== 0) {
          do {
            for (_e = X - 1; ke.bl_count[_e] === 0; )
              _e--;
            ke.bl_count[_e]--, ke.bl_count[_e + 1] += 2, ke.bl_count[X]--, de -= 2;
          } while (de > 0);
          for (_e = X; _e !== 0; _e--)
            for (xe = ke.bl_count[_e]; xe !== 0; )
              (Ce = ke.heap[--ce]) > We || (Fe[2 * Ce + 1] !== _e && (ke.opt_len += (_e - Fe[2 * Ce + 1]) * Fe[2 * Ce], Fe[2 * Ce + 1] = _e), xe--);
        }
      }(m, D), z(se, Me, m.bl_count);
    }
    function B(m, D, ee) {
      var E, Q, se = -1, Y = D[1], be = 0, Ee = 7, Me = 4;
      for (Y === 0 && (Ee = 138, Me = 3), D[2 * (ee + 1) + 1] = 65535, E = 0; E <= ee; E++)
        Q = Y, Y = D[2 * (E + 1) + 1], ++be < Ee && Q === Y || (be < Me ? m.bl_tree[2 * Q] += be : Q !== 0 ? (Q !== se && m.bl_tree[2 * Q]++, m.bl_tree[2 * v]++) : be <= 10 ? m.bl_tree[2 * x]++ : m.bl_tree[2 * b]++, be = 0, se = Q, Y === 0 ? (Ee = 138, Me = 3) : Q === Y ? (Ee = 6, Me = 3) : (Ee = 7, Me = 4));
    }
    function K(m, D, ee) {
      var E, Q, se = -1, Y = D[1], be = 0, Ee = 7, Me = 4;
      for (Y === 0 && (Ee = 138, Me = 3), E = 0; E <= ee; E++)
        if (Q = Y, Y = D[2 * (E + 1) + 1], !(++be < Ee && Q === Y)) {
          if (be < Me)
            do
              L(m, Q, m.bl_tree);
            while (--be != 0);
          else
            Q !== 0 ? (Q !== se && (L(m, Q, m.bl_tree), be--), L(m, v, m.bl_tree), $(m, be - 3, 2)) : be <= 10 ? (L(m, x, m.bl_tree), $(m, be - 3, 3)) : (L(m, b, m.bl_tree), $(m, be - 11, 7));
          be = 0, se = Q, Y === 0 ? (Ee = 138, Me = 3) : Q === Y ? (Ee = 6, Me = 3) : (Ee = 7, Me = 4);
        }
    }
    f(U);
    var h = !1;
    function c(m, D, ee, E) {
      $(m, (i << 1) + (E ? 1 : 0), 3), function(Q, se, Y, be) {
        ne(Q), te(Q, Y), te(Q, ~Y), e.arraySet(Q.pending_buf, Q.window, se, Y, Q.pending), Q.pending += Y;
      }(m, D, ee);
    }
    l._tr_init = function(m) {
      h || (function() {
        var D, ee, E, Q, se, Y = new Array(u + 1);
        for (E = 0, Q = 0; Q < 28; Q++)
          for (R[Q] = E, D = 0; D < 1 << w[Q]; D++)
            _[E++] = Q;
        for (_[E - 1] = Q, se = 0, Q = 0; Q < 16; Q++)
          for (U[Q] = se, D = 0; D < 1 << M[Q]; D++)
            I[se++] = Q;
        for (se >>= 7; Q < r; Q++)
          for (U[Q] = se << 7, D = 0; D < 1 << M[Q] - 7; D++)
            I[256 + se++] = Q;
        for (ee = 0; ee <= u; ee++)
          Y[ee] = 0;
        for (D = 0; D <= 143; )
          V[2 * D + 1] = 8, D++, Y[8]++;
        for (; D <= 255; )
          V[2 * D + 1] = 9, D++, Y[9]++;
        for (; D <= 279; )
          V[2 * D + 1] = 7, D++, Y[7]++;
        for (; D <= 287; )
          V[2 * D + 1] = 8, D++, Y[8]++;
        for (z(V, t + 1, Y), D = 0; D < r; D++)
          q[2 * D + 1] = 5, q[2 * D] = re(D, 5);
        W = new C(V, w, a + 1, t, u), O = new C(q, M, 0, r, u), j = new C(new Array(0), G, 0, o, 7);
      }(), h = !0), m.l_desc = new ae(m.dyn_ltree, W), m.d_desc = new ae(m.dyn_dtree, O), m.bl_desc = new ae(m.bl_tree, j), m.bi_buf = 0, m.bi_valid = 0, N(m);
    }, l._tr_stored_block = c, l._tr_flush_block = function(m, D, ee, E) {
      var Q, se, Y = 0;
      m.level > 0 ? (m.strm.data_type === 2 && (m.strm.data_type = function(be) {
        var Ee, Me = 4093624447;
        for (Ee = 0; Ee <= 31; Ee++, Me >>>= 1)
          if (1 & Me && be.dyn_ltree[2 * Ee] !== 0)
            return 0;
        if (be.dyn_ltree[18] !== 0 || be.dyn_ltree[20] !== 0 || be.dyn_ltree[26] !== 0)
          return 1;
        for (Ee = 32; Ee < a; Ee++)
          if (be.dyn_ltree[2 * Ee] !== 0)
            return 1;
        return 0;
      }(m)), T(m, m.l_desc), T(m, m.d_desc), Y = function(be) {
        var Ee;
        for (B(be, be.dyn_ltree, be.l_desc.max_code), B(be, be.dyn_dtree, be.d_desc.max_code), T(be, be.bl_desc), Ee = o - 1; Ee >= 3 && be.bl_tree[2 * F[Ee] + 1] === 0; Ee--)
          ;
        return be.opt_len += 3 * (Ee + 1) + 5 + 5 + 4, Ee;
      }(m), Q = m.opt_len + 3 + 7 >>> 3, (se = m.static_len + 3 + 7 >>> 3) <= Q && (Q = se)) : Q = se = ee + 5, ee + 4 <= Q && D !== -1 ? c(m, D, ee, E) : m.strategy === 4 || se === Q ? ($(m, 2 + (E ? 1 : 0), 3), k(m, V, q)) : ($(m, 4 + (E ? 1 : 0), 3), function(be, Ee, Me, ke) {
        var oe;
        for ($(be, Ee - 257, 5), $(be, Me - 1, 5), $(be, ke - 4, 4), oe = 0; oe < ke; oe++)
          $(be, be.bl_tree[2 * F[oe] + 1], 3);
        K(be, be.dyn_ltree, Ee - 1), K(be, be.dyn_dtree, Me - 1);
      }(m, m.l_desc.max_code + 1, m.d_desc.max_code + 1, Y + 1), k(m, m.dyn_ltree, m.dyn_dtree)), N(m), E && ne(m);
    }, l._tr_tally = function(m, D, ee) {
      return m.pending_buf[m.d_buf + 2 * m.last_lit] = D >>> 8 & 255, m.pending_buf[m.d_buf + 2 * m.last_lit + 1] = 255 & D, m.pending_buf[m.l_buf + m.last_lit] = 255 & ee, m.last_lit++, D === 0 ? m.dyn_ltree[2 * ee]++ : (m.matches++, D--, m.dyn_ltree[2 * (_[ee] + a + 1)]++, m.dyn_dtree[2 * J(D)]++), m.last_lit === m.lit_bufsize - 1;
    }, l._tr_align = function(m) {
      $(m, 2, 3), L(m, g, V), function(D) {
        D.bi_valid === 16 ? (te(D, D.bi_buf), D.bi_buf = 0, D.bi_valid = 0) : D.bi_valid >= 8 && (D.pending_buf[D.pending++] = 255 & D.bi_buf, D.bi_buf >>= 8, D.bi_valid -= 8);
      }(m);
    };
  }, 744: (d) => {
    d.exports = function() {
      this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
    };
  }, 4398: (d) => {
    function l(e, f) {
      if (!(e = e.replace(/\t+/g, " ").trim()))
        return null;
      var i = e.indexOf(" ");
      if (i === -1)
        throw new Error("no named row at line " + f);
      var a = e.substring(0, i);
      e = (e = (e = (e = e.substring(i + 1)).replace(/letter=[\'\"]\S+[\'\"]/gi, "")).split("=")).map(function(u) {
        return u.trim().match(/(".*?"|[^"\s]+)+(?=\s*|\s*$)/g);
      });
      for (var t = [], r = 0; r < e.length; r++) {
        var o = e[r];
        r === 0 ? t.push({ key: o[0], data: "" }) : r === e.length - 1 ? t[t.length - 1].data = s(o[0]) : (t[t.length - 1].data = s(o[0]), t.push({ key: o[1], data: "" }));
      }
      var n = { key: a, data: {} };
      return t.forEach(function(u) {
        n.data[u.key] = u.data;
      }), n;
    }
    function s(e) {
      return e && e.length !== 0 ? e.indexOf('"') === 0 || e.indexOf("'") === 0 ? e.substring(1, e.length - 1) : e.indexOf(",") !== -1 ? function(f) {
        return f.split(",").map(function(i) {
          return parseInt(i, 10);
        });
      }(e) : parseInt(e, 10) : "";
    }
    d.exports = function(e) {
      if (!e)
        throw new Error("no data provided");
      var f = { pages: [], chars: [], kernings: [] }, i = (e = e.toString().trim()).split(/\r\n?|\n/g);
      if (i.length === 0)
        throw new Error("no data in BMFont file");
      for (var a = 0; a < i.length; a++) {
        var t = l(i[a], a);
        if (t)
          if (t.key === "page") {
            if (typeof t.data.id != "number")
              throw new Error("malformed file at line " + a + " -- needs page id=N");
            if (typeof t.data.file != "string")
              throw new Error("malformed file at line " + a + ' -- needs page file="path"');
            f.pages[t.data.id] = t.data.file;
          } else
            t.key === "chars" || t.key === "kernings" || (t.key === "char" ? f.chars.push(t.data) : t.key === "kerning" ? f.kernings.push(t.data) : f[t.key] = t.data);
      }
      return f;
    };
  }, 8438: (d) => {
    var l = [66, 77, 70];
    function s(f, i, a) {
      if (a > i.length - 1)
        return 0;
      var t = i.readUInt8(a++), r = i.readInt32LE(a);
      switch (a += 4, t) {
        case 1:
          f.info = function(o, n) {
            var u = {};
            u.size = o.readInt16LE(n);
            var p = o.readUInt8(n + 2);
            return u.smooth = p >> 7 & 1, u.unicode = p >> 6 & 1, u.italic = p >> 5 & 1, u.bold = p >> 4 & 1, p >> 3 & 1 && (u.fixedHeight = 1), u.charset = o.readUInt8(n + 3) || "", u.stretchH = o.readUInt16LE(n + 4), u.aa = o.readUInt8(n + 6), u.padding = [o.readInt8(n + 7), o.readInt8(n + 8), o.readInt8(n + 9), o.readInt8(n + 10)], u.spacing = [o.readInt8(n + 11), o.readInt8(n + 12)], u.outline = o.readUInt8(n + 13), u.face = function(g, v) {
              return e(g, v).toString("utf8");
            }(o, n + 14), u;
          }(i, a);
          break;
        case 2:
          f.common = function(o, n) {
            var u = {};
            return u.lineHeight = o.readUInt16LE(n), u.base = o.readUInt16LE(n + 2), u.scaleW = o.readUInt16LE(n + 4), u.scaleH = o.readUInt16LE(n + 6), u.pages = o.readUInt16LE(n + 8), o.readUInt8(n + 10), u.packed = 0, u.alphaChnl = o.readUInt8(n + 11), u.redChnl = o.readUInt8(n + 12), u.greenChnl = o.readUInt8(n + 13), u.blueChnl = o.readUInt8(n + 14), u;
          }(i, a);
          break;
        case 3:
          f.pages = function(o, n, u) {
            for (var p = [], g = e(o, n), v = g.length + 1, x = u / v, b = 0; b < x; b++)
              p[b] = o.slice(n, n + g.length).toString("utf8"), n += v;
            return p;
          }(i, a, r);
          break;
        case 4:
          f.chars = function(o, n, u) {
            for (var p = [], g = u / 20, v = 0; v < g; v++) {
              var x = {}, b = 20 * v;
              x.id = o.readUInt32LE(n + 0 + b), x.x = o.readUInt16LE(n + 4 + b), x.y = o.readUInt16LE(n + 6 + b), x.width = o.readUInt16LE(n + 8 + b), x.height = o.readUInt16LE(n + 10 + b), x.xoffset = o.readInt16LE(n + 12 + b), x.yoffset = o.readInt16LE(n + 14 + b), x.xadvance = o.readInt16LE(n + 16 + b), x.page = o.readUInt8(n + 18 + b), x.chnl = o.readUInt8(n + 19 + b), p[v] = x;
            }
            return p;
          }(i, a, r);
          break;
        case 5:
          f.kernings = function(o, n, u) {
            for (var p = [], g = u / 10, v = 0; v < g; v++) {
              var x = {}, b = 10 * v;
              x.first = o.readUInt32LE(n + 0 + b), x.second = o.readUInt32LE(n + 4 + b), x.amount = o.readInt16LE(n + 8 + b), p[v] = x;
            }
            return p;
          }(i, a, r);
      }
      return 5 + r;
    }
    function e(f, i) {
      for (var a = i; a < f.length && f[a] !== 0; a++)
        ;
      return f.slice(i, a);
    }
    d.exports = function(f) {
      if (f.length < 6)
        throw new Error("invalid buffer length for BMFont");
      var i = l.every(function(o, n) {
        return f.readUInt8(n) === o;
      });
      if (!i)
        throw new Error("BMFont missing BMF byte header");
      var a = 3;
      if (f.readUInt8(a++) > 3)
        throw new Error("Only supports BMFont Binary v3 (BMFont App v1.10)");
      for (var t = { kernings: [], chars: [] }, r = 0; r < 5; r++)
        a += s(t, f, a);
      return t;
    };
  }, 5947: (d, l, s) => {
    var e = s(403), f = s(1596), i = { scaleh: "scaleH", scalew: "scaleW", stretchh: "stretchH", lineheight: "lineHeight", alphachnl: "alphaChnl", redchnl: "redChnl", greenchnl: "greenChnl", bluechnl: "blueChnl" };
    function a(t) {
      var r = function(o) {
        for (var n = [], u = 0; u < o.attributes.length; u++)
          n.push(o.attributes[u]);
        return n;
      }(t);
      return r.reduce(function(o, n) {
        var u;
        return o[u = n.nodeName, i[u.toLowerCase()] || u] = n.nodeValue, o;
      }, {});
    }
    d.exports = function(t) {
      t = t.toString();
      var r = f(t), o = { pages: [], chars: [], kernings: [] };
      ["info", "common"].forEach(function(b) {
        var w = r.getElementsByTagName(b)[0];
        w && (o[b] = e(a(w)));
      });
      var n = r.getElementsByTagName("pages")[0];
      if (!n)
        throw new Error("malformed file -- no <pages> element");
      for (var u = n.getElementsByTagName("page"), p = 0; p < u.length; p++) {
        var g = u[p], v = parseInt(g.getAttribute("id"), 10), x = g.getAttribute("file");
        if (isNaN(v))
          throw new Error('malformed file -- page "id" attribute is NaN');
        if (!x)
          throw new Error('malformed file -- needs page "file" attribute');
        o.pages[parseInt(v, 10)] = x;
      }
      return ["chars", "kernings"].forEach(function(b) {
        var w = r.getElementsByTagName(b)[0];
        if (w)
          for (var M = b.substring(0, b.length - 1), G = w.getElementsByTagName(M), F = 0; F < G.length; F++) {
            var V = G[F];
            o[b].push(e(a(V)));
          }
      }), o;
    };
  }, 403: (d) => {
    var l = "chasrset";
    d.exports = function(s) {
      for (var e in l in s && (s.charset = s[l], delete s[l]), s)
        e !== "face" && e !== "charset" && (s[e] = e === "padding" || e === "spacing" ? s[e].split(",").map(function(f) {
          return parseInt(f, 10);
        }) : parseInt(s[e], 10));
      return s;
    };
  }, 4655: (d, l, s) => {
    var e = s(311), f = s(3243);
    d.exports = function(i) {
      if (!i)
        return {};
      var a = {};
      return f(e(i).split(`
`), function(t) {
        var r, o = t.indexOf(":"), n = e(t.slice(0, o)).toLowerCase(), u = e(t.slice(o + 1));
        a[n] === void 0 ? a[n] = u : (r = a[n], Object.prototype.toString.call(r) === "[object Array]" ? a[n].push(u) : a[n] = [a[n], u]);
      }), a;
    };
  }, 1023: (d, l, s) => {
    var e = s(4406);
    function f(t) {
      if (typeof t != "string")
        throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
    }
    function i(t, r) {
      for (var o, n = "", u = 0, p = -1, g = 0, v = 0; v <= t.length; ++v) {
        if (v < t.length)
          o = t.charCodeAt(v);
        else {
          if (o === 47)
            break;
          o = 47;
        }
        if (o === 47) {
          if (!(p === v - 1 || g === 1))
            if (p !== v - 1 && g === 2) {
              if (n.length < 2 || u !== 2 || n.charCodeAt(n.length - 1) !== 46 || n.charCodeAt(n.length - 2) !== 46) {
                if (n.length > 2) {
                  var x = n.lastIndexOf("/");
                  if (x !== n.length - 1) {
                    x === -1 ? (n = "", u = 0) : u = (n = n.slice(0, x)).length - 1 - n.lastIndexOf("/"), p = v, g = 0;
                    continue;
                  }
                } else if (n.length === 2 || n.length === 1) {
                  n = "", u = 0, p = v, g = 0;
                  continue;
                }
              }
              r && (n.length > 0 ? n += "/.." : n = "..", u = 2);
            } else
              n.length > 0 ? n += "/" + t.slice(p + 1, v) : n = t.slice(p + 1, v), u = v - p - 1;
          p = v, g = 0;
        } else
          o === 46 && g !== -1 ? ++g : g = -1;
      }
      return n;
    }
    var a = { resolve: function() {
      for (var t, r = "", o = !1, n = arguments.length - 1; n >= -1 && !o; n--) {
        var u;
        n >= 0 ? u = arguments[n] : (t === void 0 && (t = e.cwd()), u = t), f(u), u.length !== 0 && (r = u + "/" + r, o = u.charCodeAt(0) === 47);
      }
      return r = i(r, !o), o ? r.length > 0 ? "/" + r : "/" : r.length > 0 ? r : ".";
    }, normalize: function(t) {
      if (f(t), t.length === 0)
        return ".";
      var r = t.charCodeAt(0) === 47, o = t.charCodeAt(t.length - 1) === 47;
      return (t = i(t, !r)).length !== 0 || r || (t = "."), t.length > 0 && o && (t += "/"), r ? "/" + t : t;
    }, isAbsolute: function(t) {
      return f(t), t.length > 0 && t.charCodeAt(0) === 47;
    }, join: function() {
      if (arguments.length === 0)
        return ".";
      for (var t, r = 0; r < arguments.length; ++r) {
        var o = arguments[r];
        f(o), o.length > 0 && (t === void 0 ? t = o : t += "/" + o);
      }
      return t === void 0 ? "." : a.normalize(t);
    }, relative: function(t, r) {
      if (f(t), f(r), t === r || (t = a.resolve(t)) === (r = a.resolve(r)))
        return "";
      for (var o = 1; o < t.length && t.charCodeAt(o) === 47; ++o)
        ;
      for (var n = t.length, u = n - o, p = 1; p < r.length && r.charCodeAt(p) === 47; ++p)
        ;
      for (var g = r.length - p, v = u < g ? u : g, x = -1, b = 0; b <= v; ++b) {
        if (b === v) {
          if (g > v) {
            if (r.charCodeAt(p + b) === 47)
              return r.slice(p + b + 1);
            if (b === 0)
              return r.slice(p + b);
          } else
            u > v && (t.charCodeAt(o + b) === 47 ? x = b : b === 0 && (x = 0));
          break;
        }
        var w = t.charCodeAt(o + b);
        if (w !== r.charCodeAt(p + b))
          break;
        w === 47 && (x = b);
      }
      var M = "";
      for (b = o + x + 1; b <= n; ++b)
        b !== n && t.charCodeAt(b) !== 47 || (M.length === 0 ? M += ".." : M += "/..");
      return M.length > 0 ? M + r.slice(p + x) : (p += x, r.charCodeAt(p) === 47 && ++p, r.slice(p));
    }, _makeLong: function(t) {
      return t;
    }, dirname: function(t) {
      if (f(t), t.length === 0)
        return ".";
      for (var r = t.charCodeAt(0), o = r === 47, n = -1, u = !0, p = t.length - 1; p >= 1; --p)
        if ((r = t.charCodeAt(p)) === 47) {
          if (!u) {
            n = p;
            break;
          }
        } else
          u = !1;
      return n === -1 ? o ? "/" : "." : o && n === 1 ? "//" : t.slice(0, n);
    }, basename: function(t, r) {
      if (r !== void 0 && typeof r != "string")
        throw new TypeError('"ext" argument must be a string');
      f(t);
      var o, n = 0, u = -1, p = !0;
      if (r !== void 0 && r.length > 0 && r.length <= t.length) {
        if (r.length === t.length && r === t)
          return "";
        var g = r.length - 1, v = -1;
        for (o = t.length - 1; o >= 0; --o) {
          var x = t.charCodeAt(o);
          if (x === 47) {
            if (!p) {
              n = o + 1;
              break;
            }
          } else
            v === -1 && (p = !1, v = o + 1), g >= 0 && (x === r.charCodeAt(g) ? --g == -1 && (u = o) : (g = -1, u = v));
        }
        return n === u ? u = v : u === -1 && (u = t.length), t.slice(n, u);
      }
      for (o = t.length - 1; o >= 0; --o)
        if (t.charCodeAt(o) === 47) {
          if (!p) {
            n = o + 1;
            break;
          }
        } else
          u === -1 && (p = !1, u = o + 1);
      return u === -1 ? "" : t.slice(n, u);
    }, extname: function(t) {
      f(t);
      for (var r = -1, o = 0, n = -1, u = !0, p = 0, g = t.length - 1; g >= 0; --g) {
        var v = t.charCodeAt(g);
        if (v !== 47)
          n === -1 && (u = !1, n = g + 1), v === 46 ? r === -1 ? r = g : p !== 1 && (p = 1) : r !== -1 && (p = -1);
        else if (!u) {
          o = g + 1;
          break;
        }
      }
      return r === -1 || n === -1 || p === 0 || p === 1 && r === n - 1 && r === o + 1 ? "" : t.slice(r, n);
    }, format: function(t) {
      if (t === null || typeof t != "object")
        throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
      return function(r, o) {
        var n = o.dir || o.root, u = o.base || (o.name || "") + (o.ext || "");
        return n ? n === o.root ? n + u : n + "/" + u : u;
      }(0, t);
    }, parse: function(t) {
      f(t);
      var r = { root: "", dir: "", base: "", ext: "", name: "" };
      if (t.length === 0)
        return r;
      var o, n = t.charCodeAt(0), u = n === 47;
      u ? (r.root = "/", o = 1) : o = 0;
      for (var p = -1, g = 0, v = -1, x = !0, b = t.length - 1, w = 0; b >= o; --b)
        if ((n = t.charCodeAt(b)) !== 47)
          v === -1 && (x = !1, v = b + 1), n === 46 ? p === -1 ? p = b : w !== 1 && (w = 1) : p !== -1 && (w = -1);
        else if (!x) {
          g = b + 1;
          break;
        }
      return p === -1 || v === -1 || w === 0 || w === 1 && p === v - 1 && p === g + 1 ? v !== -1 && (r.base = r.name = g === 0 && u ? t.slice(1, v) : t.slice(g, v)) : (g === 0 && u ? (r.name = t.slice(1, p), r.base = t.slice(1, v)) : (r.name = t.slice(g, p), r.base = t.slice(g, v)), r.ext = t.slice(p, v)), g > 0 ? r.dir = t.slice(0, g - 1) : u && (r.dir = "/"), r;
    }, sep: "/", delimiter: ":", win32: null, posix: null };
    a.posix = a, d.exports = a;
  }, 482: (d, l) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.Deferred = void 0, l.Deferred = class {
      constructor() {
        this.resolve = () => null, this.reject = () => null, this.promise = new Promise((s, e) => {
          this.reject = e, this.resolve = s;
        });
      }
    };
  }, 5567: (d, l) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.EndOfStreamError = l.defaultMessages = void 0, l.defaultMessages = "End-Of-Stream";
    class s extends Error {
      constructor() {
        super(l.defaultMessages);
      }
    }
    l.EndOfStreamError = s;
  }, 4514: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.StreamReader = l.EndOfStreamError = void 0;
    const e = s(5567), f = s(482);
    var i = s(5567);
    Object.defineProperty(l, "EndOfStreamError", { enumerable: !0, get: function() {
      return i.EndOfStreamError;
    } }), l.StreamReader = class {
      constructor(a) {
        if (this.s = a, this.deferred = null, this.endOfStream = !1, this.peekQueue = [], !a.read || !a.once)
          throw new Error("Expected an instance of stream.Readable");
        this.s.once("end", () => this.reject(new e.EndOfStreamError())), this.s.once("error", (t) => this.reject(t)), this.s.once("close", () => this.reject(new Error("Stream closed")));
      }
      async peek(a, t, r) {
        const o = await this.read(a, t, r);
        return this.peekQueue.push(a.subarray(t, t + o)), o;
      }
      async read(a, t, r) {
        if (r === 0)
          return 0;
        if (this.peekQueue.length === 0 && this.endOfStream)
          throw new e.EndOfStreamError();
        let o = r, n = 0;
        for (; this.peekQueue.length > 0 && o > 0; ) {
          const u = this.peekQueue.pop();
          if (!u)
            throw new Error("peekData should be defined");
          const p = Math.min(u.length, o);
          a.set(u.subarray(0, p), t + n), n += p, o -= p, p < u.length && this.peekQueue.push(u.subarray(p));
        }
        for (; o > 0 && !this.endOfStream; ) {
          const u = Math.min(o, 1048576), p = await this.readFromStream(a, t + n, u);
          if (n += p, p < u)
            break;
          o -= p;
        }
        return n;
      }
      async readFromStream(a, t, r) {
        const o = this.s.read(r);
        if (o)
          return a.set(o, t), o.length;
        {
          const n = { buffer: a, offset: t, length: r, deferred: new f.Deferred() };
          return this.deferred = n.deferred, this.s.once("readable", () => {
            this.readDeferred(n);
          }), n.deferred.promise;
        }
      }
      readDeferred(a) {
        const t = this.s.read(a.length);
        t ? (a.buffer.set(t, a.offset), a.deferred.resolve(t.length), this.deferred = null) : this.s.once("readable", () => {
          this.readDeferred(a);
        });
      }
      reject(a) {
        this.endOfStream = !0, this.deferred && (this.deferred.reject(a), this.deferred = null);
      }
    };
  }, 4644: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.StreamReader = l.EndOfStreamError = void 0;
    var e = s(5567);
    Object.defineProperty(l, "EndOfStreamError", { enumerable: !0, get: function() {
      return e.EndOfStreamError;
    } });
    var f = s(4514);
    Object.defineProperty(l, "StreamReader", { enumerable: !0, get: function() {
      return f.StreamReader;
    } });
  }, 1294: (d) => {
    function l(r, o, n, u, p, g) {
      for (var v, x, b, w, M = Math.max(o - 1, 0), G = Math.max(n - 1, 0), F = Math.min(o + 1, u - 1), V = Math.min(n + 1, p - 1), q = 4 * (n * u + o), I = 0, _ = 0, R = 0, W = 0, O = 0, j = M; j <= F; j++)
        for (var U = G; U <= V; U++)
          if (j !== o || U !== n) {
            var C = s(r, r, q, 4 * (U * u + j), !0);
            if (C === 0 ? I++ : C < 0 ? R++ : C > 0 && _++, I > 2)
              return !1;
            g && (C < W && (W = C, v = j, x = U), C > O && (O = C, b = j, w = U));
          }
      return !g || R !== 0 && _ !== 0 && (!l(r, v, x, u, p) && !l(g, v, x, u, p) || !l(r, b, w, u, p) && !l(g, b, w, u, p));
    }
    function s(r, o, n, u, p) {
      var g = r[n + 3] / 255, v = o[u + 3] / 255, x = a(r[n + 0], g), b = a(r[n + 1], g), w = a(r[n + 2], g), M = a(o[u + 0], v), G = a(o[u + 1], v), F = a(o[u + 2], v), V = e(x, b, w) - e(M, G, F);
      if (p)
        return V;
      var q = f(x, b, w) - f(M, G, F), I = i(x, b, w) - i(M, G, F);
      return 0.5053 * V * V + 0.299 * q * q + 0.1957 * I * I;
    }
    function e(r, o, n) {
      return 0.29889531 * r + 0.58662247 * o + 0.11448223 * n;
    }
    function f(r, o, n) {
      return 0.59597799 * r - 0.2741761 * o - 0.32180189 * n;
    }
    function i(r, o, n) {
      return 0.21147017 * r - 0.52261711 * o + 0.31114694 * n;
    }
    function a(r, o) {
      return 255 + (r - 255) * o;
    }
    function t(r, o, n, u, p) {
      r[o + 0] = n, r[o + 1] = u, r[o + 2] = p, r[o + 3] = 255;
    }
    d.exports = function(r, o, n, u, p, g) {
      g || (g = {});
      for (var v = g.threshold === void 0 ? 0.1 : g.threshold, x = 35215 * v * v, b = 0, w = 0; w < p; w++)
        for (var M = 0; M < u; M++) {
          var G = 4 * (w * u + M);
          if (s(r, o, G, G) > x)
            g.includeAA || !l(r, M, w, u, p, o) && !l(o, M, w, u, p, r) ? (n && t(n, G, 255, 0, 0), b++) : n && t(n, G, 255, 255, 0);
          else if (n) {
            var F = a((I = (V = r)[(q = G) + 3] / 255, e(a(V[q + 0], I), a(V[q + 1], I), a(V[q + 2], I))), 0.1);
            t(n, G, F, F, F);
          }
        }
      var V, q, I;
      return b;
    };
  }, 9902: (d, l, s) => {
    d.exports = function e(f, i, a) {
      function t(n, u) {
        if (!i[n]) {
          if (!f[n]) {
            if (r)
              return r(n, !0);
            var p = new Error("Cannot find module '" + n + "'");
            throw p.code = "MODULE_NOT_FOUND", p;
          }
          var g = i[n] = { exports: {} };
          f[n][0].call(g.exports, function(v) {
            return t(f[n][1][v] || v);
          }, g, g.exports, e, f, i, a);
        }
        return i[n].exports;
      }
      for (var r = void 0, o = 0; o < a.length; o++)
        t(a[o]);
      return t;
    }({ 1: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("./interlace"), r = [function() {
          }, function(p, g, v, x) {
            if (x === g.length)
              throw new Error("Ran out of data");
            let b = g[x];
            p[v] = b, p[v + 1] = b, p[v + 2] = b, p[v + 3] = 255;
          }, function(p, g, v, x) {
            if (x + 1 >= g.length)
              throw new Error("Ran out of data");
            let b = g[x];
            p[v] = b, p[v + 1] = b, p[v + 2] = b, p[v + 3] = g[x + 1];
          }, function(p, g, v, x) {
            if (x + 2 >= g.length)
              throw new Error("Ran out of data");
            p[v] = g[x], p[v + 1] = g[x + 1], p[v + 2] = g[x + 2], p[v + 3] = 255;
          }, function(p, g, v, x) {
            if (x + 3 >= g.length)
              throw new Error("Ran out of data");
            p[v] = g[x], p[v + 1] = g[x + 1], p[v + 2] = g[x + 2], p[v + 3] = g[x + 3];
          }], o = [function() {
          }, function(p, g, v, x) {
            let b = g[0];
            p[v] = b, p[v + 1] = b, p[v + 2] = b, p[v + 3] = x;
          }, function(p, g, v) {
            let x = g[0];
            p[v] = x, p[v + 1] = x, p[v + 2] = x, p[v + 3] = g[1];
          }, function(p, g, v, x) {
            p[v] = g[0], p[v + 1] = g[1], p[v + 2] = g[2], p[v + 3] = x;
          }, function(p, g, v) {
            p[v] = g[0], p[v + 1] = g[1], p[v + 2] = g[2], p[v + 3] = g[3];
          }];
          function n(p, g, v, x, b, w) {
            let M = p.width, G = p.height, F = p.index;
            for (let V = 0; V < G; V++)
              for (let q = 0; q < M; q++) {
                let I = v(q, V, F);
                r[x](g, b, I, w), w += x;
              }
            return w;
          }
          function u(p, g, v, x, b, w) {
            let M = p.width, G = p.height, F = p.index;
            for (let V = 0; V < G; V++) {
              for (let q = 0; q < M; q++) {
                let I = b.get(x), _ = v(q, V, F);
                o[x](g, I, _, w);
              }
              b.resetAfterLine();
            }
          }
          i.dataToBitMap = function(p, g) {
            let v, x, b = g.width, w = g.height, M = g.depth, G = g.bpp, F = g.interlace;
            M !== 8 && (v = function(R, W) {
              let O = [], j = 0;
              function U() {
                if (j === R.length)
                  throw new Error("Ran out of data");
                let C, ae, J, te, $, L, re, z, N = R[j];
                switch (j++, W) {
                  default:
                    throw new Error("unrecognised depth");
                  case 16:
                    re = R[j], j++, O.push((N << 8) + re);
                    break;
                  case 4:
                    re = 15 & N, z = N >> 4, O.push(z, re);
                    break;
                  case 2:
                    $ = 3 & N, L = N >> 2 & 3, re = N >> 4 & 3, z = N >> 6 & 3, O.push(z, re, L, $);
                    break;
                  case 1:
                    C = 1 & N, ae = N >> 1 & 1, J = N >> 2 & 1, te = N >> 3 & 1, $ = N >> 4 & 1, L = N >> 5 & 1, re = N >> 6 & 1, z = N >> 7 & 1, O.push(z, re, L, $, te, J, ae, C);
                }
              }
              return { get: function(C) {
                for (; O.length < C; )
                  U();
                let ae = O.slice(0, C);
                return O = O.slice(C), ae;
              }, resetAfterLine: function() {
                O.length = 0;
              }, end: function() {
                if (j !== R.length)
                  throw new Error("extra data found");
              } };
            }(p, M)), x = M <= 8 ? a.alloc(b * w * 4) : new Uint16Array(b * w * 4);
            let V, q, I = Math.pow(2, M) - 1, _ = 0;
            if (F)
              V = t.getImagePasses(b, w), q = t.getInterlaceIterator(b, w);
            else {
              let R = 0;
              q = function() {
                let W = R;
                return R += 4, W;
              }, V = [{ width: b, height: w }];
            }
            for (let R = 0; R < V.length; R++)
              M === 8 ? _ = n(V[R], x, q, G, p, _) : u(V[R], x, q, G, v, I);
            if (M === 8) {
              if (_ !== p.length)
                throw new Error("extra data found");
            } else
              v.end();
            return x;
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./interlace": 11, buffer: 33 }], 2: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("./constants");
          f.exports = function(r, o, n, u) {
            let p = [t.COLORTYPE_COLOR_ALPHA, t.COLORTYPE_ALPHA].indexOf(u.colorType) !== -1;
            if (u.colorType === u.inputColorType) {
              let q = function() {
                let I = new ArrayBuffer(2);
                return new DataView(I).setInt16(0, 256, !0), new Int16Array(I)[0] !== 256;
              }();
              if (u.bitDepth === 8 || u.bitDepth === 16 && q)
                return r;
            }
            let g = u.bitDepth !== 16 ? r : new Uint16Array(r.buffer), v = 255, x = t.COLORTYPE_TO_BPP_MAP[u.inputColorType];
            x !== 4 || u.inputHasAlpha || (x = 3);
            let b = t.COLORTYPE_TO_BPP_MAP[u.colorType];
            u.bitDepth === 16 && (v = 65535, b *= 2);
            let w = a.alloc(o * n * b), M = 0, G = 0, F = u.bgColor || {};
            function V() {
              let q, I, _, R = v;
              switch (u.inputColorType) {
                case t.COLORTYPE_COLOR_ALPHA:
                  R = g[M + 3], q = g[M], I = g[M + 1], _ = g[M + 2];
                  break;
                case t.COLORTYPE_COLOR:
                  q = g[M], I = g[M + 1], _ = g[M + 2];
                  break;
                case t.COLORTYPE_ALPHA:
                  R = g[M + 1], q = g[M], I = q, _ = q;
                  break;
                case t.COLORTYPE_GRAYSCALE:
                  q = g[M], I = q, _ = q;
                  break;
                default:
                  throw new Error("input color type:" + u.inputColorType + " is not supported at present");
              }
              return u.inputHasAlpha && (p || (R /= v, q = Math.min(Math.max(Math.round((1 - R) * F.red + R * q), 0), v), I = Math.min(Math.max(Math.round((1 - R) * F.green + R * I), 0), v), _ = Math.min(Math.max(Math.round((1 - R) * F.blue + R * _), 0), v))), { red: q, green: I, blue: _, alpha: R };
            }
            F.red === void 0 && (F.red = v), F.green === void 0 && (F.green = v), F.blue === void 0 && (F.blue = v);
            for (let q = 0; q < n; q++)
              for (let I = 0; I < o; I++) {
                let _ = V();
                switch (u.colorType) {
                  case t.COLORTYPE_COLOR_ALPHA:
                  case t.COLORTYPE_COLOR:
                    u.bitDepth === 8 ? (w[G] = _.red, w[G + 1] = _.green, w[G + 2] = _.blue, p && (w[G + 3] = _.alpha)) : (w.writeUInt16BE(_.red, G), w.writeUInt16BE(_.green, G + 2), w.writeUInt16BE(_.blue, G + 4), p && w.writeUInt16BE(_.alpha, G + 6));
                    break;
                  case t.COLORTYPE_ALPHA:
                  case t.COLORTYPE_GRAYSCALE: {
                    let R = (_.red + _.green + _.blue) / 3;
                    u.bitDepth === 8 ? (w[G] = R, p && (w[G + 1] = _.alpha)) : (w.writeUInt16BE(R, G), p && w.writeUInt16BE(_.alpha, G + 2));
                    break;
                  }
                  default:
                    throw new Error("unrecognised color Type " + u.colorType);
                }
                M += x, G += b;
              }
            return w;
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./constants": 4, buffer: 33 }], 3: [function(e, f, i) {
      (function(a, t) {
        (function() {
          let r = e("util"), o = e("stream"), n = f.exports = function() {
            o.call(this), this._buffers = [], this._buffered = 0, this._reads = [], this._paused = !1, this._encoding = "utf8", this.writable = !0;
          };
          r.inherits(n, o), n.prototype.read = function(u, p) {
            this._reads.push({ length: Math.abs(u), allowLess: u < 0, func: p }), a.nextTick((function() {
              this._process(), this._paused && this._reads && this._reads.length > 0 && (this._paused = !1, this.emit("drain"));
            }).bind(this));
          }, n.prototype.write = function(u, p) {
            if (!this.writable)
              return this.emit("error", new Error("Stream not writable")), !1;
            let g;
            return g = t.isBuffer(u) ? u : t.from(u, p || this._encoding), this._buffers.push(g), this._buffered += g.length, this._process(), this._reads && this._reads.length === 0 && (this._paused = !0), this.writable && !this._paused;
          }, n.prototype.end = function(u, p) {
            u && this.write(u, p), this.writable = !1, this._buffers && (this._buffers.length === 0 ? this._end() : (this._buffers.push(null), this._process()));
          }, n.prototype.destroySoon = n.prototype.end, n.prototype._end = function() {
            this._reads.length > 0 && this.emit("error", new Error("Unexpected end of input")), this.destroy();
          }, n.prototype.destroy = function() {
            this._buffers && (this.writable = !1, this._reads = null, this._buffers = null, this.emit("close"));
          }, n.prototype._processReadAllowingLess = function(u) {
            this._reads.shift();
            let p = this._buffers[0];
            p.length > u.length ? (this._buffered -= u.length, this._buffers[0] = p.slice(u.length), u.func.call(this, p.slice(0, u.length))) : (this._buffered -= p.length, this._buffers.shift(), u.func.call(this, p));
          }, n.prototype._processRead = function(u) {
            this._reads.shift();
            let p = 0, g = 0, v = t.alloc(u.length);
            for (; p < u.length; ) {
              let x = this._buffers[g++], b = Math.min(x.length, u.length - p);
              x.copy(v, p, 0, b), p += b, b !== x.length && (this._buffers[--g] = x.slice(b));
            }
            g > 0 && this._buffers.splice(0, g), this._buffered -= u.length, u.func.call(this, v);
          }, n.prototype._process = function() {
            try {
              for (; this._buffered > 0 && this._reads && this._reads.length > 0; ) {
                let u = this._reads[0];
                if (u.allowLess)
                  this._processReadAllowingLess(u);
                else {
                  if (!(this._buffered >= u.length))
                    break;
                  this._processRead(u);
                }
              }
              this._buffers && !this.writable && this._end();
            } catch (u) {
              this.emit("error", u);
            }
          };
        }).call(this);
      }).call(this, e("_process"), e("buffer").Buffer);
    }, { _process: 60, buffer: 33, stream: 61, util: 81 }], 4: [function(e, f, i) {
      f.exports = { PNG_SIGNATURE: [137, 80, 78, 71, 13, 10, 26, 10], TYPE_IHDR: 1229472850, TYPE_IEND: 1229278788, TYPE_IDAT: 1229209940, TYPE_PLTE: 1347179589, TYPE_tRNS: 1951551059, TYPE_gAMA: 1732332865, COLORTYPE_GRAYSCALE: 0, COLORTYPE_PALETTE: 1, COLORTYPE_COLOR: 2, COLORTYPE_ALPHA: 4, COLORTYPE_PALETTE_COLOR: 3, COLORTYPE_COLOR_ALPHA: 6, COLORTYPE_TO_BPP_MAP: { 0: 1, 2: 3, 3: 1, 4: 2, 6: 4 }, GAMMA_DIVISION: 1e5 };
    }, {}], 5: [function(e, f, i) {
      let a = [];
      (function() {
        for (let r = 0; r < 256; r++) {
          let o = r;
          for (let n = 0; n < 8; n++)
            1 & o ? o = 3988292384 ^ o >>> 1 : o >>>= 1;
          a[r] = o;
        }
      })();
      let t = f.exports = function() {
        this._crc = -1;
      };
      t.prototype.write = function(r) {
        for (let o = 0; o < r.length; o++)
          this._crc = a[255 & (this._crc ^ r[o])] ^ this._crc >>> 8;
        return !0;
      }, t.prototype.crc32 = function() {
        return -1 ^ this._crc;
      }, t.crc32 = function(r) {
        let o = -1;
        for (let n = 0; n < r.length; n++)
          o = a[255 & (o ^ r[n])] ^ o >>> 8;
        return -1 ^ o;
      };
    }, {}], 6: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("./paeth-predictor"), r = { 0: function(n, u, p, g, v) {
            for (let x = 0; x < p; x++)
              g[v + x] = n[u + x];
          }, 1: function(n, u, p, g, v, x) {
            for (let b = 0; b < p; b++) {
              let w = b >= x ? n[u + b - x] : 0, M = n[u + b] - w;
              g[v + b] = M;
            }
          }, 2: function(n, u, p, g, v) {
            for (let x = 0; x < p; x++) {
              let b = u > 0 ? n[u + x - p] : 0, w = n[u + x] - b;
              g[v + x] = w;
            }
          }, 3: function(n, u, p, g, v, x) {
            for (let b = 0; b < p; b++) {
              let w = b >= x ? n[u + b - x] : 0, M = u > 0 ? n[u + b - p] : 0, G = n[u + b] - (w + M >> 1);
              g[v + b] = G;
            }
          }, 4: function(n, u, p, g, v, x) {
            for (let b = 0; b < p; b++) {
              let w = b >= x ? n[u + b - x] : 0, M = u > 0 ? n[u + b - p] : 0, G = u > 0 && b >= x ? n[u + b - (p + x)] : 0, F = n[u + b] - t(w, M, G);
              g[v + b] = F;
            }
          } }, o = { 0: function(n, u, p) {
            let g = 0, v = u + p;
            for (let x = u; x < v; x++)
              g += Math.abs(n[x]);
            return g;
          }, 1: function(n, u, p, g) {
            let v = 0;
            for (let x = 0; x < p; x++) {
              let b = x >= g ? n[u + x - g] : 0, w = n[u + x] - b;
              v += Math.abs(w);
            }
            return v;
          }, 2: function(n, u, p) {
            let g = 0, v = u + p;
            for (let x = u; x < v; x++) {
              let b = u > 0 ? n[x - p] : 0, w = n[x] - b;
              g += Math.abs(w);
            }
            return g;
          }, 3: function(n, u, p, g) {
            let v = 0;
            for (let x = 0; x < p; x++) {
              let b = x >= g ? n[u + x - g] : 0, w = u > 0 ? n[u + x - p] : 0, M = n[u + x] - (b + w >> 1);
              v += Math.abs(M);
            }
            return v;
          }, 4: function(n, u, p, g) {
            let v = 0;
            for (let x = 0; x < p; x++) {
              let b = x >= g ? n[u + x - g] : 0, w = u > 0 ? n[u + x - p] : 0, M = u > 0 && x >= g ? n[u + x - (p + g)] : 0, G = n[u + x] - t(b, w, M);
              v += Math.abs(G);
            }
            return v;
          } };
          f.exports = function(n, u, p, g, v) {
            let x;
            if ("filterType" in g && g.filterType !== -1) {
              if (typeof g.filterType != "number")
                throw new Error("unrecognised filter types");
              x = [g.filterType];
            } else
              x = [0, 1, 2, 3, 4];
            g.bitDepth === 16 && (v *= 2);
            let b = u * v, w = 0, M = 0, G = a.alloc((b + 1) * p), F = x[0];
            for (let V = 0; V < p; V++) {
              if (x.length > 1) {
                let q = 1 / 0;
                for (let I = 0; I < x.length; I++) {
                  let _ = o[x[I]](n, M, b, v);
                  _ < q && (F = x[I], q = _);
                }
              }
              G[w] = F, w++, r[F](n, M, b, G, w, v), w += b, M += b;
            }
            return G;
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./paeth-predictor": 15, buffer: 33 }], 7: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("util"), r = e("./chunkstream"), o = e("./filter-parse"), n = f.exports = function(u) {
            r.call(this);
            let p = [], g = this;
            this._filter = new o(u, { read: this.read.bind(this), write: function(v) {
              p.push(v);
            }, complete: function() {
              g.emit("complete", a.concat(p));
            } }), this._filter.start();
          };
          t.inherits(n, r);
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./chunkstream": 3, "./filter-parse": 9, buffer: 33, util: 81 }], 8: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("./sync-reader"), r = e("./filter-parse");
          i.process = function(o, n) {
            let u = [], p = new t(o);
            return new r(n, { read: p.read.bind(p), write: function(g) {
              u.push(g);
            }, complete: function() {
            } }).start(), p.process(), a.concat(u);
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./filter-parse": 9, "./sync-reader": 22, buffer: 33 }], 9: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("./interlace"), r = e("./paeth-predictor");
          function o(u, p, g) {
            let v = u * p;
            return g !== 8 && (v = Math.ceil(v / (8 / g))), v;
          }
          let n = f.exports = function(u, p) {
            let g = u.width, v = u.height, x = u.interlace, b = u.bpp, w = u.depth;
            if (this.read = p.read, this.write = p.write, this.complete = p.complete, this._imageIndex = 0, this._images = [], x) {
              let M = t.getImagePasses(g, v);
              for (let G = 0; G < M.length; G++)
                this._images.push({ byteWidth: o(M[G].width, b, w), height: M[G].height, lineIndex: 0 });
            } else
              this._images.push({ byteWidth: o(g, b, w), height: v, lineIndex: 0 });
            this._xComparison = w === 8 ? b : w === 16 ? 2 * b : 1;
          };
          n.prototype.start = function() {
            this.read(this._images[this._imageIndex].byteWidth + 1, this._reverseFilterLine.bind(this));
          }, n.prototype._unFilterType1 = function(u, p, g) {
            let v = this._xComparison, x = v - 1;
            for (let b = 0; b < g; b++) {
              let w = u[1 + b], M = b > x ? p[b - v] : 0;
              p[b] = w + M;
            }
          }, n.prototype._unFilterType2 = function(u, p, g) {
            let v = this._lastLine;
            for (let x = 0; x < g; x++) {
              let b = u[1 + x], w = v ? v[x] : 0;
              p[x] = b + w;
            }
          }, n.prototype._unFilterType3 = function(u, p, g) {
            let v = this._xComparison, x = v - 1, b = this._lastLine;
            for (let w = 0; w < g; w++) {
              let M = u[1 + w], G = b ? b[w] : 0, F = w > x ? p[w - v] : 0, V = Math.floor((F + G) / 2);
              p[w] = M + V;
            }
          }, n.prototype._unFilterType4 = function(u, p, g) {
            let v = this._xComparison, x = v - 1, b = this._lastLine;
            for (let w = 0; w < g; w++) {
              let M = u[1 + w], G = b ? b[w] : 0, F = w > x ? p[w - v] : 0, V = w > x && b ? b[w - v] : 0, q = r(F, G, V);
              p[w] = M + q;
            }
          }, n.prototype._reverseFilterLine = function(u) {
            let p, g = u[0], v = this._images[this._imageIndex], x = v.byteWidth;
            if (g === 0)
              p = u.slice(1, x + 1);
            else
              switch (p = a.alloc(x), g) {
                case 1:
                  this._unFilterType1(u, p, x);
                  break;
                case 2:
                  this._unFilterType2(u, p, x);
                  break;
                case 3:
                  this._unFilterType3(u, p, x);
                  break;
                case 4:
                  this._unFilterType4(u, p, x);
                  break;
                default:
                  throw new Error("Unrecognised filter type - " + g);
              }
            this.write(p), v.lineIndex++, v.lineIndex >= v.height ? (this._lastLine = null, this._imageIndex++, v = this._images[this._imageIndex]) : this._lastLine = p, v ? this.read(v.byteWidth + 1, this._reverseFilterLine.bind(this)) : (this._lastLine = null, this.complete());
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./interlace": 11, "./paeth-predictor": 15, buffer: 33 }], 10: [function(e, f, i) {
      (function(a) {
        (function() {
          f.exports = function(t, r, o = !1) {
            let n = r.depth, u = r.width, p = r.height, g = r.colorType, v = r.transColor, x = r.palette, b = t;
            return g === 3 ? function(w, M, G, F, V) {
              let q = 0;
              for (let I = 0; I < F; I++)
                for (let _ = 0; _ < G; _++) {
                  let R = V[w[q]];
                  if (!R)
                    throw new Error("index " + w[q] + " not in palette");
                  for (let W = 0; W < 4; W++)
                    M[q + W] = R[W];
                  q += 4;
                }
            }(t, b, u, p, x) : (v && function(w, M, G, F, V) {
              let q = 0;
              for (let I = 0; I < F; I++)
                for (let _ = 0; _ < G; _++) {
                  let R = !1;
                  if (V.length === 1 ? V[0] === w[q] && (R = !0) : V[0] === w[q] && V[1] === w[q + 1] && V[2] === w[q + 2] && (R = !0), R)
                    for (let W = 0; W < 4; W++)
                      M[q + W] = 0;
                  q += 4;
                }
            }(t, b, u, p, v), n === 8 || o || (n === 16 && (b = a.alloc(u * p * 4)), function(w, M, G, F, V) {
              let q = Math.pow(2, V) - 1, I = 0;
              for (let _ = 0; _ < F; _++)
                for (let R = 0; R < G; R++) {
                  for (let W = 0; W < 4; W++)
                    M[I + W] = Math.floor(255 * w[I + W] / q + 0.5);
                  I += 4;
                }
            }(t, b, u, p, n))), b;
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { buffer: 33 }], 11: [function(e, f, i) {
      let a = [{ x: [0], y: [0] }, { x: [4], y: [0] }, { x: [0, 4], y: [4] }, { x: [2, 6], y: [0, 4] }, { x: [0, 2, 4, 6], y: [2, 6] }, { x: [1, 3, 5, 7], y: [0, 2, 4, 6] }, { x: [0, 1, 2, 3, 4, 5, 6, 7], y: [1, 3, 5, 7] }];
      i.getImagePasses = function(t, r) {
        let o = [], n = t % 8, u = r % 8, p = (t - n) / 8, g = (r - u) / 8;
        for (let v = 0; v < a.length; v++) {
          let x = a[v], b = p * x.x.length, w = g * x.y.length;
          for (let M = 0; M < x.x.length && x.x[M] < n; M++)
            b++;
          for (let M = 0; M < x.y.length && x.y[M] < u; M++)
            w++;
          b > 0 && w > 0 && o.push({ width: b, height: w, index: v });
        }
        return o;
      }, i.getInterlaceIterator = function(t) {
        return function(r, o, n) {
          let u = r % a[n].x.length, p = (r - u) / a[n].x.length * 8 + a[n].x[u], g = o % a[n].y.length;
          return 4 * p + ((o - g) / a[n].y.length * 8 + a[n].y[g]) * t * 4;
        };
      };
    }, {}], 12: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("util"), r = e("stream"), o = e("./constants"), n = e("./packer"), u = f.exports = function(p) {
            r.call(this);
            let g = p || {};
            this._packer = new n(g), this._deflate = this._packer.createDeflate(), this.readable = !0;
          };
          t.inherits(u, r), u.prototype.pack = function(p, g, v, x) {
            this.emit("data", a.from(o.PNG_SIGNATURE)), this.emit("data", this._packer.packIHDR(g, v)), x && this.emit("data", this._packer.packGAMA(x));
            let b = this._packer.filterData(p, g, v);
            this._deflate.on("error", this.emit.bind(this, "error")), this._deflate.on("data", (function(w) {
              this.emit("data", this._packer.packIDAT(w));
            }).bind(this)), this._deflate.on("end", (function() {
              this.emit("data", this._packer.packIEND()), this.emit("end");
            }).bind(this)), this._deflate.end(b);
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./constants": 4, "./packer": 14, buffer: 33, stream: 61, util: 81 }], 13: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = !0, r = e("zlib");
          r.deflateSync || (t = !1);
          let o = e("./constants"), n = e("./packer");
          f.exports = function(u, p) {
            if (!t)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            let g = new n(p || {}), v = [];
            v.push(a.from(o.PNG_SIGNATURE)), v.push(g.packIHDR(u.width, u.height)), u.gamma && v.push(g.packGAMA(u.gamma));
            let x = g.filterData(u.data, u.width, u.height), b = r.deflateSync(x, g.getDeflateOptions());
            if (x = null, !b || !b.length)
              throw new Error("bad png - invalid compressed data response");
            return v.push(g.packIDAT(b)), v.push(g.packIEND()), a.concat(v);
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./constants": 4, "./packer": 14, buffer: 33, zlib: 32 }], 14: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("./constants"), r = e("./crc"), o = e("./bitpacker"), n = e("./filter-pack"), u = e("zlib"), p = f.exports = function(g) {
            if (this._options = g, g.deflateChunkSize = g.deflateChunkSize || 32768, g.deflateLevel = g.deflateLevel != null ? g.deflateLevel : 9, g.deflateStrategy = g.deflateStrategy != null ? g.deflateStrategy : 3, g.inputHasAlpha = g.inputHasAlpha == null || g.inputHasAlpha, g.deflateFactory = g.deflateFactory || u.createDeflate, g.bitDepth = g.bitDepth || 8, g.colorType = typeof g.colorType == "number" ? g.colorType : t.COLORTYPE_COLOR_ALPHA, g.inputColorType = typeof g.inputColorType == "number" ? g.inputColorType : t.COLORTYPE_COLOR_ALPHA, [t.COLORTYPE_GRAYSCALE, t.COLORTYPE_COLOR, t.COLORTYPE_COLOR_ALPHA, t.COLORTYPE_ALPHA].indexOf(g.colorType) === -1)
              throw new Error("option color type:" + g.colorType + " is not supported at present");
            if ([t.COLORTYPE_GRAYSCALE, t.COLORTYPE_COLOR, t.COLORTYPE_COLOR_ALPHA, t.COLORTYPE_ALPHA].indexOf(g.inputColorType) === -1)
              throw new Error("option input color type:" + g.inputColorType + " is not supported at present");
            if (g.bitDepth !== 8 && g.bitDepth !== 16)
              throw new Error("option bit depth:" + g.bitDepth + " is not supported at present");
          };
          p.prototype.getDeflateOptions = function() {
            return { chunkSize: this._options.deflateChunkSize, level: this._options.deflateLevel, strategy: this._options.deflateStrategy };
          }, p.prototype.createDeflate = function() {
            return this._options.deflateFactory(this.getDeflateOptions());
          }, p.prototype.filterData = function(g, v, x) {
            let b = o(g, v, x, this._options), w = t.COLORTYPE_TO_BPP_MAP[this._options.colorType];
            return n(b, v, x, this._options, w);
          }, p.prototype._packChunk = function(g, v) {
            let x = v ? v.length : 0, b = a.alloc(x + 12);
            return b.writeUInt32BE(x, 0), b.writeUInt32BE(g, 4), v && v.copy(b, 8), b.writeInt32BE(r.crc32(b.slice(4, b.length - 4)), b.length - 4), b;
          }, p.prototype.packGAMA = function(g) {
            let v = a.alloc(4);
            return v.writeUInt32BE(Math.floor(g * t.GAMMA_DIVISION), 0), this._packChunk(t.TYPE_gAMA, v);
          }, p.prototype.packIHDR = function(g, v) {
            let x = a.alloc(13);
            return x.writeUInt32BE(g, 0), x.writeUInt32BE(v, 4), x[8] = this._options.bitDepth, x[9] = this._options.colorType, x[10] = 0, x[11] = 0, x[12] = 0, this._packChunk(t.TYPE_IHDR, x);
          }, p.prototype.packIDAT = function(g) {
            return this._packChunk(t.TYPE_IDAT, g);
          }, p.prototype.packIEND = function() {
            return this._packChunk(t.TYPE_IEND, null);
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./bitpacker": 2, "./constants": 4, "./crc": 5, "./filter-pack": 6, buffer: 33, zlib: 32 }], 15: [function(e, f, i) {
      f.exports = function(a, t, r) {
        let o = a + t - r, n = Math.abs(o - a), u = Math.abs(o - t), p = Math.abs(o - r);
        return n <= u && n <= p ? a : u <= p ? t : r;
      };
    }, {}], 16: [function(e, f, i) {
      let a = e("util"), t = e("zlib"), r = e("./chunkstream"), o = e("./filter-parse-async"), n = e("./parser"), u = e("./bitmapper"), p = e("./format-normaliser"), g = f.exports = function(v) {
        r.call(this), this._parser = new n(v, { read: this.read.bind(this), error: this._handleError.bind(this), metadata: this._handleMetaData.bind(this), gamma: this.emit.bind(this, "gamma"), palette: this._handlePalette.bind(this), transColor: this._handleTransColor.bind(this), finished: this._finished.bind(this), inflateData: this._inflateData.bind(this), simpleTransparency: this._simpleTransparency.bind(this), headersFinished: this._headersFinished.bind(this) }), this._options = v, this.writable = !0, this._parser.start();
      };
      a.inherits(g, r), g.prototype._handleError = function(v) {
        this.emit("error", v), this.writable = !1, this.destroy(), this._inflate && this._inflate.destroy && this._inflate.destroy(), this._filter && (this._filter.destroy(), this._filter.on("error", function() {
        })), this.errord = !0;
      }, g.prototype._inflateData = function(v) {
        if (!this._inflate)
          if (this._bitmapInfo.interlace)
            this._inflate = t.createInflate(), this._inflate.on("error", this.emit.bind(this, "error")), this._filter.on("complete", this._complete.bind(this)), this._inflate.pipe(this._filter);
          else {
            let x = (1 + (this._bitmapInfo.width * this._bitmapInfo.bpp * this._bitmapInfo.depth + 7 >> 3)) * this._bitmapInfo.height, b = Math.max(x, t.Z_MIN_CHUNK);
            this._inflate = t.createInflate({ chunkSize: b });
            let w = x, M = this.emit.bind(this, "error");
            this._inflate.on("error", function(F) {
              w && M(F);
            }), this._filter.on("complete", this._complete.bind(this));
            let G = this._filter.write.bind(this._filter);
            this._inflate.on("data", function(F) {
              w && (F.length > w && (F = F.slice(0, w)), w -= F.length, G(F));
            }), this._inflate.on("end", this._filter.end.bind(this._filter));
          }
        this._inflate.write(v);
      }, g.prototype._handleMetaData = function(v) {
        this._metaData = v, this._bitmapInfo = Object.create(v), this._filter = new o(this._bitmapInfo);
      }, g.prototype._handleTransColor = function(v) {
        this._bitmapInfo.transColor = v;
      }, g.prototype._handlePalette = function(v) {
        this._bitmapInfo.palette = v;
      }, g.prototype._simpleTransparency = function() {
        this._metaData.alpha = !0;
      }, g.prototype._headersFinished = function() {
        this.emit("metadata", this._metaData);
      }, g.prototype._finished = function() {
        this.errord || (this._inflate ? this._inflate.end() : this.emit("error", "No Inflate block"));
      }, g.prototype._complete = function(v) {
        if (this.errord)
          return;
        let x;
        try {
          let b = u.dataToBitMap(v, this._bitmapInfo);
          x = p(b, this._bitmapInfo, this._options.skipRescale), b = null;
        } catch (b) {
          return void this._handleError(b);
        }
        this.emit("parsed", x);
      };
    }, { "./bitmapper": 1, "./chunkstream": 3, "./filter-parse-async": 7, "./format-normaliser": 10, "./parser": 18, util: 81, zlib: 32 }], 17: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = !0, r = e("zlib"), o = e("./sync-inflate");
          r.deflateSync || (t = !1);
          let n = e("./sync-reader"), u = e("./filter-parse-sync"), p = e("./parser"), g = e("./bitmapper"), v = e("./format-normaliser");
          f.exports = function(x, b) {
            if (!t)
              throw new Error("To use the sync capability of this library in old node versions, please pin pngjs to v2.3.0");
            let w, M, G, F = [], V = new n(x);
            if (new p(b, { read: V.read.bind(V), error: function(O) {
              w = O;
            }, metadata: function(O) {
              M = O;
            }, gamma: function(O) {
              G = O;
            }, palette: function(O) {
              M.palette = O;
            }, transColor: function(O) {
              M.transColor = O;
            }, inflateData: function(O) {
              F.push(O);
            }, simpleTransparency: function() {
              M.alpha = !0;
            } }).start(), V.process(), w)
              throw w;
            let q, I = a.concat(F);
            if (F.length = 0, M.interlace)
              q = r.inflateSync(I);
            else {
              let O = (1 + (M.width * M.bpp * M.depth + 7 >> 3)) * M.height;
              q = o(I, { chunkSize: O, maxLength: O });
            }
            if (I = null, !q || !q.length)
              throw new Error("bad png - invalid inflate data response");
            let _ = u.process(q, M);
            I = null;
            let R = g.dataToBitMap(_, M);
            _ = null;
            let W = v(R, M, b.skipRescale);
            return M.data = W, M.gamma = G || 0, M;
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./bitmapper": 1, "./filter-parse-sync": 8, "./format-normaliser": 10, "./parser": 18, "./sync-inflate": 21, "./sync-reader": 22, buffer: 33, zlib: 32 }], 18: [function(e, f, i) {
      (function(a) {
        (function() {
          let t = e("./constants"), r = e("./crc"), o = f.exports = function(n, u) {
            this._options = n, n.checkCRC = n.checkCRC !== !1, this._hasIHDR = !1, this._hasIEND = !1, this._emittedHeadersFinished = !1, this._palette = [], this._colorType = 0, this._chunks = {}, this._chunks[t.TYPE_IHDR] = this._handleIHDR.bind(this), this._chunks[t.TYPE_IEND] = this._handleIEND.bind(this), this._chunks[t.TYPE_IDAT] = this._handleIDAT.bind(this), this._chunks[t.TYPE_PLTE] = this._handlePLTE.bind(this), this._chunks[t.TYPE_tRNS] = this._handleTRNS.bind(this), this._chunks[t.TYPE_gAMA] = this._handleGAMA.bind(this), this.read = u.read, this.error = u.error, this.metadata = u.metadata, this.gamma = u.gamma, this.transColor = u.transColor, this.palette = u.palette, this.parsed = u.parsed, this.inflateData = u.inflateData, this.finished = u.finished, this.simpleTransparency = u.simpleTransparency, this.headersFinished = u.headersFinished || function() {
            };
          };
          o.prototype.start = function() {
            this.read(t.PNG_SIGNATURE.length, this._parseSignature.bind(this));
          }, o.prototype._parseSignature = function(n) {
            let u = t.PNG_SIGNATURE;
            for (let p = 0; p < u.length; p++)
              if (n[p] !== u[p])
                return void this.error(new Error("Invalid file signature"));
            this.read(8, this._parseChunkBegin.bind(this));
          }, o.prototype._parseChunkBegin = function(n) {
            let u = n.readUInt32BE(0), p = n.readUInt32BE(4), g = "";
            for (let x = 4; x < 8; x++)
              g += String.fromCharCode(n[x]);
            let v = !!(32 & n[4]);
            if (this._hasIHDR || p === t.TYPE_IHDR) {
              if (this._crc = new r(), this._crc.write(a.from(g)), this._chunks[p])
                return this._chunks[p](u);
              v ? this.read(u + 4, this._skipChunk.bind(this)) : this.error(new Error("Unsupported critical chunk type " + g));
            } else
              this.error(new Error("Expected IHDR on beggining"));
          }, o.prototype._skipChunk = function() {
            this.read(8, this._parseChunkBegin.bind(this));
          }, o.prototype._handleChunkEnd = function() {
            this.read(4, this._parseChunkEnd.bind(this));
          }, o.prototype._parseChunkEnd = function(n) {
            let u = n.readInt32BE(0), p = this._crc.crc32();
            this._options.checkCRC && p !== u ? this.error(new Error("Crc error - " + u + " - " + p)) : this._hasIEND || this.read(8, this._parseChunkBegin.bind(this));
          }, o.prototype._handleIHDR = function(n) {
            this.read(n, this._parseIHDR.bind(this));
          }, o.prototype._parseIHDR = function(n) {
            this._crc.write(n);
            let u = n.readUInt32BE(0), p = n.readUInt32BE(4), g = n[8], v = n[9], x = n[10], b = n[11], w = n[12];
            if (g !== 8 && g !== 4 && g !== 2 && g !== 1 && g !== 16)
              return void this.error(new Error("Unsupported bit depth " + g));
            if (!(v in t.COLORTYPE_TO_BPP_MAP))
              return void this.error(new Error("Unsupported color type"));
            if (x !== 0)
              return void this.error(new Error("Unsupported compression method"));
            if (b !== 0)
              return void this.error(new Error("Unsupported filter method"));
            if (w !== 0 && w !== 1)
              return void this.error(new Error("Unsupported interlace method"));
            this._colorType = v;
            let M = t.COLORTYPE_TO_BPP_MAP[this._colorType];
            this._hasIHDR = !0, this.metadata({ width: u, height: p, depth: g, interlace: !!w, palette: !!(v & t.COLORTYPE_PALETTE), color: !!(v & t.COLORTYPE_COLOR), alpha: !!(v & t.COLORTYPE_ALPHA), bpp: M, colorType: v }), this._handleChunkEnd();
          }, o.prototype._handlePLTE = function(n) {
            this.read(n, this._parsePLTE.bind(this));
          }, o.prototype._parsePLTE = function(n) {
            this._crc.write(n);
            let u = Math.floor(n.length / 3);
            for (let p = 0; p < u; p++)
              this._palette.push([n[3 * p], n[3 * p + 1], n[3 * p + 2], 255]);
            this.palette(this._palette), this._handleChunkEnd();
          }, o.prototype._handleTRNS = function(n) {
            this.simpleTransparency(), this.read(n, this._parseTRNS.bind(this));
          }, o.prototype._parseTRNS = function(n) {
            if (this._crc.write(n), this._colorType === t.COLORTYPE_PALETTE_COLOR) {
              if (this._palette.length === 0)
                return void this.error(new Error("Transparency chunk must be after palette"));
              if (n.length > this._palette.length)
                return void this.error(new Error("More transparent colors than palette size"));
              for (let u = 0; u < n.length; u++)
                this._palette[u][3] = n[u];
              this.palette(this._palette);
            }
            this._colorType === t.COLORTYPE_GRAYSCALE && this.transColor([n.readUInt16BE(0)]), this._colorType === t.COLORTYPE_COLOR && this.transColor([n.readUInt16BE(0), n.readUInt16BE(2), n.readUInt16BE(4)]), this._handleChunkEnd();
          }, o.prototype._handleGAMA = function(n) {
            this.read(n, this._parseGAMA.bind(this));
          }, o.prototype._parseGAMA = function(n) {
            this._crc.write(n), this.gamma(n.readUInt32BE(0) / t.GAMMA_DIVISION), this._handleChunkEnd();
          }, o.prototype._handleIDAT = function(n) {
            this._emittedHeadersFinished || (this._emittedHeadersFinished = !0, this.headersFinished()), this.read(-n, this._parseIDAT.bind(this, n));
          }, o.prototype._parseIDAT = function(n, u) {
            if (this._crc.write(u), this._colorType === t.COLORTYPE_PALETTE_COLOR && this._palette.length === 0)
              throw new Error("Expected palette not found");
            this.inflateData(u);
            let p = n - u.length;
            p > 0 ? this._handleIDAT(p) : this._handleChunkEnd();
          }, o.prototype._handleIEND = function(n) {
            this.read(n, this._parseIEND.bind(this));
          }, o.prototype._parseIEND = function(n) {
            this._crc.write(n), this._hasIEND = !0, this._handleChunkEnd(), this.finished && this.finished();
          };
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "./constants": 4, "./crc": 5, buffer: 33 }], 19: [function(e, f, i) {
      let a = e("./parser-sync"), t = e("./packer-sync");
      i.read = function(r, o) {
        return a(r, o || {});
      }, i.write = function(r, o) {
        return t(r, o);
      };
    }, { "./packer-sync": 13, "./parser-sync": 17 }], 20: [function(e, f, i) {
      (function(a, t) {
        (function() {
          let r = e("util"), o = e("stream"), n = e("./parser-async"), u = e("./packer-async"), p = e("./png-sync"), g = i.PNG = function(v) {
            o.call(this), v = v || {}, this.width = 0 | v.width, this.height = 0 | v.height, this.data = this.width > 0 && this.height > 0 ? t.alloc(4 * this.width * this.height) : null, v.fill && this.data && this.data.fill(0), this.gamma = 0, this.readable = this.writable = !0, this._parser = new n(v), this._parser.on("error", this.emit.bind(this, "error")), this._parser.on("close", this._handleClose.bind(this)), this._parser.on("metadata", this._metadata.bind(this)), this._parser.on("gamma", this._gamma.bind(this)), this._parser.on("parsed", (function(x) {
              this.data = x, this.emit("parsed", x);
            }).bind(this)), this._packer = new u(v), this._packer.on("data", this.emit.bind(this, "data")), this._packer.on("end", this.emit.bind(this, "end")), this._parser.on("close", this._handleClose.bind(this)), this._packer.on("error", this.emit.bind(this, "error"));
          };
          r.inherits(g, o), g.sync = p, g.prototype.pack = function() {
            return this.data && this.data.length ? (a.nextTick((function() {
              this._packer.pack(this.data, this.width, this.height, this.gamma);
            }).bind(this)), this) : (this.emit("error", "No data provided"), this);
          }, g.prototype.parse = function(v, x) {
            if (x) {
              let b, w;
              b = (function(M) {
                this.removeListener("error", w), this.data = M, x(null, this);
              }).bind(this), w = (function(M) {
                this.removeListener("parsed", b), x(M, null);
              }).bind(this), this.once("parsed", b), this.once("error", w);
            }
            return this.end(v), this;
          }, g.prototype.write = function(v) {
            return this._parser.write(v), !0;
          }, g.prototype.end = function(v) {
            this._parser.end(v);
          }, g.prototype._metadata = function(v) {
            this.width = v.width, this.height = v.height, this.emit("metadata", v);
          }, g.prototype._gamma = function(v) {
            this.gamma = v;
          }, g.prototype._handleClose = function() {
            this._parser.writable || this._packer.readable || this.emit("close");
          }, g.bitblt = function(v, x, b, w, M, G, F, V) {
            if (w |= 0, M |= 0, G |= 0, F |= 0, V |= 0, (b |= 0) > v.width || w > v.height || b + M > v.width || w + G > v.height)
              throw new Error("bitblt reading outside image");
            if (F > x.width || V > x.height || F + M > x.width || V + G > x.height)
              throw new Error("bitblt writing outside image");
            for (let q = 0; q < G; q++)
              v.data.copy(x.data, (V + q) * x.width + F << 2, (w + q) * v.width + b << 2, (w + q) * v.width + b + M << 2);
          }, g.prototype.bitblt = function(v, x, b, w, M, G, F) {
            return g.bitblt(this, v, x, b, w, M, G, F), this;
          }, g.adjustGamma = function(v) {
            if (v.gamma) {
              for (let x = 0; x < v.height; x++)
                for (let b = 0; b < v.width; b++) {
                  let w = v.width * x + b << 2;
                  for (let M = 0; M < 3; M++) {
                    let G = v.data[w + M] / 255;
                    G = Math.pow(G, 0.45454545454545453 / v.gamma), v.data[w + M] = Math.round(255 * G);
                  }
                }
              v.gamma = 0;
            }
          }, g.prototype.adjustGamma = function() {
            g.adjustGamma(this);
          };
        }).call(this);
      }).call(this, e("_process"), e("buffer").Buffer);
    }, { "./packer-async": 12, "./parser-async": 16, "./png-sync": 19, _process: 60, buffer: 33, stream: 61, util: 81 }], 21: [function(e, f, i) {
      (function(a, t) {
        (function() {
          let r = e("assert").ok, o = e("zlib"), n = e("util"), u = e("buffer").kMaxLength;
          function p(x) {
            if (!(this instanceof p))
              return new p(x);
            x && x.chunkSize < o.Z_MIN_CHUNK && (x.chunkSize = o.Z_MIN_CHUNK), o.Inflate.call(this, x), this._offset = this._offset === void 0 ? this._outOffset : this._offset, this._buffer = this._buffer || this._outBuffer, x && x.maxLength != null && (this._maxLength = x.maxLength);
          }
          function g(x, b) {
            b && a.nextTick(b), x._handle && (x._handle.close(), x._handle = null);
          }
          function v(x, b) {
            return function(w, M) {
              if (typeof M == "string" && (M = t.from(M)), !(M instanceof t))
                throw new TypeError("Not a string or buffer");
              let G = w._finishFlushFlag;
              return G == null && (G = o.Z_FINISH), w._processChunk(M, G);
            }(new p(b), x);
          }
          p.prototype._processChunk = function(x, b, w) {
            if (typeof w == "function")
              return o.Inflate._processChunk.call(this, x, b, w);
            let M, G, F = this, V = x && x.length, q = this._chunkSize - this._offset, I = this._maxLength, _ = 0, R = [], W = 0;
            function O(U, C) {
              if (F._hadError)
                return;
              let ae = q - C;
              if (r(ae >= 0, "have should not go down"), ae > 0) {
                let J = F._buffer.slice(F._offset, F._offset + ae);
                if (F._offset += ae, J.length > I && (J = J.slice(0, I)), R.push(J), W += J.length, I -= J.length, I === 0)
                  return !1;
              }
              return (C === 0 || F._offset >= F._chunkSize) && (q = F._chunkSize, F._offset = 0, F._buffer = t.allocUnsafe(F._chunkSize)), C === 0 && (_ += V - U, V = U, !0);
            }
            this.on("error", function(U) {
              M = U;
            }), r(this._handle, "zlib binding closed");
            do
              G = this._handle.writeSync(b, x, _, V, this._buffer, this._offset, q), G = G || this._writeState;
            while (!this._hadError && O(G[0], G[1]));
            if (this._hadError)
              throw M;
            if (W >= u)
              throw g(this), new RangeError("Cannot create final Buffer. It would be larger than 0x" + u.toString(16) + " bytes");
            let j = t.concat(R, W);
            return g(this), j;
          }, n.inherits(p, o.Inflate), f.exports = i = v, i.Inflate = p, i.createInflate = function(x) {
            return new p(x);
          }, i.inflateSync = v;
        }).call(this);
      }).call(this, e("_process"), e("buffer").Buffer);
    }, { _process: 60, assert: 23, buffer: 33, util: 81, zlib: 32 }], 22: [function(e, f, i) {
      let a = f.exports = function(t) {
        this._buffer = t, this._reads = [];
      };
      a.prototype.read = function(t, r) {
        this._reads.push({ length: Math.abs(t), allowLess: t < 0, func: r });
      }, a.prototype.process = function() {
        for (; this._reads.length > 0 && this._buffer.length; ) {
          let t = this._reads[0];
          if (!this._buffer.length || !(this._buffer.length >= t.length || t.allowLess))
            break;
          {
            this._reads.shift();
            let r = this._buffer;
            this._buffer = r.slice(t.length), t.func.call(this, r.slice(0, t.length));
          }
        }
        if (this._reads.length > 0)
          throw new Error("There are some read requests waitng on finished stream");
        if (this._buffer.length > 0)
          throw new Error("unrecognised content at end of stream");
      };
    }, {}], 23: [function(e, f, i) {
      (function(a) {
        (function() {
          function t(O, j) {
            if (O === j)
              return 0;
            for (var U = O.length, C = j.length, ae = 0, J = Math.min(U, C); ae < J; ++ae)
              if (O[ae] !== j[ae]) {
                U = O[ae], C = j[ae];
                break;
              }
            return U < C ? -1 : C < U ? 1 : 0;
          }
          function r(O) {
            return a.Buffer && typeof a.Buffer.isBuffer == "function" ? a.Buffer.isBuffer(O) : !(O == null || !O._isBuffer);
          }
          var o = e("util/"), n = Object.prototype.hasOwnProperty, u = Array.prototype.slice, p = (function() {
          }).name === "foo";
          function g(O) {
            return Object.prototype.toString.call(O);
          }
          function v(O) {
            return !r(O) && typeof a.ArrayBuffer == "function" && (typeof ArrayBuffer.isView == "function" ? ArrayBuffer.isView(O) : !!O && (O instanceof DataView || !!(O.buffer && O.buffer instanceof ArrayBuffer)));
          }
          var x = f.exports = V, b = /\s*function\s+([^\(\s]*)\s*/;
          function w(O) {
            if (o.isFunction(O)) {
              if (p)
                return O.name;
              var j = O.toString().match(b);
              return j && j[1];
            }
          }
          function M(O, j) {
            return typeof O == "string" ? O.length < j ? O : O.slice(0, j) : O;
          }
          function G(O) {
            if (p || !o.isFunction(O))
              return o.inspect(O);
            var j = w(O);
            return "[Function" + (j ? ": " + j : "") + "]";
          }
          function F(O, j, U, C, ae) {
            throw new x.AssertionError({ message: U, actual: O, expected: j, operator: C, stackStartFunction: ae });
          }
          function V(O, j) {
            O || F(O, !0, j, "==", x.ok);
          }
          function q(O, j, U, C) {
            if (O === j)
              return !0;
            if (r(O) && r(j))
              return t(O, j) === 0;
            if (o.isDate(O) && o.isDate(j))
              return O.getTime() === j.getTime();
            if (o.isRegExp(O) && o.isRegExp(j))
              return O.source === j.source && O.global === j.global && O.multiline === j.multiline && O.lastIndex === j.lastIndex && O.ignoreCase === j.ignoreCase;
            if (O !== null && typeof O == "object" || j !== null && typeof j == "object") {
              if (v(O) && v(j) && g(O) === g(j) && !(O instanceof Float32Array || O instanceof Float64Array))
                return t(new Uint8Array(O.buffer), new Uint8Array(j.buffer)) === 0;
              if (r(O) !== r(j))
                return !1;
              var ae = (C = C || { actual: [], expected: [] }).actual.indexOf(O);
              return ae !== -1 && ae === C.expected.indexOf(j) || (C.actual.push(O), C.expected.push(j), function(J, te, $, L) {
                if (J == null || te == null)
                  return !1;
                if (o.isPrimitive(J) || o.isPrimitive(te))
                  return J === te;
                if ($ && Object.getPrototypeOf(J) !== Object.getPrototypeOf(te))
                  return !1;
                var re = I(J), z = I(te);
                if (re && !z || !re && z)
                  return !1;
                if (re)
                  return q(J = u.call(J), te = u.call(te), $);
                var N, ne, le = W(J), he = W(te);
                if (le.length !== he.length)
                  return !1;
                for (le.sort(), he.sort(), ne = le.length - 1; ne >= 0; ne--)
                  if (le[ne] !== he[ne])
                    return !1;
                for (ne = le.length - 1; ne >= 0; ne--)
                  if (!q(J[N = le[ne]], te[N], $, L))
                    return !1;
                return !0;
              }(O, j, U, C));
            }
            return U ? O === j : O == j;
          }
          function I(O) {
            return Object.prototype.toString.call(O) == "[object Arguments]";
          }
          function _(O, j) {
            if (!O || !j)
              return !1;
            if (Object.prototype.toString.call(j) == "[object RegExp]")
              return j.test(O);
            try {
              if (O instanceof j)
                return !0;
            } catch {
            }
            return !Error.isPrototypeOf(j) && j.call({}, O) === !0;
          }
          function R(O, j, U, C) {
            var ae;
            if (typeof j != "function")
              throw new TypeError('"block" argument must be a function');
            typeof U == "string" && (C = U, U = null), ae = function($) {
              var L;
              try {
                $();
              } catch (re) {
                L = re;
              }
              return L;
            }(j), C = (U && U.name ? " (" + U.name + ")." : ".") + (C ? " " + C : "."), O && !ae && F(ae, U, "Missing expected exception" + C);
            var J = typeof C == "string", te = !O && ae && !U;
            if ((!O && o.isError(ae) && J && _(ae, U) || te) && F(ae, U, "Got unwanted exception" + C), O && ae && U && !_(ae, U) || !O && ae)
              throw ae;
          }
          x.AssertionError = function(O) {
            this.name = "AssertionError", this.actual = O.actual, this.expected = O.expected, this.operator = O.operator, O.message ? (this.message = O.message, this.generatedMessage = !1) : (this.message = function($) {
              return M(G($.actual), 128) + " " + $.operator + " " + M(G($.expected), 128);
            }(this), this.generatedMessage = !0);
            var j = O.stackStartFunction || F;
            if (Error.captureStackTrace)
              Error.captureStackTrace(this, j);
            else {
              var U = new Error();
              if (U.stack) {
                var C = U.stack, ae = w(j), J = C.indexOf(`
` + ae);
                if (J >= 0) {
                  var te = C.indexOf(`
`, J + 1);
                  C = C.substring(te + 1);
                }
                this.stack = C;
              }
            }
          }, o.inherits(x.AssertionError, Error), x.fail = F, x.ok = V, x.equal = function(O, j, U) {
            O != j && F(O, j, U, "==", x.equal);
          }, x.notEqual = function(O, j, U) {
            O == j && F(O, j, U, "!=", x.notEqual);
          }, x.deepEqual = function(O, j, U) {
            q(O, j, !1) || F(O, j, U, "deepEqual", x.deepEqual);
          }, x.deepStrictEqual = function(O, j, U) {
            q(O, j, !0) || F(O, j, U, "deepStrictEqual", x.deepStrictEqual);
          }, x.notDeepEqual = function(O, j, U) {
            q(O, j, !1) && F(O, j, U, "notDeepEqual", x.notDeepEqual);
          }, x.notDeepStrictEqual = function O(j, U, C) {
            q(j, U, !0) && F(j, U, C, "notDeepStrictEqual", O);
          }, x.strictEqual = function(O, j, U) {
            O !== j && F(O, j, U, "===", x.strictEqual);
          }, x.notStrictEqual = function(O, j, U) {
            O === j && F(O, j, U, "!==", x.notStrictEqual);
          }, x.throws = function(O, j, U) {
            R(!0, O, j, U);
          }, x.doesNotThrow = function(O, j, U) {
            R(!1, O, j, U);
          }, x.ifError = function(O) {
            if (O)
              throw O;
          };
          var W = Object.keys || function(O) {
            var j = [];
            for (var U in O)
              n.call(O, U) && j.push(U);
            return j;
          };
        }).call(this);
      }).call(this, s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "util/": 26 }], 24: [function(e, f, i) {
      typeof Object.create == "function" ? f.exports = function(a, t) {
        a.super_ = t, a.prototype = Object.create(t.prototype, { constructor: { value: a, enumerable: !1, writable: !0, configurable: !0 } });
      } : f.exports = function(a, t) {
        a.super_ = t;
        var r = function() {
        };
        r.prototype = t.prototype, a.prototype = new r(), a.prototype.constructor = a;
      };
    }, {}], 25: [function(e, f, i) {
      f.exports = function(a) {
        return a && typeof a == "object" && typeof a.copy == "function" && typeof a.fill == "function" && typeof a.readUInt8 == "function";
      };
    }, {}], 26: [function(e, f, i) {
      (function(a, t) {
        (function() {
          var r = /%[sdj%]/g;
          i.format = function(J) {
            if (!V(J)) {
              for (var te = [], $ = 0; $ < arguments.length; $++)
                te.push(u(arguments[$]));
              return te.join(" ");
            }
            $ = 1;
            for (var L = arguments, re = L.length, z = String(J).replace(r, function(ne) {
              if (ne === "%%")
                return "%";
              if ($ >= re)
                return ne;
              switch (ne) {
                case "%s":
                  return String(L[$++]);
                case "%d":
                  return Number(L[$++]);
                case "%j":
                  try {
                    return JSON.stringify(L[$++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return ne;
              }
            }), N = L[$]; $ < re; N = L[++$])
              G(N) || !_(N) ? z += " " + N : z += " " + u(N);
            return z;
          }, i.deprecate = function(J, te) {
            if (q(t.process))
              return function() {
                return i.deprecate(J, te).apply(this, arguments);
              };
            if (a.noDeprecation === !0)
              return J;
            var $ = !1;
            return function() {
              if (!$) {
                if (a.throwDeprecation)
                  throw new Error(te);
                a.traceDeprecation ? console.trace(te) : console.error(te), $ = !0;
              }
              return J.apply(this, arguments);
            };
          };
          var o, n = {};
          function u(J, te) {
            var $ = { seen: [], stylize: g };
            return arguments.length >= 3 && ($.depth = arguments[2]), arguments.length >= 4 && ($.colors = arguments[3]), M(te) ? $.showHidden = te : te && i._extend($, te), q($.showHidden) && ($.showHidden = !1), q($.depth) && ($.depth = 2), q($.colors) && ($.colors = !1), q($.customInspect) && ($.customInspect = !0), $.colors && ($.stylize = p), v($, J, $.depth);
          }
          function p(J, te) {
            var $ = u.styles[te];
            return $ ? "\x1B[" + u.colors[$][0] + "m" + J + "\x1B[" + u.colors[$][1] + "m" : J;
          }
          function g(J, te) {
            return J;
          }
          function v(J, te, $) {
            if (J.customInspect && te && O(te.inspect) && te.inspect !== i.inspect && (!te.constructor || te.constructor.prototype !== te)) {
              var L = te.inspect($, J);
              return V(L) || (L = v(J, L, $)), L;
            }
            var re = function(B, K) {
              if (q(K))
                return B.stylize("undefined", "undefined");
              if (V(K)) {
                var h = "'" + JSON.stringify(K).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return B.stylize(h, "string");
              }
              return F(K) ? B.stylize("" + K, "number") : M(K) ? B.stylize("" + K, "boolean") : G(K) ? B.stylize("null", "null") : void 0;
            }(J, te);
            if (re)
              return re;
            var z = Object.keys(te), N = function(B) {
              var K = {};
              return B.forEach(function(h, c) {
                K[h] = !0;
              }), K;
            }(z);
            if (J.showHidden && (z = Object.getOwnPropertyNames(te)), W(te) && (z.indexOf("message") >= 0 || z.indexOf("description") >= 0))
              return x(te);
            if (z.length === 0) {
              if (O(te)) {
                var ne = te.name ? ": " + te.name : "";
                return J.stylize("[Function" + ne + "]", "special");
              }
              if (I(te))
                return J.stylize(RegExp.prototype.toString.call(te), "regexp");
              if (R(te))
                return J.stylize(Date.prototype.toString.call(te), "date");
              if (W(te))
                return x(te);
            }
            var le, he = "", k = !1, T = ["{", "}"];
            return w(te) && (k = !0, T = ["[", "]"]), O(te) && (he = " [Function" + (te.name ? ": " + te.name : "") + "]"), I(te) && (he = " " + RegExp.prototype.toString.call(te)), R(te) && (he = " " + Date.prototype.toUTCString.call(te)), W(te) && (he = " " + x(te)), z.length !== 0 || k && te.length != 0 ? $ < 0 ? I(te) ? J.stylize(RegExp.prototype.toString.call(te), "regexp") : J.stylize("[Object]", "special") : (J.seen.push(te), le = k ? function(B, K, h, c, m) {
              for (var D = [], ee = 0, E = K.length; ee < E; ++ee)
                ae(K, String(ee)) ? D.push(b(B, K, h, c, String(ee), !0)) : D.push("");
              return m.forEach(function(Q) {
                Q.match(/^\d+$/) || D.push(b(B, K, h, c, Q, !0));
              }), D;
            }(J, te, $, N, z) : z.map(function(B) {
              return b(J, te, $, N, B, k);
            }), J.seen.pop(), function(B, K, h) {
              return B.reduce(function(c, m) {
                return m.indexOf(`
`), c + m.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0) > 60 ? h[0] + (K === "" ? "" : K + `
 `) + " " + B.join(`,
  `) + " " + h[1] : h[0] + K + " " + B.join(", ") + " " + h[1];
            }(le, he, T)) : T[0] + he + T[1];
          }
          function x(J) {
            return "[" + Error.prototype.toString.call(J) + "]";
          }
          function b(J, te, $, L, re, z) {
            var N, ne, le;
            if ((le = Object.getOwnPropertyDescriptor(te, re) || { value: te[re] }).get ? ne = le.set ? J.stylize("[Getter/Setter]", "special") : J.stylize("[Getter]", "special") : le.set && (ne = J.stylize("[Setter]", "special")), ae(L, re) || (N = "[" + re + "]"), ne || (J.seen.indexOf(le.value) < 0 ? (ne = G($) ? v(J, le.value, null) : v(J, le.value, $ - 1)).indexOf(`
`) > -1 && (ne = z ? ne.split(`
`).map(function(he) {
              return "  " + he;
            }).join(`
`).substr(2) : `
` + ne.split(`
`).map(function(he) {
              return "   " + he;
            }).join(`
`)) : ne = J.stylize("[Circular]", "special")), q(N)) {
              if (z && re.match(/^\d+$/))
                return ne;
              (N = JSON.stringify("" + re)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (N = N.substr(1, N.length - 2), N = J.stylize(N, "name")) : (N = N.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), N = J.stylize(N, "string"));
            }
            return N + ": " + ne;
          }
          function w(J) {
            return Array.isArray(J);
          }
          function M(J) {
            return typeof J == "boolean";
          }
          function G(J) {
            return J === null;
          }
          function F(J) {
            return typeof J == "number";
          }
          function V(J) {
            return typeof J == "string";
          }
          function q(J) {
            return J === void 0;
          }
          function I(J) {
            return _(J) && j(J) === "[object RegExp]";
          }
          function _(J) {
            return typeof J == "object" && J !== null;
          }
          function R(J) {
            return _(J) && j(J) === "[object Date]";
          }
          function W(J) {
            return _(J) && (j(J) === "[object Error]" || J instanceof Error);
          }
          function O(J) {
            return typeof J == "function";
          }
          function j(J) {
            return Object.prototype.toString.call(J);
          }
          function U(J) {
            return J < 10 ? "0" + J.toString(10) : J.toString(10);
          }
          i.debuglog = function(J) {
            if (q(o) && (o = a.env.NODE_DEBUG || ""), J = J.toUpperCase(), !n[J])
              if (new RegExp("\\b" + J + "\\b", "i").test(o)) {
                var te = a.pid;
                n[J] = function() {
                  var $ = i.format.apply(i, arguments);
                  console.error("%s %d: %s", J, te, $);
                };
              } else
                n[J] = function() {
                };
            return n[J];
          }, i.inspect = u, u.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, u.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i.isArray = w, i.isBoolean = M, i.isNull = G, i.isNullOrUndefined = function(J) {
            return J == null;
          }, i.isNumber = F, i.isString = V, i.isSymbol = function(J) {
            return typeof J == "symbol";
          }, i.isUndefined = q, i.isRegExp = I, i.isObject = _, i.isDate = R, i.isError = W, i.isFunction = O, i.isPrimitive = function(J) {
            return J === null || typeof J == "boolean" || typeof J == "number" || typeof J == "string" || typeof J == "symbol" || J === void 0;
          }, i.isBuffer = e("./support/isBuffer");
          var C = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function ae(J, te) {
            return Object.prototype.hasOwnProperty.call(J, te);
          }
          i.log = function() {
            var J, te;
            console.log("%s - %s", (J = /* @__PURE__ */ new Date(), te = [U(J.getHours()), U(J.getMinutes()), U(J.getSeconds())].join(":"), [J.getDate(), C[J.getMonth()], te].join(" ")), i.format.apply(i, arguments));
          }, i.inherits = e("inherits"), i._extend = function(J, te) {
            if (!te || !_(te))
              return J;
            for (var $ = Object.keys(te), L = $.length; L--; )
              J[$[L]] = te[$[L]];
            return J;
          };
        }).call(this);
      }).call(this, e("_process"), s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./support/isBuffer": 25, _process: 60, inherits: 24 }], 27: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = e("array-filter");
          f.exports = function() {
            return t(["BigInt64Array", "BigUint64Array", "Float32Array", "Float64Array", "Int16Array", "Int32Array", "Int8Array", "Uint16Array", "Uint32Array", "Uint8Array", "Uint8ClampedArray"], function(r) {
              return typeof a[r] == "function";
            });
          };
        }).call(this);
      }).call(this, s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "array-filter": 28 }], 28: [function(e, f, i) {
      f.exports = function(t, r, o) {
        if (t.filter)
          return t.filter(r, o);
        if (t == null)
          throw new TypeError();
        if (typeof r != "function")
          throw new TypeError();
        for (var n = [], u = 0; u < t.length; u++)
          if (a.call(t, u)) {
            var p = t[u];
            r.call(o, p, u, t) && n.push(p);
          }
        return n;
      };
      var a = Object.prototype.hasOwnProperty;
    }, {}], 29: [function(e, f, i) {
      i.byteLength = function(v) {
        var x = p(v), b = x[0], w = x[1];
        return 3 * (b + w) / 4 - w;
      }, i.toByteArray = function(v) {
        var x, b, w = p(v), M = w[0], G = w[1], F = new r(function(I, _, R) {
          return 3 * (_ + R) / 4 - R;
        }(0, M, G)), V = 0, q = G > 0 ? M - 4 : M;
        for (b = 0; b < q; b += 4)
          x = t[v.charCodeAt(b)] << 18 | t[v.charCodeAt(b + 1)] << 12 | t[v.charCodeAt(b + 2)] << 6 | t[v.charCodeAt(b + 3)], F[V++] = x >> 16 & 255, F[V++] = x >> 8 & 255, F[V++] = 255 & x;
        return G === 2 && (x = t[v.charCodeAt(b)] << 2 | t[v.charCodeAt(b + 1)] >> 4, F[V++] = 255 & x), G === 1 && (x = t[v.charCodeAt(b)] << 10 | t[v.charCodeAt(b + 1)] << 4 | t[v.charCodeAt(b + 2)] >> 2, F[V++] = x >> 8 & 255, F[V++] = 255 & x), F;
      }, i.fromByteArray = function(v) {
        for (var x, b = v.length, w = b % 3, M = [], G = 16383, F = 0, V = b - w; F < V; F += G)
          M.push(g(v, F, F + G > V ? V : F + G));
        return w === 1 ? (x = v[b - 1], M.push(a[x >> 2] + a[x << 4 & 63] + "==")) : w === 2 && (x = (v[b - 2] << 8) + v[b - 1], M.push(a[x >> 10] + a[x >> 4 & 63] + a[x << 2 & 63] + "=")), M.join("");
      };
      for (var a = [], t = [], r = typeof Uint8Array < "u" ? Uint8Array : Array, o = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/", n = 0, u = o.length; n < u; ++n)
        a[n] = o[n], t[o.charCodeAt(n)] = n;
      function p(v) {
        var x = v.length;
        if (x % 4 > 0)
          throw new Error("Invalid string. Length must be a multiple of 4");
        var b = v.indexOf("=");
        return b === -1 && (b = x), [b, b === x ? 0 : 4 - b % 4];
      }
      function g(v, x, b) {
        for (var w, M = [], G = x; G < b; G += 3)
          w = (v[G] << 16 & 16711680) + (v[G + 1] << 8 & 65280) + (255 & v[G + 2]), M.push(a[(F = w) >> 18 & 63] + a[F >> 12 & 63] + a[F >> 6 & 63] + a[63 & F]);
        var F;
        return M.join("");
      }
      t["-".charCodeAt(0)] = 62, t["_".charCodeAt(0)] = 63;
    }, {}], 30: [function(e, f, i) {
    }, {}], 31: [function(e, f, i) {
      (function(a, t) {
        (function() {
          var r = e("assert"), o = e("pako/lib/zlib/zstream"), n = e("pako/lib/zlib/deflate.js"), u = e("pako/lib/zlib/inflate.js"), p = e("pako/lib/zlib/constants");
          for (var g in p)
            i[g] = p[g];
          i.NONE = 0, i.DEFLATE = 1, i.INFLATE = 2, i.GZIP = 3, i.GUNZIP = 4, i.DEFLATERAW = 5, i.INFLATERAW = 6, i.UNZIP = 7;
          function v(x) {
            if (typeof x != "number" || x < i.DEFLATE || x > i.UNZIP)
              throw new TypeError("Bad argument");
            this.dictionary = null, this.err = 0, this.flush = 0, this.init_done = !1, this.level = 0, this.memLevel = 0, this.mode = x, this.strategy = 0, this.windowBits = 0, this.write_in_progress = !1, this.pending_close = !1, this.gzip_id_bytes_read = 0;
          }
          v.prototype.close = function() {
            this.write_in_progress ? this.pending_close = !0 : (this.pending_close = !1, r(this.init_done, "close before init"), r(this.mode <= i.UNZIP), this.mode === i.DEFLATE || this.mode === i.GZIP || this.mode === i.DEFLATERAW ? n.deflateEnd(this.strm) : this.mode !== i.INFLATE && this.mode !== i.GUNZIP && this.mode !== i.INFLATERAW && this.mode !== i.UNZIP || u.inflateEnd(this.strm), this.mode = i.NONE, this.dictionary = null);
          }, v.prototype.write = function(x, b, w, M, G, F, V) {
            return this._write(!0, x, b, w, M, G, F, V);
          }, v.prototype.writeSync = function(x, b, w, M, G, F, V) {
            return this._write(!1, x, b, w, M, G, F, V);
          }, v.prototype._write = function(x, b, w, M, G, F, V, q) {
            if (r.equal(arguments.length, 8), r(this.init_done, "write before init"), r(this.mode !== i.NONE, "already finalized"), r.equal(!1, this.write_in_progress, "write already in progress"), r.equal(!1, this.pending_close, "close is pending"), this.write_in_progress = !0, r.equal(!1, b === void 0, "must provide flush value"), this.write_in_progress = !0, b !== i.Z_NO_FLUSH && b !== i.Z_PARTIAL_FLUSH && b !== i.Z_SYNC_FLUSH && b !== i.Z_FULL_FLUSH && b !== i.Z_FINISH && b !== i.Z_BLOCK)
              throw new Error("Invalid flush value");
            if (w == null && (w = t.alloc(0), G = 0, M = 0), this.strm.avail_in = G, this.strm.input = w, this.strm.next_in = M, this.strm.avail_out = q, this.strm.output = F, this.strm.next_out = V, this.flush = b, !x)
              return this._process(), this._checkError() ? this._afterSync() : void 0;
            var I = this;
            return a.nextTick(function() {
              I._process(), I._after();
            }), this;
          }, v.prototype._afterSync = function() {
            var x = this.strm.avail_out, b = this.strm.avail_in;
            return this.write_in_progress = !1, [b, x];
          }, v.prototype._process = function() {
            var x = null;
            switch (this.mode) {
              case i.DEFLATE:
              case i.GZIP:
              case i.DEFLATERAW:
                this.err = n.deflate(this.strm, this.flush);
                break;
              case i.UNZIP:
                switch (this.strm.avail_in > 0 && (x = this.strm.next_in), this.gzip_id_bytes_read) {
                  case 0:
                    if (x === null)
                      break;
                    if (this.strm.input[x] !== 31) {
                      this.mode = i.INFLATE;
                      break;
                    }
                    if (this.gzip_id_bytes_read = 1, x++, this.strm.avail_in === 1)
                      break;
                  case 1:
                    if (x === null)
                      break;
                    this.strm.input[x] === 139 ? (this.gzip_id_bytes_read = 2, this.mode = i.GUNZIP) : this.mode = i.INFLATE;
                    break;
                  default:
                    throw new Error("invalid number of gzip magic number bytes read");
                }
              case i.INFLATE:
              case i.GUNZIP:
              case i.INFLATERAW:
                for (this.err = u.inflate(this.strm, this.flush), this.err === i.Z_NEED_DICT && this.dictionary && (this.err = u.inflateSetDictionary(this.strm, this.dictionary), this.err === i.Z_OK ? this.err = u.inflate(this.strm, this.flush) : this.err === i.Z_DATA_ERROR && (this.err = i.Z_NEED_DICT)); this.strm.avail_in > 0 && this.mode === i.GUNZIP && this.err === i.Z_STREAM_END && this.strm.next_in[0] !== 0; )
                  this.reset(), this.err = u.inflate(this.strm, this.flush);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
          }, v.prototype._checkError = function() {
            switch (this.err) {
              case i.Z_OK:
              case i.Z_BUF_ERROR:
                if (this.strm.avail_out !== 0 && this.flush === i.Z_FINISH)
                  return this._error("unexpected end of file"), !1;
                break;
              case i.Z_STREAM_END:
                break;
              case i.Z_NEED_DICT:
                return this.dictionary == null ? this._error("Missing dictionary") : this._error("Bad dictionary"), !1;
              default:
                return this._error("Zlib error"), !1;
            }
            return !0;
          }, v.prototype._after = function() {
            if (this._checkError()) {
              var x = this.strm.avail_out, b = this.strm.avail_in;
              this.write_in_progress = !1, this.callback(b, x), this.pending_close && this.close();
            }
          }, v.prototype._error = function(x) {
            this.strm.msg && (x = this.strm.msg), this.onerror(x, this.err), this.write_in_progress = !1, this.pending_close && this.close();
          }, v.prototype.init = function(x, b, w, M, G) {
            r(arguments.length === 4 || arguments.length === 5, "init(windowBits, level, memLevel, strategy, [dictionary])"), r(x >= 8 && x <= 15, "invalid windowBits"), r(b >= -1 && b <= 9, "invalid compression level"), r(w >= 1 && w <= 9, "invalid memlevel"), r(M === i.Z_FILTERED || M === i.Z_HUFFMAN_ONLY || M === i.Z_RLE || M === i.Z_FIXED || M === i.Z_DEFAULT_STRATEGY, "invalid strategy"), this._init(b, x, w, M, G), this._setDictionary();
          }, v.prototype.params = function() {
            throw new Error("deflateParams Not supported");
          }, v.prototype.reset = function() {
            this._reset(), this._setDictionary();
          }, v.prototype._init = function(x, b, w, M, G) {
            switch (this.level = x, this.windowBits = b, this.memLevel = w, this.strategy = M, this.flush = i.Z_NO_FLUSH, this.err = i.Z_OK, this.mode !== i.GZIP && this.mode !== i.GUNZIP || (this.windowBits += 16), this.mode === i.UNZIP && (this.windowBits += 32), this.mode !== i.DEFLATERAW && this.mode !== i.INFLATERAW || (this.windowBits = -1 * this.windowBits), this.strm = new o(), this.mode) {
              case i.DEFLATE:
              case i.GZIP:
              case i.DEFLATERAW:
                this.err = n.deflateInit2(this.strm, this.level, i.Z_DEFLATED, this.windowBits, this.memLevel, this.strategy);
                break;
              case i.INFLATE:
              case i.GUNZIP:
              case i.INFLATERAW:
              case i.UNZIP:
                this.err = u.inflateInit2(this.strm, this.windowBits);
                break;
              default:
                throw new Error("Unknown mode " + this.mode);
            }
            this.err !== i.Z_OK && this._error("Init error"), this.dictionary = G, this.write_in_progress = !1, this.init_done = !0;
          }, v.prototype._setDictionary = function() {
            if (this.dictionary != null) {
              switch (this.err = i.Z_OK, this.mode) {
                case i.DEFLATE:
                case i.DEFLATERAW:
                  this.err = n.deflateSetDictionary(this.strm, this.dictionary);
              }
              this.err !== i.Z_OK && this._error("Failed to set dictionary");
            }
          }, v.prototype._reset = function() {
            switch (this.err = i.Z_OK, this.mode) {
              case i.DEFLATE:
              case i.DEFLATERAW:
              case i.GZIP:
                this.err = n.deflateReset(this.strm);
                break;
              case i.INFLATE:
              case i.INFLATERAW:
              case i.GUNZIP:
                this.err = u.inflateReset(this.strm);
            }
            this.err !== i.Z_OK && this._error("Failed to reset stream");
          }, i.Zlib = v;
        }).call(this);
      }).call(this, e("_process"), e("buffer").Buffer);
    }, { _process: 60, assert: 23, buffer: 33, "pako/lib/zlib/constants": 51, "pako/lib/zlib/deflate.js": 53, "pako/lib/zlib/inflate.js": 55, "pako/lib/zlib/zstream": 59 }], 32: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = e("buffer").Buffer, r = e("stream").Transform, o = e("./binding"), n = e("util"), u = e("assert").ok, p = e("buffer").kMaxLength, g = "Cannot create final Buffer. It would be larger than 0x" + p.toString(16) + " bytes";
          o.Z_MIN_WINDOWBITS = 8, o.Z_MAX_WINDOWBITS = 15, o.Z_DEFAULT_WINDOWBITS = 15, o.Z_MIN_CHUNK = 64, o.Z_MAX_CHUNK = 1 / 0, o.Z_DEFAULT_CHUNK = 16384, o.Z_MIN_MEMLEVEL = 1, o.Z_MAX_MEMLEVEL = 9, o.Z_DEFAULT_MEMLEVEL = 8, o.Z_MIN_LEVEL = -1, o.Z_MAX_LEVEL = 9, o.Z_DEFAULT_LEVEL = o.Z_DEFAULT_COMPRESSION;
          for (var v = Object.keys(o), x = 0; x < v.length; x++) {
            var b = v[x];
            b.match(/^Z/) && Object.defineProperty(i, b, { enumerable: !0, value: o[b], writable: !1 });
          }
          for (var w = { Z_OK: o.Z_OK, Z_STREAM_END: o.Z_STREAM_END, Z_NEED_DICT: o.Z_NEED_DICT, Z_ERRNO: o.Z_ERRNO, Z_STREAM_ERROR: o.Z_STREAM_ERROR, Z_DATA_ERROR: o.Z_DATA_ERROR, Z_MEM_ERROR: o.Z_MEM_ERROR, Z_BUF_ERROR: o.Z_BUF_ERROR, Z_VERSION_ERROR: o.Z_VERSION_ERROR }, M = Object.keys(w), G = 0; G < M.length; G++) {
            var F = M[G];
            w[w[F]] = F;
          }
          function V($, L, re) {
            var z = [], N = 0;
            function ne() {
              for (var he; (he = $.read()) !== null; )
                z.push(he), N += he.length;
              $.once("readable", ne);
            }
            function le() {
              var he, k = null;
              N >= p ? k = new RangeError(g) : he = t.concat(z, N), z = [], $.close(), re(k, he);
            }
            $.on("error", function(he) {
              $.removeListener("end", le), $.removeListener("readable", ne), re(he);
            }), $.on("end", le), $.end(L), ne();
          }
          function q($, L) {
            if (typeof L == "string" && (L = t.from(L)), !t.isBuffer(L))
              throw new TypeError("Not a string or buffer");
            var re = $._finishFlushFlag;
            return $._processChunk(L, re);
          }
          function I($) {
            if (!(this instanceof I))
              return new I($);
            ae.call(this, $, o.DEFLATE);
          }
          function _($) {
            if (!(this instanceof _))
              return new _($);
            ae.call(this, $, o.INFLATE);
          }
          function R($) {
            if (!(this instanceof R))
              return new R($);
            ae.call(this, $, o.GZIP);
          }
          function W($) {
            if (!(this instanceof W))
              return new W($);
            ae.call(this, $, o.GUNZIP);
          }
          function O($) {
            if (!(this instanceof O))
              return new O($);
            ae.call(this, $, o.DEFLATERAW);
          }
          function j($) {
            if (!(this instanceof j))
              return new j($);
            ae.call(this, $, o.INFLATERAW);
          }
          function U($) {
            if (!(this instanceof U))
              return new U($);
            ae.call(this, $, o.UNZIP);
          }
          function C($) {
            return $ === o.Z_NO_FLUSH || $ === o.Z_PARTIAL_FLUSH || $ === o.Z_SYNC_FLUSH || $ === o.Z_FULL_FLUSH || $ === o.Z_FINISH || $ === o.Z_BLOCK;
          }
          function ae($, L) {
            var re = this;
            if (this._opts = $ = $ || {}, this._chunkSize = $.chunkSize || i.Z_DEFAULT_CHUNK, r.call(this, $), $.flush && !C($.flush))
              throw new Error("Invalid flush flag: " + $.flush);
            if ($.finishFlush && !C($.finishFlush))
              throw new Error("Invalid flush flag: " + $.finishFlush);
            if (this._flushFlag = $.flush || o.Z_NO_FLUSH, this._finishFlushFlag = $.finishFlush !== void 0 ? $.finishFlush : o.Z_FINISH, $.chunkSize && ($.chunkSize < i.Z_MIN_CHUNK || $.chunkSize > i.Z_MAX_CHUNK))
              throw new Error("Invalid chunk size: " + $.chunkSize);
            if ($.windowBits && ($.windowBits < i.Z_MIN_WINDOWBITS || $.windowBits > i.Z_MAX_WINDOWBITS))
              throw new Error("Invalid windowBits: " + $.windowBits);
            if ($.level && ($.level < i.Z_MIN_LEVEL || $.level > i.Z_MAX_LEVEL))
              throw new Error("Invalid compression level: " + $.level);
            if ($.memLevel && ($.memLevel < i.Z_MIN_MEMLEVEL || $.memLevel > i.Z_MAX_MEMLEVEL))
              throw new Error("Invalid memLevel: " + $.memLevel);
            if ($.strategy && $.strategy != i.Z_FILTERED && $.strategy != i.Z_HUFFMAN_ONLY && $.strategy != i.Z_RLE && $.strategy != i.Z_FIXED && $.strategy != i.Z_DEFAULT_STRATEGY)
              throw new Error("Invalid strategy: " + $.strategy);
            if ($.dictionary && !t.isBuffer($.dictionary))
              throw new Error("Invalid dictionary: it should be a Buffer instance");
            this._handle = new o.Zlib(L);
            var z = this;
            this._hadError = !1, this._handle.onerror = function(le, he) {
              J(z), z._hadError = !0;
              var k = new Error(le);
              k.errno = he, k.code = i.codes[he], z.emit("error", k);
            };
            var N = i.Z_DEFAULT_COMPRESSION;
            typeof $.level == "number" && (N = $.level);
            var ne = i.Z_DEFAULT_STRATEGY;
            typeof $.strategy == "number" && (ne = $.strategy), this._handle.init($.windowBits || i.Z_DEFAULT_WINDOWBITS, N, $.memLevel || i.Z_DEFAULT_MEMLEVEL, ne, $.dictionary), this._buffer = t.allocUnsafe(this._chunkSize), this._offset = 0, this._level = N, this._strategy = ne, this.once("end", this.close), Object.defineProperty(this, "_closed", { get: function() {
              return !re._handle;
            }, configurable: !0, enumerable: !0 });
          }
          function J($, L) {
            L && a.nextTick(L), $._handle && ($._handle.close(), $._handle = null);
          }
          function te($) {
            $.emit("close");
          }
          Object.defineProperty(i, "codes", { enumerable: !0, value: Object.freeze(w), writable: !1 }), i.Deflate = I, i.Inflate = _, i.Gzip = R, i.Gunzip = W, i.DeflateRaw = O, i.InflateRaw = j, i.Unzip = U, i.createDeflate = function($) {
            return new I($);
          }, i.createInflate = function($) {
            return new _($);
          }, i.createDeflateRaw = function($) {
            return new O($);
          }, i.createInflateRaw = function($) {
            return new j($);
          }, i.createGzip = function($) {
            return new R($);
          }, i.createGunzip = function($) {
            return new W($);
          }, i.createUnzip = function($) {
            return new U($);
          }, i.deflate = function($, L, re) {
            return typeof L == "function" && (re = L, L = {}), V(new I(L), $, re);
          }, i.deflateSync = function($, L) {
            return q(new I(L), $);
          }, i.gzip = function($, L, re) {
            return typeof L == "function" && (re = L, L = {}), V(new R(L), $, re);
          }, i.gzipSync = function($, L) {
            return q(new R(L), $);
          }, i.deflateRaw = function($, L, re) {
            return typeof L == "function" && (re = L, L = {}), V(new O(L), $, re);
          }, i.deflateRawSync = function($, L) {
            return q(new O(L), $);
          }, i.unzip = function($, L, re) {
            return typeof L == "function" && (re = L, L = {}), V(new U(L), $, re);
          }, i.unzipSync = function($, L) {
            return q(new U(L), $);
          }, i.inflate = function($, L, re) {
            return typeof L == "function" && (re = L, L = {}), V(new _(L), $, re);
          }, i.inflateSync = function($, L) {
            return q(new _(L), $);
          }, i.gunzip = function($, L, re) {
            return typeof L == "function" && (re = L, L = {}), V(new W(L), $, re);
          }, i.gunzipSync = function($, L) {
            return q(new W(L), $);
          }, i.inflateRaw = function($, L, re) {
            return typeof L == "function" && (re = L, L = {}), V(new j(L), $, re);
          }, i.inflateRawSync = function($, L) {
            return q(new j(L), $);
          }, n.inherits(ae, r), ae.prototype.params = function($, L, re) {
            if ($ < i.Z_MIN_LEVEL || $ > i.Z_MAX_LEVEL)
              throw new RangeError("Invalid compression level: " + $);
            if (L != i.Z_FILTERED && L != i.Z_HUFFMAN_ONLY && L != i.Z_RLE && L != i.Z_FIXED && L != i.Z_DEFAULT_STRATEGY)
              throw new TypeError("Invalid strategy: " + L);
            if (this._level !== $ || this._strategy !== L) {
              var z = this;
              this.flush(o.Z_SYNC_FLUSH, function() {
                u(z._handle, "zlib binding closed"), z._handle.params($, L), z._hadError || (z._level = $, z._strategy = L, re && re());
              });
            } else
              a.nextTick(re);
          }, ae.prototype.reset = function() {
            return u(this._handle, "zlib binding closed"), this._handle.reset();
          }, ae.prototype._flush = function($) {
            this._transform(t.alloc(0), "", $);
          }, ae.prototype.flush = function($, L) {
            var re = this, z = this._writableState;
            (typeof $ == "function" || $ === void 0 && !L) && (L = $, $ = o.Z_FULL_FLUSH), z.ended ? L && a.nextTick(L) : z.ending ? L && this.once("end", L) : z.needDrain ? L && this.once("drain", function() {
              return re.flush($, L);
            }) : (this._flushFlag = $, this.write(t.alloc(0), "", L));
          }, ae.prototype.close = function($) {
            J(this, $), a.nextTick(te, this);
          }, ae.prototype._transform = function($, L, re) {
            var z, N = this._writableState, ne = (N.ending || N.ended) && (!$ || N.length === $.length);
            return $ === null || t.isBuffer($) ? this._handle ? (ne ? z = this._finishFlushFlag : (z = this._flushFlag, $.length >= N.length && (this._flushFlag = this._opts.flush || o.Z_NO_FLUSH)), void this._processChunk($, z, re)) : re(new Error("zlib binding closed")) : re(new Error("invalid input"));
          }, ae.prototype._processChunk = function($, L, re) {
            var z = $ && $.length, N = this._chunkSize - this._offset, ne = 0, le = this, he = typeof re == "function";
            if (!he) {
              var k, T = [], B = 0;
              this.on("error", function(D) {
                k = D;
              }), u(this._handle, "zlib binding closed");
              do
                var K = this._handle.writeSync(L, $, ne, z, this._buffer, this._offset, N);
              while (!this._hadError && m(K[0], K[1]));
              if (this._hadError)
                throw k;
              if (B >= p)
                throw J(this), new RangeError(g);
              var h = t.concat(T, B);
              return J(this), h;
            }
            u(this._handle, "zlib binding closed");
            var c = this._handle.write(L, $, ne, z, this._buffer, this._offset, N);
            function m(D, ee) {
              if (this && (this.buffer = null, this.callback = null), !le._hadError) {
                var E = N - ee;
                if (u(E >= 0, "have should not go down"), E > 0) {
                  var Q = le._buffer.slice(le._offset, le._offset + E);
                  le._offset += E, he ? le.push(Q) : (T.push(Q), B += Q.length);
                }
                if ((ee === 0 || le._offset >= le._chunkSize) && (N = le._chunkSize, le._offset = 0, le._buffer = t.allocUnsafe(le._chunkSize)), ee === 0) {
                  if (ne += z - D, z = D, !he)
                    return !0;
                  var se = le._handle.write(L, $, ne, z, le._buffer, le._offset, le._chunkSize);
                  return se.callback = m, void (se.buffer = $);
                }
                if (!he)
                  return !1;
                re();
              }
            }
            c.buffer = $, c.callback = m;
          }, n.inherits(I, ae), n.inherits(_, ae), n.inherits(R, ae), n.inherits(W, ae), n.inherits(O, ae), n.inherits(j, ae), n.inherits(U, ae);
        }).call(this);
      }).call(this, e("_process"));
    }, { "./binding": 31, _process: 60, assert: 23, buffer: 33, stream: 61, util: 81 }], 33: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = e("base64-js"), r = e("ieee754");
          i.Buffer = u, i.SlowBuffer = function(h) {
            return +h != h && (h = 0), u.alloc(+h);
          }, i.INSPECT_MAX_BYTES = 50;
          var o = 2147483647;
          function n(h) {
            if (h > o)
              throw new RangeError('The value "' + h + '" is invalid for option "size"');
            var c = new Uint8Array(h);
            return c.__proto__ = u.prototype, c;
          }
          function u(h, c, m) {
            if (typeof h == "number") {
              if (typeof c == "string")
                throw new TypeError('The "string" argument must be of type string. Received type number');
              return v(h);
            }
            return p(h, c, m);
          }
          function p(h, c, m) {
            if (typeof h == "string")
              return function(E, Q) {
                if (typeof Q == "string" && Q !== "" || (Q = "utf8"), !u.isEncoding(Q))
                  throw new TypeError("Unknown encoding: " + Q);
                var se = 0 | w(E, Q), Y = n(se), be = Y.write(E, Q);
                return be !== se && (Y = Y.slice(0, be)), Y;
              }(h, c);
            if (ArrayBuffer.isView(h))
              return x(h);
            if (h == null)
              throw TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof h);
            if (B(h, ArrayBuffer) || h && B(h.buffer, ArrayBuffer))
              return function(E, Q, se) {
                if (Q < 0 || E.byteLength < Q)
                  throw new RangeError('"offset" is outside of buffer bounds');
                if (E.byteLength < Q + (se || 0))
                  throw new RangeError('"length" is outside of buffer bounds');
                var Y;
                return (Y = Q === void 0 && se === void 0 ? new Uint8Array(E) : se === void 0 ? new Uint8Array(E, Q) : new Uint8Array(E, Q, se)).__proto__ = u.prototype, Y;
              }(h, c, m);
            if (typeof h == "number")
              throw new TypeError('The "value" argument must not be of type number. Received type number');
            var D = h.valueOf && h.valueOf();
            if (D != null && D !== h)
              return u.from(D, c, m);
            var ee = function(E) {
              if (u.isBuffer(E)) {
                var Q = 0 | b(E.length), se = n(Q);
                return se.length === 0 || E.copy(se, 0, 0, Q), se;
              }
              return E.length !== void 0 ? typeof E.length != "number" || K(E.length) ? n(0) : x(E) : E.type === "Buffer" && Array.isArray(E.data) ? x(E.data) : void 0;
            }(h);
            if (ee)
              return ee;
            if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof h[Symbol.toPrimitive] == "function")
              return u.from(h[Symbol.toPrimitive]("string"), c, m);
            throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof h);
          }
          function g(h) {
            if (typeof h != "number")
              throw new TypeError('"size" argument must be of type number');
            if (h < 0)
              throw new RangeError('The value "' + h + '" is invalid for option "size"');
          }
          function v(h) {
            return g(h), n(h < 0 ? 0 : 0 | b(h));
          }
          function x(h) {
            for (var c = h.length < 0 ? 0 : 0 | b(h.length), m = n(c), D = 0; D < c; D += 1)
              m[D] = 255 & h[D];
            return m;
          }
          function b(h) {
            if (h >= o)
              throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + o.toString(16) + " bytes");
            return 0 | h;
          }
          function w(h, c) {
            if (u.isBuffer(h))
              return h.length;
            if (ArrayBuffer.isView(h) || B(h, ArrayBuffer))
              return h.byteLength;
            if (typeof h != "string")
              throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof h);
            var m = h.length, D = arguments.length > 2 && arguments[2] === !0;
            if (!D && m === 0)
              return 0;
            for (var ee = !1; ; )
              switch (c) {
                case "ascii":
                case "latin1":
                case "binary":
                  return m;
                case "utf8":
                case "utf-8":
                  return he(h).length;
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return 2 * m;
                case "hex":
                  return m >>> 1;
                case "base64":
                  return k(h).length;
                default:
                  if (ee)
                    return D ? -1 : he(h).length;
                  c = ("" + c).toLowerCase(), ee = !0;
              }
          }
          function M(h, c, m) {
            var D = !1;
            if ((c === void 0 || c < 0) && (c = 0), c > this.length || ((m === void 0 || m > this.length) && (m = this.length), m <= 0) || (m >>>= 0) <= (c >>>= 0))
              return "";
            for (h || (h = "utf8"); ; )
              switch (h) {
                case "hex":
                  return te(this, c, m);
                case "utf8":
                case "utf-8":
                  return U(this, c, m);
                case "ascii":
                  return ae(this, c, m);
                case "latin1":
                case "binary":
                  return J(this, c, m);
                case "base64":
                  return j(this, c, m);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return $(this, c, m);
                default:
                  if (D)
                    throw new TypeError("Unknown encoding: " + h);
                  h = (h + "").toLowerCase(), D = !0;
              }
          }
          function G(h, c, m) {
            var D = h[c];
            h[c] = h[m], h[m] = D;
          }
          function F(h, c, m, D, ee) {
            if (h.length === 0)
              return -1;
            if (typeof m == "string" ? (D = m, m = 0) : m > 2147483647 ? m = 2147483647 : m < -2147483648 && (m = -2147483648), K(m = +m) && (m = ee ? 0 : h.length - 1), m < 0 && (m = h.length + m), m >= h.length) {
              if (ee)
                return -1;
              m = h.length - 1;
            } else if (m < 0) {
              if (!ee)
                return -1;
              m = 0;
            }
            if (typeof c == "string" && (c = u.from(c, D)), u.isBuffer(c))
              return c.length === 0 ? -1 : V(h, c, m, D, ee);
            if (typeof c == "number")
              return c &= 255, typeof Uint8Array.prototype.indexOf == "function" ? ee ? Uint8Array.prototype.indexOf.call(h, c, m) : Uint8Array.prototype.lastIndexOf.call(h, c, m) : V(h, [c], m, D, ee);
            throw new TypeError("val must be string, number or Buffer");
          }
          function V(h, c, m, D, ee) {
            var E, Q = 1, se = h.length, Y = c.length;
            if (D !== void 0 && ((D = String(D).toLowerCase()) === "ucs2" || D === "ucs-2" || D === "utf16le" || D === "utf-16le")) {
              if (h.length < 2 || c.length < 2)
                return -1;
              Q = 2, se /= 2, Y /= 2, m /= 2;
            }
            function be(oe, ce) {
              return Q === 1 ? oe[ce] : oe.readUInt16BE(ce * Q);
            }
            if (ee) {
              var Ee = -1;
              for (E = m; E < se; E++)
                if (be(h, E) === be(c, Ee === -1 ? 0 : E - Ee)) {
                  if (Ee === -1 && (Ee = E), E - Ee + 1 === Y)
                    return Ee * Q;
                } else
                  Ee !== -1 && (E -= E - Ee), Ee = -1;
            } else
              for (m + Y > se && (m = se - Y), E = m; E >= 0; E--) {
                for (var Me = !0, ke = 0; ke < Y; ke++)
                  if (be(h, E + ke) !== be(c, ke)) {
                    Me = !1;
                    break;
                  }
                if (Me)
                  return E;
              }
            return -1;
          }
          function q(h, c, m, D) {
            m = Number(m) || 0;
            var ee = h.length - m;
            D ? (D = Number(D)) > ee && (D = ee) : D = ee;
            var E = c.length;
            D > E / 2 && (D = E / 2);
            for (var Q = 0; Q < D; ++Q) {
              var se = parseInt(c.substr(2 * Q, 2), 16);
              if (K(se))
                return Q;
              h[m + Q] = se;
            }
            return Q;
          }
          function I(h, c, m, D) {
            return T(he(c, h.length - m), h, m, D);
          }
          function _(h, c, m, D) {
            return T(function(ee) {
              for (var E = [], Q = 0; Q < ee.length; ++Q)
                E.push(255 & ee.charCodeAt(Q));
              return E;
            }(c), h, m, D);
          }
          function R(h, c, m, D) {
            return _(h, c, m, D);
          }
          function W(h, c, m, D) {
            return T(k(c), h, m, D);
          }
          function O(h, c, m, D) {
            return T(function(ee, E) {
              for (var Q, se, Y, be = [], Ee = 0; Ee < ee.length && !((E -= 2) < 0); ++Ee)
                se = (Q = ee.charCodeAt(Ee)) >> 8, Y = Q % 256, be.push(Y), be.push(se);
              return be;
            }(c, h.length - m), h, m, D);
          }
          function j(h, c, m) {
            return c === 0 && m === h.length ? t.fromByteArray(h) : t.fromByteArray(h.slice(c, m));
          }
          function U(h, c, m) {
            m = Math.min(h.length, m);
            for (var D = [], ee = c; ee < m; ) {
              var E, Q, se, Y, be = h[ee], Ee = null, Me = be > 239 ? 4 : be > 223 ? 3 : be > 191 ? 2 : 1;
              if (ee + Me <= m)
                switch (Me) {
                  case 1:
                    be < 128 && (Ee = be);
                    break;
                  case 2:
                    (192 & (E = h[ee + 1])) == 128 && (Y = (31 & be) << 6 | 63 & E) > 127 && (Ee = Y);
                    break;
                  case 3:
                    E = h[ee + 1], Q = h[ee + 2], (192 & E) == 128 && (192 & Q) == 128 && (Y = (15 & be) << 12 | (63 & E) << 6 | 63 & Q) > 2047 && (Y < 55296 || Y > 57343) && (Ee = Y);
                    break;
                  case 4:
                    E = h[ee + 1], Q = h[ee + 2], se = h[ee + 3], (192 & E) == 128 && (192 & Q) == 128 && (192 & se) == 128 && (Y = (15 & be) << 18 | (63 & E) << 12 | (63 & Q) << 6 | 63 & se) > 65535 && Y < 1114112 && (Ee = Y);
                }
              Ee === null ? (Ee = 65533, Me = 1) : Ee > 65535 && (Ee -= 65536, D.push(Ee >>> 10 & 1023 | 55296), Ee = 56320 | 1023 & Ee), D.push(Ee), ee += Me;
            }
            return function(ke) {
              var oe = ke.length;
              if (oe <= C)
                return String.fromCharCode.apply(String, ke);
              for (var ce = "", xe = 0; xe < oe; )
                ce += String.fromCharCode.apply(String, ke.slice(xe, xe += C));
              return ce;
            }(D);
          }
          i.kMaxLength = o, u.TYPED_ARRAY_SUPPORT = function() {
            try {
              var h = new Uint8Array(1);
              return h.__proto__ = { __proto__: Uint8Array.prototype, foo: function() {
                return 42;
              } }, h.foo() === 42;
            } catch {
              return !1;
            }
          }(), u.TYPED_ARRAY_SUPPORT || typeof console > "u" || typeof console.error != "function" || console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."), Object.defineProperty(u.prototype, "parent", { enumerable: !0, get: function() {
            if (u.isBuffer(this))
              return this.buffer;
          } }), Object.defineProperty(u.prototype, "offset", { enumerable: !0, get: function() {
            if (u.isBuffer(this))
              return this.byteOffset;
          } }), typeof Symbol < "u" && Symbol.species != null && u[Symbol.species] === u && Object.defineProperty(u, Symbol.species, { value: null, configurable: !0, enumerable: !1, writable: !1 }), u.poolSize = 8192, u.from = function(h, c, m) {
            return p(h, c, m);
          }, u.prototype.__proto__ = Uint8Array.prototype, u.__proto__ = Uint8Array, u.alloc = function(h, c, m) {
            return function(D, ee, E) {
              return g(D), D <= 0 ? n(D) : ee !== void 0 ? typeof E == "string" ? n(D).fill(ee, E) : n(D).fill(ee) : n(D);
            }(h, c, m);
          }, u.allocUnsafe = function(h) {
            return v(h);
          }, u.allocUnsafeSlow = function(h) {
            return v(h);
          }, u.isBuffer = function(h) {
            return h != null && h._isBuffer === !0 && h !== u.prototype;
          }, u.compare = function(h, c) {
            if (B(h, Uint8Array) && (h = u.from(h, h.offset, h.byteLength)), B(c, Uint8Array) && (c = u.from(c, c.offset, c.byteLength)), !u.isBuffer(h) || !u.isBuffer(c))
              throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
            if (h === c)
              return 0;
            for (var m = h.length, D = c.length, ee = 0, E = Math.min(m, D); ee < E; ++ee)
              if (h[ee] !== c[ee]) {
                m = h[ee], D = c[ee];
                break;
              }
            return m < D ? -1 : D < m ? 1 : 0;
          }, u.isEncoding = function(h) {
            switch (String(h).toLowerCase()) {
              case "hex":
              case "utf8":
              case "utf-8":
              case "ascii":
              case "latin1":
              case "binary":
              case "base64":
              case "ucs2":
              case "ucs-2":
              case "utf16le":
              case "utf-16le":
                return !0;
              default:
                return !1;
            }
          }, u.concat = function(h, c) {
            if (!Array.isArray(h))
              throw new TypeError('"list" argument must be an Array of Buffers');
            if (h.length === 0)
              return u.alloc(0);
            var m;
            if (c === void 0)
              for (c = 0, m = 0; m < h.length; ++m)
                c += h[m].length;
            var D = u.allocUnsafe(c), ee = 0;
            for (m = 0; m < h.length; ++m) {
              var E = h[m];
              if (B(E, Uint8Array) && (E = u.from(E)), !u.isBuffer(E))
                throw new TypeError('"list" argument must be an Array of Buffers');
              E.copy(D, ee), ee += E.length;
            }
            return D;
          }, u.byteLength = w, u.prototype._isBuffer = !0, u.prototype.swap16 = function() {
            var h = this.length;
            if (h % 2 != 0)
              throw new RangeError("Buffer size must be a multiple of 16-bits");
            for (var c = 0; c < h; c += 2)
              G(this, c, c + 1);
            return this;
          }, u.prototype.swap32 = function() {
            var h = this.length;
            if (h % 4 != 0)
              throw new RangeError("Buffer size must be a multiple of 32-bits");
            for (var c = 0; c < h; c += 4)
              G(this, c, c + 3), G(this, c + 1, c + 2);
            return this;
          }, u.prototype.swap64 = function() {
            var h = this.length;
            if (h % 8 != 0)
              throw new RangeError("Buffer size must be a multiple of 64-bits");
            for (var c = 0; c < h; c += 8)
              G(this, c, c + 7), G(this, c + 1, c + 6), G(this, c + 2, c + 5), G(this, c + 3, c + 4);
            return this;
          }, u.prototype.toString = function() {
            var h = this.length;
            return h === 0 ? "" : arguments.length === 0 ? U(this, 0, h) : M.apply(this, arguments);
          }, u.prototype.toLocaleString = u.prototype.toString, u.prototype.equals = function(h) {
            if (!u.isBuffer(h))
              throw new TypeError("Argument must be a Buffer");
            return this === h || u.compare(this, h) === 0;
          }, u.prototype.inspect = function() {
            var h = "", c = i.INSPECT_MAX_BYTES;
            return h = this.toString("hex", 0, c).replace(/(.{2})/g, "$1 ").trim(), this.length > c && (h += " ... "), "<Buffer " + h + ">";
          }, u.prototype.compare = function(h, c, m, D, ee) {
            if (B(h, Uint8Array) && (h = u.from(h, h.offset, h.byteLength)), !u.isBuffer(h))
              throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof h);
            if (c === void 0 && (c = 0), m === void 0 && (m = h ? h.length : 0), D === void 0 && (D = 0), ee === void 0 && (ee = this.length), c < 0 || m > h.length || D < 0 || ee > this.length)
              throw new RangeError("out of range index");
            if (D >= ee && c >= m)
              return 0;
            if (D >= ee)
              return -1;
            if (c >= m)
              return 1;
            if (this === h)
              return 0;
            for (var E = (ee >>>= 0) - (D >>>= 0), Q = (m >>>= 0) - (c >>>= 0), se = Math.min(E, Q), Y = this.slice(D, ee), be = h.slice(c, m), Ee = 0; Ee < se; ++Ee)
              if (Y[Ee] !== be[Ee]) {
                E = Y[Ee], Q = be[Ee];
                break;
              }
            return E < Q ? -1 : Q < E ? 1 : 0;
          }, u.prototype.includes = function(h, c, m) {
            return this.indexOf(h, c, m) !== -1;
          }, u.prototype.indexOf = function(h, c, m) {
            return F(this, h, c, m, !0);
          }, u.prototype.lastIndexOf = function(h, c, m) {
            return F(this, h, c, m, !1);
          }, u.prototype.write = function(h, c, m, D) {
            if (c === void 0)
              D = "utf8", m = this.length, c = 0;
            else if (m === void 0 && typeof c == "string")
              D = c, m = this.length, c = 0;
            else {
              if (!isFinite(c))
                throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
              c >>>= 0, isFinite(m) ? (m >>>= 0, D === void 0 && (D = "utf8")) : (D = m, m = void 0);
            }
            var ee = this.length - c;
            if ((m === void 0 || m > ee) && (m = ee), h.length > 0 && (m < 0 || c < 0) || c > this.length)
              throw new RangeError("Attempt to write outside buffer bounds");
            D || (D = "utf8");
            for (var E = !1; ; )
              switch (D) {
                case "hex":
                  return q(this, h, c, m);
                case "utf8":
                case "utf-8":
                  return I(this, h, c, m);
                case "ascii":
                  return _(this, h, c, m);
                case "latin1":
                case "binary":
                  return R(this, h, c, m);
                case "base64":
                  return W(this, h, c, m);
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return O(this, h, c, m);
                default:
                  if (E)
                    throw new TypeError("Unknown encoding: " + D);
                  D = ("" + D).toLowerCase(), E = !0;
              }
          }, u.prototype.toJSON = function() {
            return { type: "Buffer", data: Array.prototype.slice.call(this._arr || this, 0) };
          };
          var C = 4096;
          function ae(h, c, m) {
            var D = "";
            m = Math.min(h.length, m);
            for (var ee = c; ee < m; ++ee)
              D += String.fromCharCode(127 & h[ee]);
            return D;
          }
          function J(h, c, m) {
            var D = "";
            m = Math.min(h.length, m);
            for (var ee = c; ee < m; ++ee)
              D += String.fromCharCode(h[ee]);
            return D;
          }
          function te(h, c, m) {
            var D, ee = h.length;
            (!c || c < 0) && (c = 0), (!m || m < 0 || m > ee) && (m = ee);
            for (var E = "", Q = c; Q < m; ++Q)
              E += (D = h[Q]) < 16 ? "0" + D.toString(16) : D.toString(16);
            return E;
          }
          function $(h, c, m) {
            for (var D = h.slice(c, m), ee = "", E = 0; E < D.length; E += 2)
              ee += String.fromCharCode(D[E] + 256 * D[E + 1]);
            return ee;
          }
          function L(h, c, m) {
            if (h % 1 != 0 || h < 0)
              throw new RangeError("offset is not uint");
            if (h + c > m)
              throw new RangeError("Trying to access beyond buffer length");
          }
          function re(h, c, m, D, ee, E) {
            if (!u.isBuffer(h))
              throw new TypeError('"buffer" argument must be a Buffer instance');
            if (c > ee || c < E)
              throw new RangeError('"value" argument is out of bounds');
            if (m + D > h.length)
              throw new RangeError("Index out of range");
          }
          function z(h, c, m, D, ee, E) {
            if (m + D > h.length)
              throw new RangeError("Index out of range");
            if (m < 0)
              throw new RangeError("Index out of range");
          }
          function N(h, c, m, D, ee) {
            return c = +c, m >>>= 0, ee || z(h, 0, m, 4), r.write(h, c, m, D, 23, 4), m + 4;
          }
          function ne(h, c, m, D, ee) {
            return c = +c, m >>>= 0, ee || z(h, 0, m, 8), r.write(h, c, m, D, 52, 8), m + 8;
          }
          u.prototype.slice = function(h, c) {
            var m = this.length;
            (h = ~~h) < 0 ? (h += m) < 0 && (h = 0) : h > m && (h = m), (c = c === void 0 ? m : ~~c) < 0 ? (c += m) < 0 && (c = 0) : c > m && (c = m), c < h && (c = h);
            var D = this.subarray(h, c);
            return D.__proto__ = u.prototype, D;
          }, u.prototype.readUIntLE = function(h, c, m) {
            h >>>= 0, c >>>= 0, m || L(h, c, this.length);
            for (var D = this[h], ee = 1, E = 0; ++E < c && (ee *= 256); )
              D += this[h + E] * ee;
            return D;
          }, u.prototype.readUIntBE = function(h, c, m) {
            h >>>= 0, c >>>= 0, m || L(h, c, this.length);
            for (var D = this[h + --c], ee = 1; c > 0 && (ee *= 256); )
              D += this[h + --c] * ee;
            return D;
          }, u.prototype.readUInt8 = function(h, c) {
            return h >>>= 0, c || L(h, 1, this.length), this[h];
          }, u.prototype.readUInt16LE = function(h, c) {
            return h >>>= 0, c || L(h, 2, this.length), this[h] | this[h + 1] << 8;
          }, u.prototype.readUInt16BE = function(h, c) {
            return h >>>= 0, c || L(h, 2, this.length), this[h] << 8 | this[h + 1];
          }, u.prototype.readUInt32LE = function(h, c) {
            return h >>>= 0, c || L(h, 4, this.length), (this[h] | this[h + 1] << 8 | this[h + 2] << 16) + 16777216 * this[h + 3];
          }, u.prototype.readUInt32BE = function(h, c) {
            return h >>>= 0, c || L(h, 4, this.length), 16777216 * this[h] + (this[h + 1] << 16 | this[h + 2] << 8 | this[h + 3]);
          }, u.prototype.readIntLE = function(h, c, m) {
            h >>>= 0, c >>>= 0, m || L(h, c, this.length);
            for (var D = this[h], ee = 1, E = 0; ++E < c && (ee *= 256); )
              D += this[h + E] * ee;
            return D >= (ee *= 128) && (D -= Math.pow(2, 8 * c)), D;
          }, u.prototype.readIntBE = function(h, c, m) {
            h >>>= 0, c >>>= 0, m || L(h, c, this.length);
            for (var D = c, ee = 1, E = this[h + --D]; D > 0 && (ee *= 256); )
              E += this[h + --D] * ee;
            return E >= (ee *= 128) && (E -= Math.pow(2, 8 * c)), E;
          }, u.prototype.readInt8 = function(h, c) {
            return h >>>= 0, c || L(h, 1, this.length), 128 & this[h] ? -1 * (255 - this[h] + 1) : this[h];
          }, u.prototype.readInt16LE = function(h, c) {
            h >>>= 0, c || L(h, 2, this.length);
            var m = this[h] | this[h + 1] << 8;
            return 32768 & m ? 4294901760 | m : m;
          }, u.prototype.readInt16BE = function(h, c) {
            h >>>= 0, c || L(h, 2, this.length);
            var m = this[h + 1] | this[h] << 8;
            return 32768 & m ? 4294901760 | m : m;
          }, u.prototype.readInt32LE = function(h, c) {
            return h >>>= 0, c || L(h, 4, this.length), this[h] | this[h + 1] << 8 | this[h + 2] << 16 | this[h + 3] << 24;
          }, u.prototype.readInt32BE = function(h, c) {
            return h >>>= 0, c || L(h, 4, this.length), this[h] << 24 | this[h + 1] << 16 | this[h + 2] << 8 | this[h + 3];
          }, u.prototype.readFloatLE = function(h, c) {
            return h >>>= 0, c || L(h, 4, this.length), r.read(this, h, !0, 23, 4);
          }, u.prototype.readFloatBE = function(h, c) {
            return h >>>= 0, c || L(h, 4, this.length), r.read(this, h, !1, 23, 4);
          }, u.prototype.readDoubleLE = function(h, c) {
            return h >>>= 0, c || L(h, 8, this.length), r.read(this, h, !0, 52, 8);
          }, u.prototype.readDoubleBE = function(h, c) {
            return h >>>= 0, c || L(h, 8, this.length), r.read(this, h, !1, 52, 8);
          }, u.prototype.writeUIntLE = function(h, c, m, D) {
            h = +h, c >>>= 0, m >>>= 0, D || re(this, h, c, m, Math.pow(2, 8 * m) - 1, 0);
            var ee = 1, E = 0;
            for (this[c] = 255 & h; ++E < m && (ee *= 256); )
              this[c + E] = h / ee & 255;
            return c + m;
          }, u.prototype.writeUIntBE = function(h, c, m, D) {
            h = +h, c >>>= 0, m >>>= 0, D || re(this, h, c, m, Math.pow(2, 8 * m) - 1, 0);
            var ee = m - 1, E = 1;
            for (this[c + ee] = 255 & h; --ee >= 0 && (E *= 256); )
              this[c + ee] = h / E & 255;
            return c + m;
          }, u.prototype.writeUInt8 = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 1, 255, 0), this[c] = 255 & h, c + 1;
          }, u.prototype.writeUInt16LE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 2, 65535, 0), this[c] = 255 & h, this[c + 1] = h >>> 8, c + 2;
          }, u.prototype.writeUInt16BE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 2, 65535, 0), this[c] = h >>> 8, this[c + 1] = 255 & h, c + 2;
          }, u.prototype.writeUInt32LE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 4, 4294967295, 0), this[c + 3] = h >>> 24, this[c + 2] = h >>> 16, this[c + 1] = h >>> 8, this[c] = 255 & h, c + 4;
          }, u.prototype.writeUInt32BE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 4, 4294967295, 0), this[c] = h >>> 24, this[c + 1] = h >>> 16, this[c + 2] = h >>> 8, this[c + 3] = 255 & h, c + 4;
          }, u.prototype.writeIntLE = function(h, c, m, D) {
            if (h = +h, c >>>= 0, !D) {
              var ee = Math.pow(2, 8 * m - 1);
              re(this, h, c, m, ee - 1, -ee);
            }
            var E = 0, Q = 1, se = 0;
            for (this[c] = 255 & h; ++E < m && (Q *= 256); )
              h < 0 && se === 0 && this[c + E - 1] !== 0 && (se = 1), this[c + E] = (h / Q >> 0) - se & 255;
            return c + m;
          }, u.prototype.writeIntBE = function(h, c, m, D) {
            if (h = +h, c >>>= 0, !D) {
              var ee = Math.pow(2, 8 * m - 1);
              re(this, h, c, m, ee - 1, -ee);
            }
            var E = m - 1, Q = 1, se = 0;
            for (this[c + E] = 255 & h; --E >= 0 && (Q *= 256); )
              h < 0 && se === 0 && this[c + E + 1] !== 0 && (se = 1), this[c + E] = (h / Q >> 0) - se & 255;
            return c + m;
          }, u.prototype.writeInt8 = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 1, 127, -128), h < 0 && (h = 255 + h + 1), this[c] = 255 & h, c + 1;
          }, u.prototype.writeInt16LE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 2, 32767, -32768), this[c] = 255 & h, this[c + 1] = h >>> 8, c + 2;
          }, u.prototype.writeInt16BE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 2, 32767, -32768), this[c] = h >>> 8, this[c + 1] = 255 & h, c + 2;
          }, u.prototype.writeInt32LE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 4, 2147483647, -2147483648), this[c] = 255 & h, this[c + 1] = h >>> 8, this[c + 2] = h >>> 16, this[c + 3] = h >>> 24, c + 4;
          }, u.prototype.writeInt32BE = function(h, c, m) {
            return h = +h, c >>>= 0, m || re(this, h, c, 4, 2147483647, -2147483648), h < 0 && (h = 4294967295 + h + 1), this[c] = h >>> 24, this[c + 1] = h >>> 16, this[c + 2] = h >>> 8, this[c + 3] = 255 & h, c + 4;
          }, u.prototype.writeFloatLE = function(h, c, m) {
            return N(this, h, c, !0, m);
          }, u.prototype.writeFloatBE = function(h, c, m) {
            return N(this, h, c, !1, m);
          }, u.prototype.writeDoubleLE = function(h, c, m) {
            return ne(this, h, c, !0, m);
          }, u.prototype.writeDoubleBE = function(h, c, m) {
            return ne(this, h, c, !1, m);
          }, u.prototype.copy = function(h, c, m, D) {
            if (!u.isBuffer(h))
              throw new TypeError("argument should be a Buffer");
            if (m || (m = 0), D || D === 0 || (D = this.length), c >= h.length && (c = h.length), c || (c = 0), D > 0 && D < m && (D = m), D === m || h.length === 0 || this.length === 0)
              return 0;
            if (c < 0)
              throw new RangeError("targetStart out of bounds");
            if (m < 0 || m >= this.length)
              throw new RangeError("Index out of range");
            if (D < 0)
              throw new RangeError("sourceEnd out of bounds");
            D > this.length && (D = this.length), h.length - c < D - m && (D = h.length - c + m);
            var ee = D - m;
            if (this === h && typeof Uint8Array.prototype.copyWithin == "function")
              this.copyWithin(c, m, D);
            else if (this === h && m < c && c < D)
              for (var E = ee - 1; E >= 0; --E)
                h[E + c] = this[E + m];
            else
              Uint8Array.prototype.set.call(h, this.subarray(m, D), c);
            return ee;
          }, u.prototype.fill = function(h, c, m, D) {
            if (typeof h == "string") {
              if (typeof c == "string" ? (D = c, c = 0, m = this.length) : typeof m == "string" && (D = m, m = this.length), D !== void 0 && typeof D != "string")
                throw new TypeError("encoding must be a string");
              if (typeof D == "string" && !u.isEncoding(D))
                throw new TypeError("Unknown encoding: " + D);
              if (h.length === 1) {
                var ee = h.charCodeAt(0);
                (D === "utf8" && ee < 128 || D === "latin1") && (h = ee);
              }
            } else
              typeof h == "number" && (h &= 255);
            if (c < 0 || this.length < c || this.length < m)
              throw new RangeError("Out of range index");
            if (m <= c)
              return this;
            var E;
            if (c >>>= 0, m = m === void 0 ? this.length : m >>> 0, h || (h = 0), typeof h == "number")
              for (E = c; E < m; ++E)
                this[E] = h;
            else {
              var Q = u.isBuffer(h) ? h : u.from(h, D), se = Q.length;
              if (se === 0)
                throw new TypeError('The value "' + h + '" is invalid for argument "value"');
              for (E = 0; E < m - c; ++E)
                this[E + c] = Q[E % se];
            }
            return this;
          };
          var le = /[^+/0-9A-Za-z-_]/g;
          function he(h, c) {
            var m;
            c = c || 1 / 0;
            for (var D = h.length, ee = null, E = [], Q = 0; Q < D; ++Q) {
              if ((m = h.charCodeAt(Q)) > 55295 && m < 57344) {
                if (!ee) {
                  if (m > 56319) {
                    (c -= 3) > -1 && E.push(239, 191, 189);
                    continue;
                  }
                  if (Q + 1 === D) {
                    (c -= 3) > -1 && E.push(239, 191, 189);
                    continue;
                  }
                  ee = m;
                  continue;
                }
                if (m < 56320) {
                  (c -= 3) > -1 && E.push(239, 191, 189), ee = m;
                  continue;
                }
                m = 65536 + (ee - 55296 << 10 | m - 56320);
              } else
                ee && (c -= 3) > -1 && E.push(239, 191, 189);
              if (ee = null, m < 128) {
                if ((c -= 1) < 0)
                  break;
                E.push(m);
              } else if (m < 2048) {
                if ((c -= 2) < 0)
                  break;
                E.push(m >> 6 | 192, 63 & m | 128);
              } else if (m < 65536) {
                if ((c -= 3) < 0)
                  break;
                E.push(m >> 12 | 224, m >> 6 & 63 | 128, 63 & m | 128);
              } else {
                if (!(m < 1114112))
                  throw new Error("Invalid code point");
                if ((c -= 4) < 0)
                  break;
                E.push(m >> 18 | 240, m >> 12 & 63 | 128, m >> 6 & 63 | 128, 63 & m | 128);
              }
            }
            return E;
          }
          function k(h) {
            return t.toByteArray(function(c) {
              if ((c = (c = c.split("=")[0]).trim().replace(le, "")).length < 2)
                return "";
              for (; c.length % 4 != 0; )
                c += "=";
              return c;
            }(h));
          }
          function T(h, c, m, D) {
            for (var ee = 0; ee < D && !(ee + m >= c.length || ee >= h.length); ++ee)
              c[ee + m] = h[ee];
            return ee;
          }
          function B(h, c) {
            return h instanceof c || h != null && h.constructor != null && h.constructor.name != null && h.constructor.name === c.name;
          }
          function K(h) {
            return h != h;
          }
        }).call(this);
      }).call(this, e("buffer").Buffer);
    }, { "base64-js": 29, buffer: 33, ieee754: 44 }], 34: [function(e, f, i) {
      var a, t = TypeError, r = Object.getOwnPropertyDescriptor;
      if (r)
        try {
          r({}, "");
        } catch {
          r = null;
        }
      var o = function() {
        throw new t();
      }, n = r ? function() {
        try {
          return o;
        } catch {
          try {
            return r(arguments, "callee").get;
          } catch {
            return o;
          }
        }
      }() : o, u = e("has-symbols")(), p = Object.getPrototypeOf || function(I) {
        return I.__proto__;
      }, g = a, v = a, x = a, b = typeof Uint8Array > "u" ? a : p(Uint8Array), w = { "%Array%": Array, "%ArrayBuffer%": typeof ArrayBuffer > "u" ? a : ArrayBuffer, "%ArrayBufferPrototype%": typeof ArrayBuffer > "u" ? a : ArrayBuffer.prototype, "%ArrayIteratorPrototype%": u ? p([][Symbol.iterator]()) : a, "%ArrayPrototype%": Array.prototype, "%ArrayProto_entries%": Array.prototype.entries, "%ArrayProto_forEach%": Array.prototype.forEach, "%ArrayProto_keys%": Array.prototype.keys, "%ArrayProto_values%": Array.prototype.values, "%AsyncFromSyncIteratorPrototype%": a, "%AsyncFunction%": v, "%AsyncFunctionPrototype%": a, "%AsyncGenerator%": a, "%AsyncGeneratorFunction%": x, "%AsyncGeneratorPrototype%": a, "%AsyncIteratorPrototype%": a, "%Atomics%": typeof Atomics > "u" ? a : Atomics, "%Boolean%": Boolean, "%BooleanPrototype%": Boolean.prototype, "%DataView%": typeof DataView > "u" ? a : DataView, "%DataViewPrototype%": typeof DataView > "u" ? a : DataView.prototype, "%Date%": Date, "%DatePrototype%": Date.prototype, "%decodeURI%": decodeURI, "%decodeURIComponent%": decodeURIComponent, "%encodeURI%": encodeURI, "%encodeURIComponent%": encodeURIComponent, "%Error%": Error, "%ErrorPrototype%": Error.prototype, "%eval%": eval, "%EvalError%": EvalError, "%EvalErrorPrototype%": EvalError.prototype, "%Float32Array%": typeof Float32Array > "u" ? a : Float32Array, "%Float32ArrayPrototype%": typeof Float32Array > "u" ? a : Float32Array.prototype, "%Float64Array%": typeof Float64Array > "u" ? a : Float64Array, "%Float64ArrayPrototype%": typeof Float64Array > "u" ? a : Float64Array.prototype, "%Function%": Function, "%FunctionPrototype%": Function.prototype, "%Generator%": a, "%GeneratorFunction%": g, "%GeneratorPrototype%": a, "%Int8Array%": typeof Int8Array > "u" ? a : Int8Array, "%Int8ArrayPrototype%": typeof Int8Array > "u" ? a : Int8Array.prototype, "%Int16Array%": typeof Int16Array > "u" ? a : Int16Array, "%Int16ArrayPrototype%": typeof Int16Array > "u" ? a : Int8Array.prototype, "%Int32Array%": typeof Int32Array > "u" ? a : Int32Array, "%Int32ArrayPrototype%": typeof Int32Array > "u" ? a : Int32Array.prototype, "%isFinite%": isFinite, "%isNaN%": isNaN, "%IteratorPrototype%": u ? p(p([][Symbol.iterator]())) : a, "%JSON%": typeof JSON == "object" ? JSON : a, "%JSONParse%": typeof JSON == "object" ? JSON.parse : a, "%Map%": typeof Map > "u" ? a : Map, "%MapIteratorPrototype%": typeof Map < "u" && u ? p((/* @__PURE__ */ new Map())[Symbol.iterator]()) : a, "%MapPrototype%": typeof Map > "u" ? a : Map.prototype, "%Math%": Math, "%Number%": Number, "%NumberPrototype%": Number.prototype, "%Object%": Object, "%ObjectPrototype%": Object.prototype, "%ObjProto_toString%": Object.prototype.toString, "%ObjProto_valueOf%": Object.prototype.valueOf, "%parseFloat%": parseFloat, "%parseInt%": parseInt, "%Promise%": typeof Promise > "u" ? a : Promise, "%PromisePrototype%": typeof Promise > "u" ? a : Promise.prototype, "%PromiseProto_then%": typeof Promise > "u" ? a : Promise.prototype.then, "%Promise_all%": typeof Promise > "u" ? a : Promise.all, "%Promise_reject%": typeof Promise > "u" ? a : Promise.reject, "%Promise_resolve%": typeof Promise > "u" ? a : Promise.resolve, "%Proxy%": typeof Proxy > "u" ? a : Proxy, "%RangeError%": RangeError, "%RangeErrorPrototype%": RangeError.prototype, "%ReferenceError%": ReferenceError, "%ReferenceErrorPrototype%": ReferenceError.prototype, "%Reflect%": typeof Reflect > "u" ? a : Reflect, "%RegExp%": RegExp, "%RegExpPrototype%": RegExp.prototype, "%Set%": typeof Set > "u" ? a : Set, "%SetIteratorPrototype%": typeof Set < "u" && u ? p((/* @__PURE__ */ new Set())[Symbol.iterator]()) : a, "%SetPrototype%": typeof Set > "u" ? a : Set.prototype, "%SharedArrayBuffer%": typeof SharedArrayBuffer > "u" ? a : SharedArrayBuffer, "%SharedArrayBufferPrototype%": typeof SharedArrayBuffer > "u" ? a : SharedArrayBuffer.prototype, "%String%": String, "%StringIteratorPrototype%": u ? p(""[Symbol.iterator]()) : a, "%StringPrototype%": String.prototype, "%Symbol%": u ? Symbol : a, "%SymbolPrototype%": u ? Symbol.prototype : a, "%SyntaxError%": SyntaxError, "%SyntaxErrorPrototype%": SyntaxError.prototype, "%ThrowTypeError%": n, "%TypedArray%": b, "%TypedArrayPrototype%": b ? b.prototype : a, "%TypeError%": t, "%TypeErrorPrototype%": t.prototype, "%Uint8Array%": typeof Uint8Array > "u" ? a : Uint8Array, "%Uint8ArrayPrototype%": typeof Uint8Array > "u" ? a : Uint8Array.prototype, "%Uint8ClampedArray%": typeof Uint8ClampedArray > "u" ? a : Uint8ClampedArray, "%Uint8ClampedArrayPrototype%": typeof Uint8ClampedArray > "u" ? a : Uint8ClampedArray.prototype, "%Uint16Array%": typeof Uint16Array > "u" ? a : Uint16Array, "%Uint16ArrayPrototype%": typeof Uint16Array > "u" ? a : Uint16Array.prototype, "%Uint32Array%": typeof Uint32Array > "u" ? a : Uint32Array, "%Uint32ArrayPrototype%": typeof Uint32Array > "u" ? a : Uint32Array.prototype, "%URIError%": URIError, "%URIErrorPrototype%": URIError.prototype, "%WeakMap%": typeof WeakMap > "u" ? a : WeakMap, "%WeakMapPrototype%": typeof WeakMap > "u" ? a : WeakMap.prototype, "%WeakSet%": typeof WeakSet > "u" ? a : WeakSet, "%WeakSetPrototype%": typeof WeakSet > "u" ? a : WeakSet.prototype }, M = e("function-bind").call(Function.call, String.prototype.replace), G = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g, F = /\\(\\)?/g, V = function(I) {
        var _ = [];
        return M(I, G, function(R, W, O, j) {
          _[_.length] = O ? M(j, F, "$1") : W || R;
        }), _;
      }, q = function(I, _) {
        if (!(I in w))
          throw new SyntaxError("intrinsic " + I + " does not exist!");
        if (w[I] === void 0 && !_)
          throw new t("intrinsic " + I + " exists, but is not available. Please file an issue!");
        return w[I];
      };
      f.exports = function(I, _) {
        if (typeof I != "string" || I.length === 0)
          throw new TypeError("intrinsic name must be a non-empty string");
        if (arguments.length > 1 && typeof _ != "boolean")
          throw new TypeError('"allowMissing" argument must be a boolean');
        for (var R = V(I), W = q("%" + (R.length > 0 ? R[0] : "") + "%", _), O = 1; O < R.length; O += 1)
          if (W != null)
            if (r && O + 1 >= R.length) {
              var j = r(W, R[O]);
              if (!_ && !(R[O] in W))
                throw new t("base intrinsic for " + I + " exists, but the property is not available.");
              W = j ? j.get || j.value : W[R[O]];
            } else
              W = W[R[O]];
        return W;
      };
    }, { "function-bind": 41, "has-symbols": 42 }], 35: [function(e, f, i) {
      var a = e("function-bind"), t = e("../GetIntrinsic")("%Function%"), r = t.apply, o = t.call;
      f.exports = function() {
        return a.apply(o, arguments);
      }, f.exports.apply = function() {
        return a.apply(r, arguments);
      };
    }, { "../GetIntrinsic": 34, "function-bind": 41 }], 36: [function(e, f, i) {
      var a = e("../GetIntrinsic"), t = e("./callBind"), r = t(a("String.prototype.indexOf"));
      f.exports = function(o, n) {
        var u = a(o, !!n);
        return typeof u == "function" && r(o, ".prototype.") ? t(u) : u;
      };
    }, { "../GetIntrinsic": 34, "./callBind": 35 }], 37: [function(e, f, i) {
      var a = e("../GetIntrinsic")("%Object.getOwnPropertyDescriptor%");
      if (a)
        try {
          a([], "length");
        } catch {
          a = null;
        }
      f.exports = a;
    }, { "../GetIntrinsic": 34 }], 38: [function(e, f, i) {
      var a, t = typeof Reflect == "object" ? Reflect : null, r = t && typeof t.apply == "function" ? t.apply : function(F, V, q) {
        return Function.prototype.apply.call(F, V, q);
      };
      a = t && typeof t.ownKeys == "function" ? t.ownKeys : Object.getOwnPropertySymbols ? function(F) {
        return Object.getOwnPropertyNames(F).concat(Object.getOwnPropertySymbols(F));
      } : function(F) {
        return Object.getOwnPropertyNames(F);
      };
      var o = Number.isNaN || function(F) {
        return F != F;
      };
      function n() {
        n.init.call(this);
      }
      f.exports = n, f.exports.once = function(F, V) {
        return new Promise(function(q, I) {
          function _() {
            R !== void 0 && F.removeListener("error", R), q([].slice.call(arguments));
          }
          var R;
          V !== "error" && (R = function(W) {
            F.removeListener(V, _), I(W);
          }, F.once("error", R)), F.once(V, _);
        });
      }, n.EventEmitter = n, n.prototype._events = void 0, n.prototype._eventsCount = 0, n.prototype._maxListeners = void 0;
      var u = 10;
      function p(F) {
        if (typeof F != "function")
          throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof F);
      }
      function g(F) {
        return F._maxListeners === void 0 ? n.defaultMaxListeners : F._maxListeners;
      }
      function v(F, V, q, I) {
        var _, R, W, O;
        if (p(q), (R = F._events) === void 0 ? (R = F._events = /* @__PURE__ */ Object.create(null), F._eventsCount = 0) : (R.newListener !== void 0 && (F.emit("newListener", V, q.listener ? q.listener : q), R = F._events), W = R[V]), W === void 0)
          W = R[V] = q, ++F._eventsCount;
        else if (typeof W == "function" ? W = R[V] = I ? [q, W] : [W, q] : I ? W.unshift(q) : W.push(q), (_ = g(F)) > 0 && W.length > _ && !W.warned) {
          W.warned = !0;
          var j = new Error("Possible EventEmitter memory leak detected. " + W.length + " " + String(V) + " listeners added. Use emitter.setMaxListeners() to increase limit");
          j.name = "MaxListenersExceededWarning", j.emitter = F, j.type = V, j.count = W.length, O = j, console && console.warn && console.warn(O);
        }
        return F;
      }
      function x() {
        if (!this.fired)
          return this.target.removeListener(this.type, this.wrapFn), this.fired = !0, arguments.length === 0 ? this.listener.call(this.target) : this.listener.apply(this.target, arguments);
      }
      function b(F, V, q) {
        var I = { fired: !1, wrapFn: void 0, target: F, type: V, listener: q }, _ = x.bind(I);
        return _.listener = q, I.wrapFn = _, _;
      }
      function w(F, V, q) {
        var I = F._events;
        if (I === void 0)
          return [];
        var _ = I[V];
        return _ === void 0 ? [] : typeof _ == "function" ? q ? [_.listener || _] : [_] : q ? function(R) {
          for (var W = new Array(R.length), O = 0; O < W.length; ++O)
            W[O] = R[O].listener || R[O];
          return W;
        }(_) : G(_, _.length);
      }
      function M(F) {
        var V = this._events;
        if (V !== void 0) {
          var q = V[F];
          if (typeof q == "function")
            return 1;
          if (q !== void 0)
            return q.length;
        }
        return 0;
      }
      function G(F, V) {
        for (var q = new Array(V), I = 0; I < V; ++I)
          q[I] = F[I];
        return q;
      }
      Object.defineProperty(n, "defaultMaxListeners", { enumerable: !0, get: function() {
        return u;
      }, set: function(F) {
        if (typeof F != "number" || F < 0 || o(F))
          throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + F + ".");
        u = F;
      } }), n.init = function() {
        this._events !== void 0 && this._events !== Object.getPrototypeOf(this)._events || (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0), this._maxListeners = this._maxListeners || void 0;
      }, n.prototype.setMaxListeners = function(F) {
        if (typeof F != "number" || F < 0 || o(F))
          throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + F + ".");
        return this._maxListeners = F, this;
      }, n.prototype.getMaxListeners = function() {
        return g(this);
      }, n.prototype.emit = function(F) {
        for (var V = [], q = 1; q < arguments.length; q++)
          V.push(arguments[q]);
        var I = F === "error", _ = this._events;
        if (_ !== void 0)
          I = I && _.error === void 0;
        else if (!I)
          return !1;
        if (I) {
          var R;
          if (V.length > 0 && (R = V[0]), R instanceof Error)
            throw R;
          var W = new Error("Unhandled error." + (R ? " (" + R.message + ")" : ""));
          throw W.context = R, W;
        }
        var O = _[F];
        if (O === void 0)
          return !1;
        if (typeof O == "function")
          r(O, this, V);
        else {
          var j = O.length, U = G(O, j);
          for (q = 0; q < j; ++q)
            r(U[q], this, V);
        }
        return !0;
      }, n.prototype.addListener = function(F, V) {
        return v(this, F, V, !1);
      }, n.prototype.on = n.prototype.addListener, n.prototype.prependListener = function(F, V) {
        return v(this, F, V, !0);
      }, n.prototype.once = function(F, V) {
        return p(V), this.on(F, b(this, F, V)), this;
      }, n.prototype.prependOnceListener = function(F, V) {
        return p(V), this.prependListener(F, b(this, F, V)), this;
      }, n.prototype.removeListener = function(F, V) {
        var q, I, _, R, W;
        if (p(V), (I = this._events) === void 0)
          return this;
        if ((q = I[F]) === void 0)
          return this;
        if (q === V || q.listener === V)
          --this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : (delete I[F], I.removeListener && this.emit("removeListener", F, q.listener || V));
        else if (typeof q != "function") {
          for (_ = -1, R = q.length - 1; R >= 0; R--)
            if (q[R] === V || q[R].listener === V) {
              W = q[R].listener, _ = R;
              break;
            }
          if (_ < 0)
            return this;
          _ === 0 ? q.shift() : function(O, j) {
            for (; j + 1 < O.length; j++)
              O[j] = O[j + 1];
            O.pop();
          }(q, _), q.length === 1 && (I[F] = q[0]), I.removeListener !== void 0 && this.emit("removeListener", F, W || V);
        }
        return this;
      }, n.prototype.off = n.prototype.removeListener, n.prototype.removeAllListeners = function(F) {
        var V, q, I;
        if ((q = this._events) === void 0)
          return this;
        if (q.removeListener === void 0)
          return arguments.length === 0 ? (this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0) : q[F] !== void 0 && (--this._eventsCount == 0 ? this._events = /* @__PURE__ */ Object.create(null) : delete q[F]), this;
        if (arguments.length === 0) {
          var _, R = Object.keys(q);
          for (I = 0; I < R.length; ++I)
            (_ = R[I]) !== "removeListener" && this.removeAllListeners(_);
          return this.removeAllListeners("removeListener"), this._events = /* @__PURE__ */ Object.create(null), this._eventsCount = 0, this;
        }
        if (typeof (V = q[F]) == "function")
          this.removeListener(F, V);
        else if (V !== void 0)
          for (I = V.length - 1; I >= 0; I--)
            this.removeListener(F, V[I]);
        return this;
      }, n.prototype.listeners = function(F) {
        return w(this, F, !0);
      }, n.prototype.rawListeners = function(F) {
        return w(this, F, !1);
      }, n.listenerCount = function(F, V) {
        return typeof F.listenerCount == "function" ? F.listenerCount(V) : M.call(F, V);
      }, n.prototype.listenerCount = M, n.prototype.eventNames = function() {
        return this._eventsCount > 0 ? a(this._events) : [];
      };
    }, {}], 39: [function(e, f, i) {
      var a = Object.prototype.hasOwnProperty, t = Object.prototype.toString;
      f.exports = function(r, o, n) {
        if (t.call(o) !== "[object Function]")
          throw new TypeError("iterator must be a function");
        var u = r.length;
        if (u === +u)
          for (var p = 0; p < u; p++)
            o.call(n, r[p], p, r);
        else
          for (var g in r)
            a.call(r, g) && o.call(n, r[g], g, r);
      };
    }, {}], 40: [function(e, f, i) {
      var a = "Function.prototype.bind called on incompatible ", t = Array.prototype.slice, r = Object.prototype.toString, o = "[object Function]";
      f.exports = function(n) {
        var u = this;
        if (typeof u != "function" || r.call(u) !== o)
          throw new TypeError(a + u);
        for (var p, g = t.call(arguments, 1), v = Math.max(0, u.length - g.length), x = [], b = 0; b < v; b++)
          x.push("$" + b);
        if (p = Function("binder", "return function (" + x.join(",") + "){ return binder.apply(this,arguments); }")(function() {
          if (this instanceof p) {
            var M = u.apply(this, g.concat(t.call(arguments)));
            return Object(M) === M ? M : this;
          }
          return u.apply(n, g.concat(t.call(arguments)));
        }), u.prototype) {
          var w = function() {
          };
          w.prototype = u.prototype, p.prototype = new w(), w.prototype = null;
        }
        return p;
      };
    }, {}], 41: [function(e, f, i) {
      var a = e("./implementation");
      f.exports = Function.prototype.bind || a;
    }, { "./implementation": 40 }], 42: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = a.Symbol, r = e("./shams");
          f.exports = function() {
            return typeof t == "function" && typeof Symbol == "function" && typeof t("foo") == "symbol" && typeof Symbol("bar") == "symbol" && r();
          };
        }).call(this);
      }).call(this, s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "./shams": 43 }], 43: [function(e, f, i) {
      f.exports = function() {
        if (typeof Symbol != "function" || typeof Object.getOwnPropertySymbols != "function")
          return !1;
        if (typeof Symbol.iterator == "symbol")
          return !0;
        var a = {}, t = Symbol("test"), r = Object(t);
        if (typeof t == "string" || Object.prototype.toString.call(t) !== "[object Symbol]" || Object.prototype.toString.call(r) !== "[object Symbol]")
          return !1;
        for (t in a[t] = 42, a)
          return !1;
        if (typeof Object.keys == "function" && Object.keys(a).length !== 0 || typeof Object.getOwnPropertyNames == "function" && Object.getOwnPropertyNames(a).length !== 0)
          return !1;
        var o = Object.getOwnPropertySymbols(a);
        if (o.length !== 1 || o[0] !== t || !Object.prototype.propertyIsEnumerable.call(a, t))
          return !1;
        if (typeof Object.getOwnPropertyDescriptor == "function") {
          var n = Object.getOwnPropertyDescriptor(a, t);
          if (n.value !== 42 || n.enumerable !== !0)
            return !1;
        }
        return !0;
      };
    }, {}], 44: [function(e, f, i) {
      i.read = function(a, t, r, o, n) {
        var u, p, g = 8 * n - o - 1, v = (1 << g) - 1, x = v >> 1, b = -7, w = r ? n - 1 : 0, M = r ? -1 : 1, G = a[t + w];
        for (w += M, u = G & (1 << -b) - 1, G >>= -b, b += g; b > 0; u = 256 * u + a[t + w], w += M, b -= 8)
          ;
        for (p = u & (1 << -b) - 1, u >>= -b, b += o; b > 0; p = 256 * p + a[t + w], w += M, b -= 8)
          ;
        if (u === 0)
          u = 1 - x;
        else {
          if (u === v)
            return p ? NaN : 1 / 0 * (G ? -1 : 1);
          p += Math.pow(2, o), u -= x;
        }
        return (G ? -1 : 1) * p * Math.pow(2, u - o);
      }, i.write = function(a, t, r, o, n, u) {
        var p, g, v, x = 8 * u - n - 1, b = (1 << x) - 1, w = b >> 1, M = n === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, G = o ? 0 : u - 1, F = o ? 1 : -1, V = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
        for (t = Math.abs(t), isNaN(t) || t === 1 / 0 ? (g = isNaN(t) ? 1 : 0, p = b) : (p = Math.floor(Math.log(t) / Math.LN2), t * (v = Math.pow(2, -p)) < 1 && (p--, v *= 2), (t += p + w >= 1 ? M / v : M * Math.pow(2, 1 - w)) * v >= 2 && (p++, v /= 2), p + w >= b ? (g = 0, p = b) : p + w >= 1 ? (g = (t * v - 1) * Math.pow(2, n), p += w) : (g = t * Math.pow(2, w - 1) * Math.pow(2, n), p = 0)); n >= 8; a[r + G] = 255 & g, G += F, g /= 256, n -= 8)
          ;
        for (p = p << n | g, x += n; x > 0; a[r + G] = 255 & p, G += F, p /= 256, x -= 8)
          ;
        a[r + G - F] |= 128 * V;
      };
    }, {}], 45: [function(e, f, i) {
      typeof Object.create == "function" ? f.exports = function(a, t) {
        t && (a.super_ = t, a.prototype = Object.create(t.prototype, { constructor: { value: a, enumerable: !1, writable: !0, configurable: !0 } }));
      } : f.exports = function(a, t) {
        if (t) {
          a.super_ = t;
          var r = function() {
          };
          r.prototype = t.prototype, a.prototype = new r(), a.prototype.constructor = a;
        }
      };
    }, {}], 46: [function(e, f, i) {
      var a = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol", t = Object.prototype.toString, r = function(u) {
        return !(a && u && typeof u == "object" && Symbol.toStringTag in u) && t.call(u) === "[object Arguments]";
      }, o = function(u) {
        return !!r(u) || u !== null && typeof u == "object" && typeof u.length == "number" && u.length >= 0 && t.call(u) !== "[object Array]" && t.call(u.callee) === "[object Function]";
      }, n = function() {
        return r(arguments);
      }();
      r.isLegacyArguments = o, f.exports = n ? r : o;
    }, {}], 47: [function(e, f, i) {
      var a = Object.prototype.toString, t = Function.prototype.toString, r = /^\s*(?:function)?\*/, o = typeof Symbol == "function" && typeof Symbol.toStringTag == "symbol", n = Object.getPrototypeOf, u = function() {
        if (!o)
          return !1;
        try {
          return Function("return function*() {}")();
        } catch {
        }
      }(), p = u ? n(u) : {};
      f.exports = function(g) {
        return typeof g == "function" && (!!r.test(t.call(g)) || (o ? n(g) === p : a.call(g) === "[object GeneratorFunction]"));
      };
    }, {}], 48: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = e("foreach"), r = e("available-typed-arrays"), o = e("es-abstract/helpers/callBound"), n = o("Object.prototype.toString"), u = e("has-symbols")() && typeof Symbol.toStringTag == "symbol", p = r(), g = o("Array.prototype.indexOf", !0) || function(M, G) {
            for (var F = 0; F < M.length; F += 1)
              if (M[F] === G)
                return F;
            return -1;
          }, v = o("String.prototype.slice"), x = {}, b = e("es-abstract/helpers/getOwnPropertyDescriptor"), w = Object.getPrototypeOf;
          u && b && w && t(p, function(M) {
            var G = new a[M]();
            if (!(Symbol.toStringTag in G))
              throw new EvalError("this engine has support for Symbol.toStringTag, but " + M + " does not have the property! Please report this.");
            var F = w(G), V = b(F, Symbol.toStringTag);
            if (!V) {
              var q = w(F);
              V = b(q, Symbol.toStringTag);
            }
            x[M] = V.get;
          }), f.exports = function(M) {
            if (!M || typeof M != "object")
              return !1;
            if (!u) {
              var G = v(n(M), 8, -1);
              return g(p, G) > -1;
            }
            return !!b && function(F) {
              var V = !1;
              return t(x, function(q, I) {
                if (!V)
                  try {
                    V = q.call(F) === I;
                  } catch {
                  }
              }), V;
            }(M);
          };
        }).call(this);
      }).call(this, s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "available-typed-arrays": 27, "es-abstract/helpers/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 37, foreach: 39, "has-symbols": 42 }], 49: [function(e, f, i) {
      var a = typeof Uint8Array < "u" && typeof Uint16Array < "u" && typeof Int32Array < "u";
      function t(n, u) {
        return Object.prototype.hasOwnProperty.call(n, u);
      }
      i.assign = function(n) {
        for (var u = Array.prototype.slice.call(arguments, 1); u.length; ) {
          var p = u.shift();
          if (p) {
            if (typeof p != "object")
              throw new TypeError(p + "must be non-object");
            for (var g in p)
              t(p, g) && (n[g] = p[g]);
          }
        }
        return n;
      }, i.shrinkBuf = function(n, u) {
        return n.length === u ? n : n.subarray ? n.subarray(0, u) : (n.length = u, n);
      };
      var r = { arraySet: function(n, u, p, g, v) {
        if (u.subarray && n.subarray)
          n.set(u.subarray(p, p + g), v);
        else
          for (var x = 0; x < g; x++)
            n[v + x] = u[p + x];
      }, flattenChunks: function(n) {
        var u, p, g, v, x, b;
        for (g = 0, u = 0, p = n.length; u < p; u++)
          g += n[u].length;
        for (b = new Uint8Array(g), v = 0, u = 0, p = n.length; u < p; u++)
          x = n[u], b.set(x, v), v += x.length;
        return b;
      } }, o = { arraySet: function(n, u, p, g, v) {
        for (var x = 0; x < g; x++)
          n[v + x] = u[p + x];
      }, flattenChunks: function(n) {
        return [].concat.apply([], n);
      } };
      i.setTyped = function(n) {
        n ? (i.Buf8 = Uint8Array, i.Buf16 = Uint16Array, i.Buf32 = Int32Array, i.assign(i, r)) : (i.Buf8 = Array, i.Buf16 = Array, i.Buf32 = Array, i.assign(i, o));
      }, i.setTyped(a);
    }, {}], 50: [function(e, f, i) {
      f.exports = function(a, t, r, o) {
        for (var n = 65535 & a | 0, u = a >>> 16 & 65535 | 0, p = 0; r !== 0; ) {
          r -= p = r > 2e3 ? 2e3 : r;
          do
            u = u + (n = n + t[o++] | 0) | 0;
          while (--p);
          n %= 65521, u %= 65521;
        }
        return n | u << 16 | 0;
      };
    }, {}], 51: [function(e, f, i) {
      f.exports = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 };
    }, {}], 52: [function(e, f, i) {
      var a = function() {
        for (var t, r = [], o = 0; o < 256; o++) {
          t = o;
          for (var n = 0; n < 8; n++)
            t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1;
          r[o] = t;
        }
        return r;
      }();
      f.exports = function(t, r, o, n) {
        var u = a, p = n + o;
        t ^= -1;
        for (var g = n; g < p; g++)
          t = t >>> 8 ^ u[255 & (t ^ r[g])];
        return -1 ^ t;
      };
    }, {}], 53: [function(e, f, i) {
      var a, t = e("../utils/common"), r = e("./trees"), o = e("./adler32"), n = e("./crc32"), u = e("./messages"), p = 0, g = 1, v = 3, x = 4, b = 5, w = 0, M = 1, G = -2, F = -3, V = -5, q = -1, I = 1, _ = 2, R = 3, W = 4, O = 0, j = 2, U = 8, C = 9, ae = 15, J = 8, te = 286, $ = 30, L = 19, re = 2 * te + 1, z = 15, N = 3, ne = 258, le = ne + N + 1, he = 32, k = 42, T = 69, B = 73, K = 91, h = 103, c = 113, m = 666, D = 1, ee = 2, E = 3, Q = 4, se = 3;
      function Y(P, we) {
        return P.msg = u[we], we;
      }
      function be(P) {
        return (P << 1) - (P > 4 ? 9 : 0);
      }
      function Ee(P) {
        for (var we = P.length; --we >= 0; )
          P[we] = 0;
      }
      function Me(P) {
        var we = P.state, X = we.pending;
        X > P.avail_out && (X = P.avail_out), X !== 0 && (t.arraySet(P.output, we.pending_buf, we.pending_out, X, P.next_out), P.next_out += X, we.pending_out += X, P.total_out += X, P.avail_out -= X, we.pending -= X, we.pending === 0 && (we.pending_out = 0));
      }
      function ke(P, we) {
        r._tr_flush_block(P, P.block_start >= 0 ? P.block_start : -1, P.strstart - P.block_start, we), P.block_start = P.strstart, Me(P.strm);
      }
      function oe(P, we) {
        P.pending_buf[P.pending++] = we;
      }
      function ce(P, we) {
        P.pending_buf[P.pending++] = we >>> 8 & 255, P.pending_buf[P.pending++] = 255 & we;
      }
      function xe(P, we) {
        var X, de, Ze = P.max_chain_length, Re = P.strstart, rt = P.prev_length, De = P.nice_match, Je = P.strstart > P.w_size - le ? P.strstart - (P.w_size - le) : 0, Ne = P.window, Ie = P.w_mask, at = P.prev, st = P.strstart + ne, tt = Ne[Re + rt - 1], mt = Ne[Re + rt];
        P.prev_length >= P.good_match && (Ze >>= 2), De > P.lookahead && (De = P.lookahead);
        do
          if (Ne[(X = we) + rt] === mt && Ne[X + rt - 1] === tt && Ne[X] === Ne[Re] && Ne[++X] === Ne[Re + 1]) {
            Re += 2, X++;
            do
              ;
            while (Ne[++Re] === Ne[++X] && Ne[++Re] === Ne[++X] && Ne[++Re] === Ne[++X] && Ne[++Re] === Ne[++X] && Ne[++Re] === Ne[++X] && Ne[++Re] === Ne[++X] && Ne[++Re] === Ne[++X] && Ne[++Re] === Ne[++X] && Re < st);
            if (de = ne - (st - Re), Re = st - ne, de > rt) {
              if (P.match_start = we, rt = de, de >= De)
                break;
              tt = Ne[Re + rt - 1], mt = Ne[Re + rt];
            }
          }
        while ((we = at[we & Ie]) > Je && --Ze != 0);
        return rt <= P.lookahead ? rt : P.lookahead;
      }
      function Ce(P) {
        var we, X, de, Ze, Re, rt, De, Je, Ne, Ie, at = P.w_size;
        do {
          if (Ze = P.window_size - P.lookahead - P.strstart, P.strstart >= at + (at - le)) {
            t.arraySet(P.window, P.window, at, at, 0), P.match_start -= at, P.strstart -= at, P.block_start -= at, we = X = P.hash_size;
            do
              de = P.head[--we], P.head[we] = de >= at ? de - at : 0;
            while (--X);
            we = X = at;
            do
              de = P.prev[--we], P.prev[we] = de >= at ? de - at : 0;
            while (--X);
            Ze += at;
          }
          if (P.strm.avail_in === 0)
            break;
          if (rt = P.strm, De = P.window, Je = P.strstart + P.lookahead, Ne = Ze, Ie = void 0, (Ie = rt.avail_in) > Ne && (Ie = Ne), X = Ie === 0 ? 0 : (rt.avail_in -= Ie, t.arraySet(De, rt.input, rt.next_in, Ie, Je), rt.state.wrap === 1 ? rt.adler = o(rt.adler, De, Ie, Je) : rt.state.wrap === 2 && (rt.adler = n(rt.adler, De, Ie, Je)), rt.next_in += Ie, rt.total_in += Ie, Ie), P.lookahead += X, P.lookahead + P.insert >= N)
            for (Re = P.strstart - P.insert, P.ins_h = P.window[Re], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Re + 1]) & P.hash_mask; P.insert && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[Re + N - 1]) & P.hash_mask, P.prev[Re & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = Re, Re++, P.insert--, !(P.lookahead + P.insert < N)); )
              ;
        } while (P.lookahead < le && P.strm.avail_in !== 0);
      }
      function _e(P, we) {
        for (var X, de; ; ) {
          if (P.lookahead < le) {
            if (Ce(P), P.lookahead < le && we === p)
              return D;
            if (P.lookahead === 0)
              break;
          }
          if (X = 0, P.lookahead >= N && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + N - 1]) & P.hash_mask, X = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), X !== 0 && P.strstart - X <= P.w_size - le && (P.match_length = xe(P, X)), P.match_length >= N)
            if (de = r._tr_tally(P, P.strstart - P.match_start, P.match_length - N), P.lookahead -= P.match_length, P.match_length <= P.max_lazy_match && P.lookahead >= N) {
              P.match_length--;
              do
                P.strstart++, P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + N - 1]) & P.hash_mask, X = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart;
              while (--P.match_length != 0);
              P.strstart++;
            } else
              P.strstart += P.match_length, P.match_length = 0, P.ins_h = P.window[P.strstart], P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + 1]) & P.hash_mask;
          else
            de = r._tr_tally(P, 0, P.window[P.strstart]), P.lookahead--, P.strstart++;
          if (de && (ke(P, !1), P.strm.avail_out === 0))
            return D;
        }
        return P.insert = P.strstart < N - 1 ? P.strstart : N - 1, we === x ? (ke(P, !0), P.strm.avail_out === 0 ? E : Q) : P.last_lit && (ke(P, !1), P.strm.avail_out === 0) ? D : ee;
      }
      function Be(P, we) {
        for (var X, de, Ze; ; ) {
          if (P.lookahead < le) {
            if (Ce(P), P.lookahead < le && we === p)
              return D;
            if (P.lookahead === 0)
              break;
          }
          if (X = 0, P.lookahead >= N && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + N - 1]) & P.hash_mask, X = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart), P.prev_length = P.match_length, P.prev_match = P.match_start, P.match_length = N - 1, X !== 0 && P.prev_length < P.max_lazy_match && P.strstart - X <= P.w_size - le && (P.match_length = xe(P, X), P.match_length <= 5 && (P.strategy === I || P.match_length === N && P.strstart - P.match_start > 4096) && (P.match_length = N - 1)), P.prev_length >= N && P.match_length <= P.prev_length) {
            Ze = P.strstart + P.lookahead - N, de = r._tr_tally(P, P.strstart - 1 - P.prev_match, P.prev_length - N), P.lookahead -= P.prev_length - 1, P.prev_length -= 2;
            do
              ++P.strstart <= Ze && (P.ins_h = (P.ins_h << P.hash_shift ^ P.window[P.strstart + N - 1]) & P.hash_mask, X = P.prev[P.strstart & P.w_mask] = P.head[P.ins_h], P.head[P.ins_h] = P.strstart);
            while (--P.prev_length != 0);
            if (P.match_available = 0, P.match_length = N - 1, P.strstart++, de && (ke(P, !1), P.strm.avail_out === 0))
              return D;
          } else if (P.match_available) {
            if ((de = r._tr_tally(P, 0, P.window[P.strstart - 1])) && ke(P, !1), P.strstart++, P.lookahead--, P.strm.avail_out === 0)
              return D;
          } else
            P.match_available = 1, P.strstart++, P.lookahead--;
        }
        return P.match_available && (de = r._tr_tally(P, 0, P.window[P.strstart - 1]), P.match_available = 0), P.insert = P.strstart < N - 1 ? P.strstart : N - 1, we === x ? (ke(P, !0), P.strm.avail_out === 0 ? E : Q) : P.last_lit && (ke(P, !1), P.strm.avail_out === 0) ? D : ee;
      }
      function Pe(P, we, X, de, Ze) {
        this.good_length = P, this.max_lazy = we, this.nice_length = X, this.max_chain = de, this.func = Ze;
      }
      function Fe() {
        this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = U, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new t.Buf16(2 * re), this.dyn_dtree = new t.Buf16(2 * (2 * $ + 1)), this.bl_tree = new t.Buf16(2 * (2 * L + 1)), Ee(this.dyn_ltree), Ee(this.dyn_dtree), Ee(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new t.Buf16(z + 1), this.heap = new t.Buf16(2 * te + 1), Ee(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new t.Buf16(2 * te + 1), Ee(this.depth), this.l_buf = 0, this.lit_bufsize = 0, this.last_lit = 0, this.d_buf = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0;
      }
      function We(P) {
        var we;
        return P && P.state ? (P.total_in = P.total_out = 0, P.data_type = j, (we = P.state).pending = 0, we.pending_out = 0, we.wrap < 0 && (we.wrap = -we.wrap), we.status = we.wrap ? k : c, P.adler = we.wrap === 2 ? 0 : 1, we.last_flush = p, r._tr_init(we), w) : Y(P, G);
      }
      function Qe(P) {
        var we, X = We(P);
        return X === w && ((we = P.state).window_size = 2 * we.w_size, Ee(we.head), we.max_lazy_match = a[we.level].max_lazy, we.good_match = a[we.level].good_length, we.nice_match = a[we.level].nice_length, we.max_chain_length = a[we.level].max_chain, we.strstart = 0, we.block_start = 0, we.lookahead = 0, we.insert = 0, we.match_length = we.prev_length = N - 1, we.match_available = 0, we.ins_h = 0), X;
      }
      function lt(P, we, X, de, Ze, Re) {
        if (!P)
          return G;
        var rt = 1;
        if (we === q && (we = 6), de < 0 ? (rt = 0, de = -de) : de > 15 && (rt = 2, de -= 16), Ze < 1 || Ze > C || X !== U || de < 8 || de > 15 || we < 0 || we > 9 || Re < 0 || Re > W)
          return Y(P, G);
        de === 8 && (de = 9);
        var De = new Fe();
        return P.state = De, De.strm = P, De.wrap = rt, De.gzhead = null, De.w_bits = de, De.w_size = 1 << De.w_bits, De.w_mask = De.w_size - 1, De.hash_bits = Ze + 7, De.hash_size = 1 << De.hash_bits, De.hash_mask = De.hash_size - 1, De.hash_shift = ~~((De.hash_bits + N - 1) / N), De.window = new t.Buf8(2 * De.w_size), De.head = new t.Buf16(De.hash_size), De.prev = new t.Buf16(De.w_size), De.lit_bufsize = 1 << Ze + 6, De.pending_buf_size = 4 * De.lit_bufsize, De.pending_buf = new t.Buf8(De.pending_buf_size), De.d_buf = 1 * De.lit_bufsize, De.l_buf = 3 * De.lit_bufsize, De.level = we, De.strategy = Re, De.method = X, Qe(P);
      }
      a = [new Pe(0, 0, 0, 0, function(P, we) {
        var X = 65535;
        for (X > P.pending_buf_size - 5 && (X = P.pending_buf_size - 5); ; ) {
          if (P.lookahead <= 1) {
            if (Ce(P), P.lookahead === 0 && we === p)
              return D;
            if (P.lookahead === 0)
              break;
          }
          P.strstart += P.lookahead, P.lookahead = 0;
          var de = P.block_start + X;
          if ((P.strstart === 0 || P.strstart >= de) && (P.lookahead = P.strstart - de, P.strstart = de, ke(P, !1), P.strm.avail_out === 0) || P.strstart - P.block_start >= P.w_size - le && (ke(P, !1), P.strm.avail_out === 0))
            return D;
        }
        return P.insert = 0, we === x ? (ke(P, !0), P.strm.avail_out === 0 ? E : Q) : (P.strstart > P.block_start && (ke(P, !1), P.strm.avail_out), D);
      }), new Pe(4, 4, 8, 4, _e), new Pe(4, 5, 16, 8, _e), new Pe(4, 6, 32, 32, _e), new Pe(4, 4, 16, 16, Be), new Pe(8, 16, 32, 32, Be), new Pe(8, 16, 128, 128, Be), new Pe(8, 32, 128, 256, Be), new Pe(32, 128, 258, 1024, Be), new Pe(32, 258, 258, 4096, Be)], i.deflateInit = function(P, we) {
        return lt(P, we, U, ae, J, O);
      }, i.deflateInit2 = lt, i.deflateReset = Qe, i.deflateResetKeep = We, i.deflateSetHeader = function(P, we) {
        return P && P.state ? P.state.wrap !== 2 ? G : (P.state.gzhead = we, w) : G;
      }, i.deflate = function(P, we) {
        var X, de, Ze, Re;
        if (!P || !P.state || we > b || we < 0)
          return P ? Y(P, G) : G;
        if (de = P.state, !P.output || !P.input && P.avail_in !== 0 || de.status === m && we !== x)
          return Y(P, P.avail_out === 0 ? V : G);
        if (de.strm = P, X = de.last_flush, de.last_flush = we, de.status === k)
          if (de.wrap === 2)
            P.adler = 0, oe(de, 31), oe(de, 139), oe(de, 8), de.gzhead ? (oe(de, (de.gzhead.text ? 1 : 0) + (de.gzhead.hcrc ? 2 : 0) + (de.gzhead.extra ? 4 : 0) + (de.gzhead.name ? 8 : 0) + (de.gzhead.comment ? 16 : 0)), oe(de, 255 & de.gzhead.time), oe(de, de.gzhead.time >> 8 & 255), oe(de, de.gzhead.time >> 16 & 255), oe(de, de.gzhead.time >> 24 & 255), oe(de, de.level === 9 ? 2 : de.strategy >= _ || de.level < 2 ? 4 : 0), oe(de, 255 & de.gzhead.os), de.gzhead.extra && de.gzhead.extra.length && (oe(de, 255 & de.gzhead.extra.length), oe(de, de.gzhead.extra.length >> 8 & 255)), de.gzhead.hcrc && (P.adler = n(P.adler, de.pending_buf, de.pending, 0)), de.gzindex = 0, de.status = T) : (oe(de, 0), oe(de, 0), oe(de, 0), oe(de, 0), oe(de, 0), oe(de, de.level === 9 ? 2 : de.strategy >= _ || de.level < 2 ? 4 : 0), oe(de, se), de.status = c);
          else {
            var rt = U + (de.w_bits - 8 << 4) << 8;
            rt |= (de.strategy >= _ || de.level < 2 ? 0 : de.level < 6 ? 1 : de.level === 6 ? 2 : 3) << 6, de.strstart !== 0 && (rt |= he), rt += 31 - rt % 31, de.status = c, ce(de, rt), de.strstart !== 0 && (ce(de, P.adler >>> 16), ce(de, 65535 & P.adler)), P.adler = 1;
          }
        if (de.status === T)
          if (de.gzhead.extra) {
            for (Ze = de.pending; de.gzindex < (65535 & de.gzhead.extra.length) && (de.pending !== de.pending_buf_size || (de.gzhead.hcrc && de.pending > Ze && (P.adler = n(P.adler, de.pending_buf, de.pending - Ze, Ze)), Me(P), Ze = de.pending, de.pending !== de.pending_buf_size)); )
              oe(de, 255 & de.gzhead.extra[de.gzindex]), de.gzindex++;
            de.gzhead.hcrc && de.pending > Ze && (P.adler = n(P.adler, de.pending_buf, de.pending - Ze, Ze)), de.gzindex === de.gzhead.extra.length && (de.gzindex = 0, de.status = B);
          } else
            de.status = B;
        if (de.status === B)
          if (de.gzhead.name) {
            Ze = de.pending;
            do {
              if (de.pending === de.pending_buf_size && (de.gzhead.hcrc && de.pending > Ze && (P.adler = n(P.adler, de.pending_buf, de.pending - Ze, Ze)), Me(P), Ze = de.pending, de.pending === de.pending_buf_size)) {
                Re = 1;
                break;
              }
              Re = de.gzindex < de.gzhead.name.length ? 255 & de.gzhead.name.charCodeAt(de.gzindex++) : 0, oe(de, Re);
            } while (Re !== 0);
            de.gzhead.hcrc && de.pending > Ze && (P.adler = n(P.adler, de.pending_buf, de.pending - Ze, Ze)), Re === 0 && (de.gzindex = 0, de.status = K);
          } else
            de.status = K;
        if (de.status === K)
          if (de.gzhead.comment) {
            Ze = de.pending;
            do {
              if (de.pending === de.pending_buf_size && (de.gzhead.hcrc && de.pending > Ze && (P.adler = n(P.adler, de.pending_buf, de.pending - Ze, Ze)), Me(P), Ze = de.pending, de.pending === de.pending_buf_size)) {
                Re = 1;
                break;
              }
              Re = de.gzindex < de.gzhead.comment.length ? 255 & de.gzhead.comment.charCodeAt(de.gzindex++) : 0, oe(de, Re);
            } while (Re !== 0);
            de.gzhead.hcrc && de.pending > Ze && (P.adler = n(P.adler, de.pending_buf, de.pending - Ze, Ze)), Re === 0 && (de.status = h);
          } else
            de.status = h;
        if (de.status === h && (de.gzhead.hcrc ? (de.pending + 2 > de.pending_buf_size && Me(P), de.pending + 2 <= de.pending_buf_size && (oe(de, 255 & P.adler), oe(de, P.adler >> 8 & 255), P.adler = 0, de.status = c)) : de.status = c), de.pending !== 0) {
          if (Me(P), P.avail_out === 0)
            return de.last_flush = -1, w;
        } else if (P.avail_in === 0 && be(we) <= be(X) && we !== x)
          return Y(P, V);
        if (de.status === m && P.avail_in !== 0)
          return Y(P, V);
        if (P.avail_in !== 0 || de.lookahead !== 0 || we !== p && de.status !== m) {
          var De = de.strategy === _ ? function(Je, Ne) {
            for (var Ie; ; ) {
              if (Je.lookahead === 0 && (Ce(Je), Je.lookahead === 0)) {
                if (Ne === p)
                  return D;
                break;
              }
              if (Je.match_length = 0, Ie = r._tr_tally(Je, 0, Je.window[Je.strstart]), Je.lookahead--, Je.strstart++, Ie && (ke(Je, !1), Je.strm.avail_out === 0))
                return D;
            }
            return Je.insert = 0, Ne === x ? (ke(Je, !0), Je.strm.avail_out === 0 ? E : Q) : Je.last_lit && (ke(Je, !1), Je.strm.avail_out === 0) ? D : ee;
          }(de, we) : de.strategy === R ? function(Je, Ne) {
            for (var Ie, at, st, tt, mt = Je.window; ; ) {
              if (Je.lookahead <= ne) {
                if (Ce(Je), Je.lookahead <= ne && Ne === p)
                  return D;
                if (Je.lookahead === 0)
                  break;
              }
              if (Je.match_length = 0, Je.lookahead >= N && Je.strstart > 0 && (at = mt[st = Je.strstart - 1]) === mt[++st] && at === mt[++st] && at === mt[++st]) {
                tt = Je.strstart + ne;
                do
                  ;
                while (at === mt[++st] && at === mt[++st] && at === mt[++st] && at === mt[++st] && at === mt[++st] && at === mt[++st] && at === mt[++st] && at === mt[++st] && st < tt);
                Je.match_length = ne - (tt - st), Je.match_length > Je.lookahead && (Je.match_length = Je.lookahead);
              }
              if (Je.match_length >= N ? (Ie = r._tr_tally(Je, 1, Je.match_length - N), Je.lookahead -= Je.match_length, Je.strstart += Je.match_length, Je.match_length = 0) : (Ie = r._tr_tally(Je, 0, Je.window[Je.strstart]), Je.lookahead--, Je.strstart++), Ie && (ke(Je, !1), Je.strm.avail_out === 0))
                return D;
            }
            return Je.insert = 0, Ne === x ? (ke(Je, !0), Je.strm.avail_out === 0 ? E : Q) : Je.last_lit && (ke(Je, !1), Je.strm.avail_out === 0) ? D : ee;
          }(de, we) : a[de.level].func(de, we);
          if (De !== E && De !== Q || (de.status = m), De === D || De === E)
            return P.avail_out === 0 && (de.last_flush = -1), w;
          if (De === ee && (we === g ? r._tr_align(de) : we !== b && (r._tr_stored_block(de, 0, 0, !1), we === v && (Ee(de.head), de.lookahead === 0 && (de.strstart = 0, de.block_start = 0, de.insert = 0))), Me(P), P.avail_out === 0))
            return de.last_flush = -1, w;
        }
        return we !== x ? w : de.wrap <= 0 ? M : (de.wrap === 2 ? (oe(de, 255 & P.adler), oe(de, P.adler >> 8 & 255), oe(de, P.adler >> 16 & 255), oe(de, P.adler >> 24 & 255), oe(de, 255 & P.total_in), oe(de, P.total_in >> 8 & 255), oe(de, P.total_in >> 16 & 255), oe(de, P.total_in >> 24 & 255)) : (ce(de, P.adler >>> 16), ce(de, 65535 & P.adler)), Me(P), de.wrap > 0 && (de.wrap = -de.wrap), de.pending !== 0 ? w : M);
      }, i.deflateEnd = function(P) {
        var we;
        return P && P.state ? (we = P.state.status) !== k && we !== T && we !== B && we !== K && we !== h && we !== c && we !== m ? Y(P, G) : (P.state = null, we === c ? Y(P, F) : w) : G;
      }, i.deflateSetDictionary = function(P, we) {
        var X, de, Ze, Re, rt, De, Je, Ne, Ie = we.length;
        if (!P || !P.state || (Re = (X = P.state).wrap) === 2 || Re === 1 && X.status !== k || X.lookahead)
          return G;
        for (Re === 1 && (P.adler = o(P.adler, we, Ie, 0)), X.wrap = 0, Ie >= X.w_size && (Re === 0 && (Ee(X.head), X.strstart = 0, X.block_start = 0, X.insert = 0), Ne = new t.Buf8(X.w_size), t.arraySet(Ne, we, Ie - X.w_size, X.w_size, 0), we = Ne, Ie = X.w_size), rt = P.avail_in, De = P.next_in, Je = P.input, P.avail_in = Ie, P.next_in = 0, P.input = we, Ce(X); X.lookahead >= N; ) {
          de = X.strstart, Ze = X.lookahead - (N - 1);
          do
            X.ins_h = (X.ins_h << X.hash_shift ^ X.window[de + N - 1]) & X.hash_mask, X.prev[de & X.w_mask] = X.head[X.ins_h], X.head[X.ins_h] = de, de++;
          while (--Ze);
          X.strstart = de, X.lookahead = N - 1, Ce(X);
        }
        return X.strstart += X.lookahead, X.block_start = X.strstart, X.insert = X.lookahead, X.lookahead = 0, X.match_length = X.prev_length = N - 1, X.match_available = 0, P.next_in = De, P.input = Je, P.avail_in = rt, X.wrap = Re, w;
      }, i.deflateInfo = "pako deflate (from Nodeca project)";
    }, { "../utils/common": 49, "./adler32": 50, "./crc32": 52, "./messages": 57, "./trees": 58 }], 54: [function(e, f, i) {
      f.exports = function(a, t) {
        var r, o, n, u, p, g, v, x, b, w, M, G, F, V, q, I, _, R, W, O, j, U, C, ae, J;
        r = a.state, o = a.next_in, ae = a.input, n = o + (a.avail_in - 5), u = a.next_out, J = a.output, p = u - (t - a.avail_out), g = u + (a.avail_out - 257), v = r.dmax, x = r.wsize, b = r.whave, w = r.wnext, M = r.window, G = r.hold, F = r.bits, V = r.lencode, q = r.distcode, I = (1 << r.lenbits) - 1, _ = (1 << r.distbits) - 1;
        e:
          do {
            F < 15 && (G += ae[o++] << F, F += 8, G += ae[o++] << F, F += 8), R = V[G & I];
            t:
              for (; ; ) {
                if (G >>>= W = R >>> 24, F -= W, (W = R >>> 16 & 255) == 0)
                  J[u++] = 65535 & R;
                else {
                  if (!(16 & W)) {
                    if (!(64 & W)) {
                      R = V[(65535 & R) + (G & (1 << W) - 1)];
                      continue t;
                    }
                    if (32 & W) {
                      r.mode = 12;
                      break e;
                    }
                    a.msg = "invalid literal/length code", r.mode = 30;
                    break e;
                  }
                  O = 65535 & R, (W &= 15) && (F < W && (G += ae[o++] << F, F += 8), O += G & (1 << W) - 1, G >>>= W, F -= W), F < 15 && (G += ae[o++] << F, F += 8, G += ae[o++] << F, F += 8), R = q[G & _];
                  r:
                    for (; ; ) {
                      if (G >>>= W = R >>> 24, F -= W, !(16 & (W = R >>> 16 & 255))) {
                        if (!(64 & W)) {
                          R = q[(65535 & R) + (G & (1 << W) - 1)];
                          continue r;
                        }
                        a.msg = "invalid distance code", r.mode = 30;
                        break e;
                      }
                      if (j = 65535 & R, F < (W &= 15) && (G += ae[o++] << F, (F += 8) < W && (G += ae[o++] << F, F += 8)), (j += G & (1 << W) - 1) > v) {
                        a.msg = "invalid distance too far back", r.mode = 30;
                        break e;
                      }
                      if (G >>>= W, F -= W, j > (W = u - p)) {
                        if ((W = j - W) > b && r.sane) {
                          a.msg = "invalid distance too far back", r.mode = 30;
                          break e;
                        }
                        if (U = 0, C = M, w === 0) {
                          if (U += x - W, W < O) {
                            O -= W;
                            do
                              J[u++] = M[U++];
                            while (--W);
                            U = u - j, C = J;
                          }
                        } else if (w < W) {
                          if (U += x + w - W, (W -= w) < O) {
                            O -= W;
                            do
                              J[u++] = M[U++];
                            while (--W);
                            if (U = 0, w < O) {
                              O -= W = w;
                              do
                                J[u++] = M[U++];
                              while (--W);
                              U = u - j, C = J;
                            }
                          }
                        } else if (U += w - W, W < O) {
                          O -= W;
                          do
                            J[u++] = M[U++];
                          while (--W);
                          U = u - j, C = J;
                        }
                        for (; O > 2; )
                          J[u++] = C[U++], J[u++] = C[U++], J[u++] = C[U++], O -= 3;
                        O && (J[u++] = C[U++], O > 1 && (J[u++] = C[U++]));
                      } else {
                        U = u - j;
                        do
                          J[u++] = J[U++], J[u++] = J[U++], J[u++] = J[U++], O -= 3;
                        while (O > 2);
                        O && (J[u++] = J[U++], O > 1 && (J[u++] = J[U++]));
                      }
                      break;
                    }
                }
                break;
              }
          } while (o < n && u < g);
        o -= O = F >> 3, G &= (1 << (F -= O << 3)) - 1, a.next_in = o, a.next_out = u, a.avail_in = o < n ? n - o + 5 : 5 - (o - n), a.avail_out = u < g ? g - u + 257 : 257 - (u - g), r.hold = G, r.bits = F;
      };
    }, {}], 55: [function(e, f, i) {
      var a = e("../utils/common"), t = e("./adler32"), r = e("./crc32"), o = e("./inffast"), n = e("./inftrees"), u = 0, p = 1, g = 2, v = 4, x = 5, b = 6, w = 0, M = 1, G = 2, F = -2, V = -3, q = -4, I = -5, _ = 8, R = 1, W = 2, O = 3, j = 4, U = 5, C = 6, ae = 7, J = 8, te = 9, $ = 10, L = 11, re = 12, z = 13, N = 14, ne = 15, le = 16, he = 17, k = 18, T = 19, B = 20, K = 21, h = 22, c = 23, m = 24, D = 25, ee = 26, E = 27, Q = 28, se = 29, Y = 30, be = 31, Ee = 852, Me = 592, ke = 15;
      function oe(P) {
        return (P >>> 24 & 255) + (P >>> 8 & 65280) + ((65280 & P) << 8) + ((255 & P) << 24);
      }
      function ce() {
        this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new a.Buf16(320), this.work = new a.Buf16(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0;
      }
      function xe(P) {
        var we;
        return P && P.state ? (we = P.state, P.total_in = P.total_out = we.total = 0, P.msg = "", we.wrap && (P.adler = 1 & we.wrap), we.mode = R, we.last = 0, we.havedict = 0, we.dmax = 32768, we.head = null, we.hold = 0, we.bits = 0, we.lencode = we.lendyn = new a.Buf32(Ee), we.distcode = we.distdyn = new a.Buf32(Me), we.sane = 1, we.back = -1, w) : F;
      }
      function Ce(P) {
        var we;
        return P && P.state ? ((we = P.state).wsize = 0, we.whave = 0, we.wnext = 0, xe(P)) : F;
      }
      function _e(P, we) {
        var X, de;
        return P && P.state ? (de = P.state, we < 0 ? (X = 0, we = -we) : (X = 1 + (we >> 4), we < 48 && (we &= 15)), we && (we < 8 || we > 15) ? F : (de.window !== null && de.wbits !== we && (de.window = null), de.wrap = X, de.wbits = we, Ce(P))) : F;
      }
      function Be(P, we) {
        var X, de;
        return P ? (de = new ce(), P.state = de, de.window = null, (X = _e(P, we)) !== w && (P.state = null), X) : F;
      }
      var Pe, Fe, We = !0;
      function Qe(P) {
        if (We) {
          var we;
          for (Pe = new a.Buf32(512), Fe = new a.Buf32(32), we = 0; we < 144; )
            P.lens[we++] = 8;
          for (; we < 256; )
            P.lens[we++] = 9;
          for (; we < 280; )
            P.lens[we++] = 7;
          for (; we < 288; )
            P.lens[we++] = 8;
          for (n(p, P.lens, 0, 288, Pe, 0, P.work, { bits: 9 }), we = 0; we < 32; )
            P.lens[we++] = 5;
          n(g, P.lens, 0, 32, Fe, 0, P.work, { bits: 5 }), We = !1;
        }
        P.lencode = Pe, P.lenbits = 9, P.distcode = Fe, P.distbits = 5;
      }
      function lt(P, we, X, de) {
        var Ze, Re = P.state;
        return Re.window === null && (Re.wsize = 1 << Re.wbits, Re.wnext = 0, Re.whave = 0, Re.window = new a.Buf8(Re.wsize)), de >= Re.wsize ? (a.arraySet(Re.window, we, X - Re.wsize, Re.wsize, 0), Re.wnext = 0, Re.whave = Re.wsize) : ((Ze = Re.wsize - Re.wnext) > de && (Ze = de), a.arraySet(Re.window, we, X - de, Ze, Re.wnext), (de -= Ze) ? (a.arraySet(Re.window, we, X - de, de, 0), Re.wnext = de, Re.whave = Re.wsize) : (Re.wnext += Ze, Re.wnext === Re.wsize && (Re.wnext = 0), Re.whave < Re.wsize && (Re.whave += Ze))), 0;
      }
      i.inflateReset = Ce, i.inflateReset2 = _e, i.inflateResetKeep = xe, i.inflateInit = function(P) {
        return Be(P, ke);
      }, i.inflateInit2 = Be, i.inflate = function(P, we) {
        var X, de, Ze, Re, rt, De, Je, Ne, Ie, at, st, tt, mt, It, wt, ot, kt, Ft, Rt, qt, Lt, Se, Ye, Ke, ut = 0, bt = new a.Buf8(4), At = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
        if (!P || !P.state || !P.output || !P.input && P.avail_in !== 0)
          return F;
        (X = P.state).mode === re && (X.mode = z), rt = P.next_out, Ze = P.output, Je = P.avail_out, Re = P.next_in, de = P.input, De = P.avail_in, Ne = X.hold, Ie = X.bits, at = De, st = Je, Se = w;
        e:
          for (; ; )
            switch (X.mode) {
              case R:
                if (X.wrap === 0) {
                  X.mode = z;
                  break;
                }
                for (; Ie < 16; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                if (2 & X.wrap && Ne === 35615) {
                  X.check = 0, bt[0] = 255 & Ne, bt[1] = Ne >>> 8 & 255, X.check = r(X.check, bt, 2, 0), Ne = 0, Ie = 0, X.mode = W;
                  break;
                }
                if (X.flags = 0, X.head && (X.head.done = !1), !(1 & X.wrap) || (((255 & Ne) << 8) + (Ne >> 8)) % 31) {
                  P.msg = "incorrect header check", X.mode = Y;
                  break;
                }
                if ((15 & Ne) !== _) {
                  P.msg = "unknown compression method", X.mode = Y;
                  break;
                }
                if (Ie -= 4, Lt = 8 + (15 & (Ne >>>= 4)), X.wbits === 0)
                  X.wbits = Lt;
                else if (Lt > X.wbits) {
                  P.msg = "invalid window size", X.mode = Y;
                  break;
                }
                X.dmax = 1 << Lt, P.adler = X.check = 1, X.mode = 512 & Ne ? $ : re, Ne = 0, Ie = 0;
                break;
              case W:
                for (; Ie < 16; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                if (X.flags = Ne, (255 & X.flags) !== _) {
                  P.msg = "unknown compression method", X.mode = Y;
                  break;
                }
                if (57344 & X.flags) {
                  P.msg = "unknown header flags set", X.mode = Y;
                  break;
                }
                X.head && (X.head.text = Ne >> 8 & 1), 512 & X.flags && (bt[0] = 255 & Ne, bt[1] = Ne >>> 8 & 255, X.check = r(X.check, bt, 2, 0)), Ne = 0, Ie = 0, X.mode = O;
              case O:
                for (; Ie < 32; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                X.head && (X.head.time = Ne), 512 & X.flags && (bt[0] = 255 & Ne, bt[1] = Ne >>> 8 & 255, bt[2] = Ne >>> 16 & 255, bt[3] = Ne >>> 24 & 255, X.check = r(X.check, bt, 4, 0)), Ne = 0, Ie = 0, X.mode = j;
              case j:
                for (; Ie < 16; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                X.head && (X.head.xflags = 255 & Ne, X.head.os = Ne >> 8), 512 & X.flags && (bt[0] = 255 & Ne, bt[1] = Ne >>> 8 & 255, X.check = r(X.check, bt, 2, 0)), Ne = 0, Ie = 0, X.mode = U;
              case U:
                if (1024 & X.flags) {
                  for (; Ie < 16; ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  X.length = Ne, X.head && (X.head.extra_len = Ne), 512 & X.flags && (bt[0] = 255 & Ne, bt[1] = Ne >>> 8 & 255, X.check = r(X.check, bt, 2, 0)), Ne = 0, Ie = 0;
                } else
                  X.head && (X.head.extra = null);
                X.mode = C;
              case C:
                if (1024 & X.flags && ((tt = X.length) > De && (tt = De), tt && (X.head && (Lt = X.head.extra_len - X.length, X.head.extra || (X.head.extra = new Array(X.head.extra_len)), a.arraySet(X.head.extra, de, Re, tt, Lt)), 512 & X.flags && (X.check = r(X.check, de, tt, Re)), De -= tt, Re += tt, X.length -= tt), X.length))
                  break e;
                X.length = 0, X.mode = ae;
              case ae:
                if (2048 & X.flags) {
                  if (De === 0)
                    break e;
                  tt = 0;
                  do
                    Lt = de[Re + tt++], X.head && Lt && X.length < 65536 && (X.head.name += String.fromCharCode(Lt));
                  while (Lt && tt < De);
                  if (512 & X.flags && (X.check = r(X.check, de, tt, Re)), De -= tt, Re += tt, Lt)
                    break e;
                } else
                  X.head && (X.head.name = null);
                X.length = 0, X.mode = J;
              case J:
                if (4096 & X.flags) {
                  if (De === 0)
                    break e;
                  tt = 0;
                  do
                    Lt = de[Re + tt++], X.head && Lt && X.length < 65536 && (X.head.comment += String.fromCharCode(Lt));
                  while (Lt && tt < De);
                  if (512 & X.flags && (X.check = r(X.check, de, tt, Re)), De -= tt, Re += tt, Lt)
                    break e;
                } else
                  X.head && (X.head.comment = null);
                X.mode = te;
              case te:
                if (512 & X.flags) {
                  for (; Ie < 16; ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  if (Ne !== (65535 & X.check)) {
                    P.msg = "header crc mismatch", X.mode = Y;
                    break;
                  }
                  Ne = 0, Ie = 0;
                }
                X.head && (X.head.hcrc = X.flags >> 9 & 1, X.head.done = !0), P.adler = X.check = 0, X.mode = re;
                break;
              case $:
                for (; Ie < 32; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                P.adler = X.check = oe(Ne), Ne = 0, Ie = 0, X.mode = L;
              case L:
                if (X.havedict === 0)
                  return P.next_out = rt, P.avail_out = Je, P.next_in = Re, P.avail_in = De, X.hold = Ne, X.bits = Ie, G;
                P.adler = X.check = 1, X.mode = re;
              case re:
                if (we === x || we === b)
                  break e;
              case z:
                if (X.last) {
                  Ne >>>= 7 & Ie, Ie -= 7 & Ie, X.mode = E;
                  break;
                }
                for (; Ie < 3; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                switch (X.last = 1 & Ne, Ie -= 1, 3 & (Ne >>>= 1)) {
                  case 0:
                    X.mode = N;
                    break;
                  case 1:
                    if (Qe(X), X.mode = B, we === b) {
                      Ne >>>= 2, Ie -= 2;
                      break e;
                    }
                    break;
                  case 2:
                    X.mode = he;
                    break;
                  case 3:
                    P.msg = "invalid block type", X.mode = Y;
                }
                Ne >>>= 2, Ie -= 2;
                break;
              case N:
                for (Ne >>>= 7 & Ie, Ie -= 7 & Ie; Ie < 32; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                if ((65535 & Ne) != (Ne >>> 16 ^ 65535)) {
                  P.msg = "invalid stored block lengths", X.mode = Y;
                  break;
                }
                if (X.length = 65535 & Ne, Ne = 0, Ie = 0, X.mode = ne, we === b)
                  break e;
              case ne:
                X.mode = le;
              case le:
                if (tt = X.length) {
                  if (tt > De && (tt = De), tt > Je && (tt = Je), tt === 0)
                    break e;
                  a.arraySet(Ze, de, Re, tt, rt), De -= tt, Re += tt, Je -= tt, rt += tt, X.length -= tt;
                  break;
                }
                X.mode = re;
                break;
              case he:
                for (; Ie < 14; ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                if (X.nlen = 257 + (31 & Ne), Ne >>>= 5, Ie -= 5, X.ndist = 1 + (31 & Ne), Ne >>>= 5, Ie -= 5, X.ncode = 4 + (15 & Ne), Ne >>>= 4, Ie -= 4, X.nlen > 286 || X.ndist > 30) {
                  P.msg = "too many length or distance symbols", X.mode = Y;
                  break;
                }
                X.have = 0, X.mode = k;
              case k:
                for (; X.have < X.ncode; ) {
                  for (; Ie < 3; ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  X.lens[At[X.have++]] = 7 & Ne, Ne >>>= 3, Ie -= 3;
                }
                for (; X.have < 19; )
                  X.lens[At[X.have++]] = 0;
                if (X.lencode = X.lendyn, X.lenbits = 7, Ye = { bits: X.lenbits }, Se = n(u, X.lens, 0, 19, X.lencode, 0, X.work, Ye), X.lenbits = Ye.bits, Se) {
                  P.msg = "invalid code lengths set", X.mode = Y;
                  break;
                }
                X.have = 0, X.mode = T;
              case T:
                for (; X.have < X.nlen + X.ndist; ) {
                  for (; ot = (ut = X.lencode[Ne & (1 << X.lenbits) - 1]) >>> 16 & 255, kt = 65535 & ut, !((wt = ut >>> 24) <= Ie); ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  if (kt < 16)
                    Ne >>>= wt, Ie -= wt, X.lens[X.have++] = kt;
                  else {
                    if (kt === 16) {
                      for (Ke = wt + 2; Ie < Ke; ) {
                        if (De === 0)
                          break e;
                        De--, Ne += de[Re++] << Ie, Ie += 8;
                      }
                      if (Ne >>>= wt, Ie -= wt, X.have === 0) {
                        P.msg = "invalid bit length repeat", X.mode = Y;
                        break;
                      }
                      Lt = X.lens[X.have - 1], tt = 3 + (3 & Ne), Ne >>>= 2, Ie -= 2;
                    } else if (kt === 17) {
                      for (Ke = wt + 3; Ie < Ke; ) {
                        if (De === 0)
                          break e;
                        De--, Ne += de[Re++] << Ie, Ie += 8;
                      }
                      Ie -= wt, Lt = 0, tt = 3 + (7 & (Ne >>>= wt)), Ne >>>= 3, Ie -= 3;
                    } else {
                      for (Ke = wt + 7; Ie < Ke; ) {
                        if (De === 0)
                          break e;
                        De--, Ne += de[Re++] << Ie, Ie += 8;
                      }
                      Ie -= wt, Lt = 0, tt = 11 + (127 & (Ne >>>= wt)), Ne >>>= 7, Ie -= 7;
                    }
                    if (X.have + tt > X.nlen + X.ndist) {
                      P.msg = "invalid bit length repeat", X.mode = Y;
                      break;
                    }
                    for (; tt--; )
                      X.lens[X.have++] = Lt;
                  }
                }
                if (X.mode === Y)
                  break;
                if (X.lens[256] === 0) {
                  P.msg = "invalid code -- missing end-of-block", X.mode = Y;
                  break;
                }
                if (X.lenbits = 9, Ye = { bits: X.lenbits }, Se = n(p, X.lens, 0, X.nlen, X.lencode, 0, X.work, Ye), X.lenbits = Ye.bits, Se) {
                  P.msg = "invalid literal/lengths set", X.mode = Y;
                  break;
                }
                if (X.distbits = 6, X.distcode = X.distdyn, Ye = { bits: X.distbits }, Se = n(g, X.lens, X.nlen, X.ndist, X.distcode, 0, X.work, Ye), X.distbits = Ye.bits, Se) {
                  P.msg = "invalid distances set", X.mode = Y;
                  break;
                }
                if (X.mode = B, we === b)
                  break e;
              case B:
                X.mode = K;
              case K:
                if (De >= 6 && Je >= 258) {
                  P.next_out = rt, P.avail_out = Je, P.next_in = Re, P.avail_in = De, X.hold = Ne, X.bits = Ie, o(P, st), rt = P.next_out, Ze = P.output, Je = P.avail_out, Re = P.next_in, de = P.input, De = P.avail_in, Ne = X.hold, Ie = X.bits, X.mode === re && (X.back = -1);
                  break;
                }
                for (X.back = 0; ot = (ut = X.lencode[Ne & (1 << X.lenbits) - 1]) >>> 16 & 255, kt = 65535 & ut, !((wt = ut >>> 24) <= Ie); ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                if (ot && !(240 & ot)) {
                  for (Ft = wt, Rt = ot, qt = kt; ot = (ut = X.lencode[qt + ((Ne & (1 << Ft + Rt) - 1) >> Ft)]) >>> 16 & 255, kt = 65535 & ut, !(Ft + (wt = ut >>> 24) <= Ie); ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  Ne >>>= Ft, Ie -= Ft, X.back += Ft;
                }
                if (Ne >>>= wt, Ie -= wt, X.back += wt, X.length = kt, ot === 0) {
                  X.mode = ee;
                  break;
                }
                if (32 & ot) {
                  X.back = -1, X.mode = re;
                  break;
                }
                if (64 & ot) {
                  P.msg = "invalid literal/length code", X.mode = Y;
                  break;
                }
                X.extra = 15 & ot, X.mode = h;
              case h:
                if (X.extra) {
                  for (Ke = X.extra; Ie < Ke; ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  X.length += Ne & (1 << X.extra) - 1, Ne >>>= X.extra, Ie -= X.extra, X.back += X.extra;
                }
                X.was = X.length, X.mode = c;
              case c:
                for (; ot = (ut = X.distcode[Ne & (1 << X.distbits) - 1]) >>> 16 & 255, kt = 65535 & ut, !((wt = ut >>> 24) <= Ie); ) {
                  if (De === 0)
                    break e;
                  De--, Ne += de[Re++] << Ie, Ie += 8;
                }
                if (!(240 & ot)) {
                  for (Ft = wt, Rt = ot, qt = kt; ot = (ut = X.distcode[qt + ((Ne & (1 << Ft + Rt) - 1) >> Ft)]) >>> 16 & 255, kt = 65535 & ut, !(Ft + (wt = ut >>> 24) <= Ie); ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  Ne >>>= Ft, Ie -= Ft, X.back += Ft;
                }
                if (Ne >>>= wt, Ie -= wt, X.back += wt, 64 & ot) {
                  P.msg = "invalid distance code", X.mode = Y;
                  break;
                }
                X.offset = kt, X.extra = 15 & ot, X.mode = m;
              case m:
                if (X.extra) {
                  for (Ke = X.extra; Ie < Ke; ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  X.offset += Ne & (1 << X.extra) - 1, Ne >>>= X.extra, Ie -= X.extra, X.back += X.extra;
                }
                if (X.offset > X.dmax) {
                  P.msg = "invalid distance too far back", X.mode = Y;
                  break;
                }
                X.mode = D;
              case D:
                if (Je === 0)
                  break e;
                if (tt = st - Je, X.offset > tt) {
                  if ((tt = X.offset - tt) > X.whave && X.sane) {
                    P.msg = "invalid distance too far back", X.mode = Y;
                    break;
                  }
                  tt > X.wnext ? (tt -= X.wnext, mt = X.wsize - tt) : mt = X.wnext - tt, tt > X.length && (tt = X.length), It = X.window;
                } else
                  It = Ze, mt = rt - X.offset, tt = X.length;
                tt > Je && (tt = Je), Je -= tt, X.length -= tt;
                do
                  Ze[rt++] = It[mt++];
                while (--tt);
                X.length === 0 && (X.mode = K);
                break;
              case ee:
                if (Je === 0)
                  break e;
                Ze[rt++] = X.length, Je--, X.mode = K;
                break;
              case E:
                if (X.wrap) {
                  for (; Ie < 32; ) {
                    if (De === 0)
                      break e;
                    De--, Ne |= de[Re++] << Ie, Ie += 8;
                  }
                  if (st -= Je, P.total_out += st, X.total += st, st && (P.adler = X.check = X.flags ? r(X.check, Ze, st, rt - st) : t(X.check, Ze, st, rt - st)), st = Je, (X.flags ? Ne : oe(Ne)) !== X.check) {
                    P.msg = "incorrect data check", X.mode = Y;
                    break;
                  }
                  Ne = 0, Ie = 0;
                }
                X.mode = Q;
              case Q:
                if (X.wrap && X.flags) {
                  for (; Ie < 32; ) {
                    if (De === 0)
                      break e;
                    De--, Ne += de[Re++] << Ie, Ie += 8;
                  }
                  if (Ne !== (4294967295 & X.total)) {
                    P.msg = "incorrect length check", X.mode = Y;
                    break;
                  }
                  Ne = 0, Ie = 0;
                }
                X.mode = se;
              case se:
                Se = M;
                break e;
              case Y:
                Se = V;
                break e;
              case be:
                return q;
              default:
                return F;
            }
        return P.next_out = rt, P.avail_out = Je, P.next_in = Re, P.avail_in = De, X.hold = Ne, X.bits = Ie, (X.wsize || st !== P.avail_out && X.mode < Y && (X.mode < E || we !== v)) && lt(P, P.output, P.next_out, st - P.avail_out) ? (X.mode = be, q) : (at -= P.avail_in, st -= P.avail_out, P.total_in += at, P.total_out += st, X.total += st, X.wrap && st && (P.adler = X.check = X.flags ? r(X.check, Ze, st, P.next_out - st) : t(X.check, Ze, st, P.next_out - st)), P.data_type = X.bits + (X.last ? 64 : 0) + (X.mode === re ? 128 : 0) + (X.mode === B || X.mode === ne ? 256 : 0), (at === 0 && st === 0 || we === v) && Se === w && (Se = I), Se);
      }, i.inflateEnd = function(P) {
        if (!P || !P.state)
          return F;
        var we = P.state;
        return we.window && (we.window = null), P.state = null, w;
      }, i.inflateGetHeader = function(P, we) {
        var X;
        return P && P.state && 2 & (X = P.state).wrap ? (X.head = we, we.done = !1, w) : F;
      }, i.inflateSetDictionary = function(P, we) {
        var X, de = we.length;
        return P && P.state ? (X = P.state).wrap !== 0 && X.mode !== L ? F : X.mode === L && t(1, we, de, 0) !== X.check ? V : lt(P, we, de, de) ? (X.mode = be, q) : (X.havedict = 1, w) : F;
      }, i.inflateInfo = "pako inflate (from Nodeca project)";
    }, { "../utils/common": 49, "./adler32": 50, "./crc32": 52, "./inffast": 54, "./inftrees": 56 }], 56: [function(e, f, i) {
      var a = e("../utils/common"), t = 15, r = [3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0], o = [16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78], n = [1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0], u = [16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64];
      f.exports = function(p, g, v, x, b, w, M, G) {
        var F, V, q, I, _, R, W, O, j, U = G.bits, C = 0, ae = 0, J = 0, te = 0, $ = 0, L = 0, re = 0, z = 0, N = 0, ne = 0, le = null, he = 0, k = new a.Buf16(16), T = new a.Buf16(16), B = null, K = 0;
        for (C = 0; C <= t; C++)
          k[C] = 0;
        for (ae = 0; ae < x; ae++)
          k[g[v + ae]]++;
        for ($ = U, te = t; te >= 1 && k[te] === 0; te--)
          ;
        if ($ > te && ($ = te), te === 0)
          return b[w++] = 20971520, b[w++] = 20971520, G.bits = 1, 0;
        for (J = 1; J < te && k[J] === 0; J++)
          ;
        for ($ < J && ($ = J), z = 1, C = 1; C <= t; C++)
          if (z <<= 1, (z -= k[C]) < 0)
            return -1;
        if (z > 0 && (p === 0 || te !== 1))
          return -1;
        for (T[1] = 0, C = 1; C < t; C++)
          T[C + 1] = T[C] + k[C];
        for (ae = 0; ae < x; ae++)
          g[v + ae] !== 0 && (M[T[g[v + ae]]++] = ae);
        if (p === 0 ? (le = B = M, R = 19) : p === 1 ? (le = r, he -= 257, B = o, K -= 257, R = 256) : (le = n, B = u, R = -1), ne = 0, ae = 0, C = J, _ = w, L = $, re = 0, q = -1, I = (N = 1 << $) - 1, p === 1 && N > 852 || p === 2 && N > 592)
          return 1;
        for (; ; ) {
          W = C - re, M[ae] < R ? (O = 0, j = M[ae]) : M[ae] > R ? (O = B[K + M[ae]], j = le[he + M[ae]]) : (O = 96, j = 0), F = 1 << C - re, J = V = 1 << L;
          do
            b[_ + (ne >> re) + (V -= F)] = W << 24 | O << 16 | j | 0;
          while (V !== 0);
          for (F = 1 << C - 1; ne & F; )
            F >>= 1;
          if (F !== 0 ? (ne &= F - 1, ne += F) : ne = 0, ae++, --k[C] == 0) {
            if (C === te)
              break;
            C = g[v + M[ae]];
          }
          if (C > $ && (ne & I) !== q) {
            for (re === 0 && (re = $), _ += J, z = 1 << (L = C - re); L + re < te && !((z -= k[L + re]) <= 0); )
              L++, z <<= 1;
            if (N += 1 << L, p === 1 && N > 852 || p === 2 && N > 592)
              return 1;
            b[q = ne & I] = $ << 24 | L << 16 | _ - w | 0;
          }
        }
        return ne !== 0 && (b[_ + ne] = C - re << 24 | 4194304 | 0), G.bits = $, 0;
      };
    }, { "../utils/common": 49 }], 57: [function(e, f, i) {
      f.exports = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" };
    }, {}], 58: [function(e, f, i) {
      var a = e("../utils/common"), t = 4, r = 0, o = 1, n = 2;
      function u(oe) {
        for (var ce = oe.length; --ce >= 0; )
          oe[ce] = 0;
      }
      var p = 0, g = 1, v = 2, x = 29, b = 256, w = b + 1 + x, M = 30, G = 19, F = 2 * w + 1, V = 15, q = 16, I = 7, _ = 256, R = 16, W = 17, O = 18, j = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], U = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], C = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], ae = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], J = new Array(2 * (w + 2));
      u(J);
      var te = new Array(2 * M);
      u(te);
      var $ = new Array(512);
      u($);
      var L = new Array(256);
      u(L);
      var re = new Array(x);
      u(re);
      var z, N, ne, le = new Array(M);
      function he(oe, ce, xe, Ce, _e) {
        this.static_tree = oe, this.extra_bits = ce, this.extra_base = xe, this.elems = Ce, this.max_length = _e, this.has_stree = oe && oe.length;
      }
      function k(oe, ce) {
        this.dyn_tree = oe, this.max_code = 0, this.stat_desc = ce;
      }
      function T(oe) {
        return oe < 256 ? $[oe] : $[256 + (oe >>> 7)];
      }
      function B(oe, ce) {
        oe.pending_buf[oe.pending++] = 255 & ce, oe.pending_buf[oe.pending++] = ce >>> 8 & 255;
      }
      function K(oe, ce, xe) {
        oe.bi_valid > q - xe ? (oe.bi_buf |= ce << oe.bi_valid & 65535, B(oe, oe.bi_buf), oe.bi_buf = ce >> q - oe.bi_valid, oe.bi_valid += xe - q) : (oe.bi_buf |= ce << oe.bi_valid & 65535, oe.bi_valid += xe);
      }
      function h(oe, ce, xe) {
        K(oe, xe[2 * ce], xe[2 * ce + 1]);
      }
      function c(oe, ce) {
        var xe = 0;
        do
          xe |= 1 & oe, oe >>>= 1, xe <<= 1;
        while (--ce > 0);
        return xe >>> 1;
      }
      function m(oe, ce, xe) {
        var Ce, _e, Be = new Array(V + 1), Pe = 0;
        for (Ce = 1; Ce <= V; Ce++)
          Be[Ce] = Pe = Pe + xe[Ce - 1] << 1;
        for (_e = 0; _e <= ce; _e++) {
          var Fe = oe[2 * _e + 1];
          Fe !== 0 && (oe[2 * _e] = c(Be[Fe]++, Fe));
        }
      }
      function D(oe) {
        var ce;
        for (ce = 0; ce < w; ce++)
          oe.dyn_ltree[2 * ce] = 0;
        for (ce = 0; ce < M; ce++)
          oe.dyn_dtree[2 * ce] = 0;
        for (ce = 0; ce < G; ce++)
          oe.bl_tree[2 * ce] = 0;
        oe.dyn_ltree[2 * _] = 1, oe.opt_len = oe.static_len = 0, oe.last_lit = oe.matches = 0;
      }
      function ee(oe) {
        oe.bi_valid > 8 ? B(oe, oe.bi_buf) : oe.bi_valid > 0 && (oe.pending_buf[oe.pending++] = oe.bi_buf), oe.bi_buf = 0, oe.bi_valid = 0;
      }
      function E(oe, ce, xe, Ce) {
        var _e = 2 * ce, Be = 2 * xe;
        return oe[_e] < oe[Be] || oe[_e] === oe[Be] && Ce[ce] <= Ce[xe];
      }
      function Q(oe, ce, xe) {
        for (var Ce = oe.heap[xe], _e = xe << 1; _e <= oe.heap_len && (_e < oe.heap_len && E(ce, oe.heap[_e + 1], oe.heap[_e], oe.depth) && _e++, !E(ce, Ce, oe.heap[_e], oe.depth)); )
          oe.heap[xe] = oe.heap[_e], xe = _e, _e <<= 1;
        oe.heap[xe] = Ce;
      }
      function se(oe, ce, xe) {
        var Ce, _e, Be, Pe, Fe = 0;
        if (oe.last_lit !== 0)
          do
            Ce = oe.pending_buf[oe.d_buf + 2 * Fe] << 8 | oe.pending_buf[oe.d_buf + 2 * Fe + 1], _e = oe.pending_buf[oe.l_buf + Fe], Fe++, Ce === 0 ? h(oe, _e, ce) : (h(oe, (Be = L[_e]) + b + 1, ce), (Pe = j[Be]) !== 0 && K(oe, _e -= re[Be], Pe), h(oe, Be = T(--Ce), xe), (Pe = U[Be]) !== 0 && K(oe, Ce -= le[Be], Pe));
          while (Fe < oe.last_lit);
        h(oe, _, ce);
      }
      function Y(oe, ce) {
        var xe, Ce, _e, Be = ce.dyn_tree, Pe = ce.stat_desc.static_tree, Fe = ce.stat_desc.has_stree, We = ce.stat_desc.elems, Qe = -1;
        for (oe.heap_len = 0, oe.heap_max = F, xe = 0; xe < We; xe++)
          Be[2 * xe] !== 0 ? (oe.heap[++oe.heap_len] = Qe = xe, oe.depth[xe] = 0) : Be[2 * xe + 1] = 0;
        for (; oe.heap_len < 2; )
          Be[2 * (_e = oe.heap[++oe.heap_len] = Qe < 2 ? ++Qe : 0)] = 1, oe.depth[_e] = 0, oe.opt_len--, Fe && (oe.static_len -= Pe[2 * _e + 1]);
        for (ce.max_code = Qe, xe = oe.heap_len >> 1; xe >= 1; xe--)
          Q(oe, Be, xe);
        _e = We;
        do
          xe = oe.heap[1], oe.heap[1] = oe.heap[oe.heap_len--], Q(oe, Be, 1), Ce = oe.heap[1], oe.heap[--oe.heap_max] = xe, oe.heap[--oe.heap_max] = Ce, Be[2 * _e] = Be[2 * xe] + Be[2 * Ce], oe.depth[_e] = (oe.depth[xe] >= oe.depth[Ce] ? oe.depth[xe] : oe.depth[Ce]) + 1, Be[2 * xe + 1] = Be[2 * Ce + 1] = _e, oe.heap[1] = _e++, Q(oe, Be, 1);
        while (oe.heap_len >= 2);
        oe.heap[--oe.heap_max] = oe.heap[1], function(lt, P) {
          var we, X, de, Ze, Re, rt, De = P.dyn_tree, Je = P.max_code, Ne = P.stat_desc.static_tree, Ie = P.stat_desc.has_stree, at = P.stat_desc.extra_bits, st = P.stat_desc.extra_base, tt = P.stat_desc.max_length, mt = 0;
          for (Ze = 0; Ze <= V; Ze++)
            lt.bl_count[Ze] = 0;
          for (De[2 * lt.heap[lt.heap_max] + 1] = 0, we = lt.heap_max + 1; we < F; we++)
            (Ze = De[2 * De[2 * (X = lt.heap[we]) + 1] + 1] + 1) > tt && (Ze = tt, mt++), De[2 * X + 1] = Ze, X > Je || (lt.bl_count[Ze]++, Re = 0, X >= st && (Re = at[X - st]), rt = De[2 * X], lt.opt_len += rt * (Ze + Re), Ie && (lt.static_len += rt * (Ne[2 * X + 1] + Re)));
          if (mt !== 0) {
            do {
              for (Ze = tt - 1; lt.bl_count[Ze] === 0; )
                Ze--;
              lt.bl_count[Ze]--, lt.bl_count[Ze + 1] += 2, lt.bl_count[tt]--, mt -= 2;
            } while (mt > 0);
            for (Ze = tt; Ze !== 0; Ze--)
              for (X = lt.bl_count[Ze]; X !== 0; )
                (de = lt.heap[--we]) > Je || (De[2 * de + 1] !== Ze && (lt.opt_len += (Ze - De[2 * de + 1]) * De[2 * de], De[2 * de + 1] = Ze), X--);
          }
        }(oe, ce), m(Be, Qe, oe.bl_count);
      }
      function be(oe, ce, xe) {
        var Ce, _e, Be = -1, Pe = ce[1], Fe = 0, We = 7, Qe = 4;
        for (Pe === 0 && (We = 138, Qe = 3), ce[2 * (xe + 1) + 1] = 65535, Ce = 0; Ce <= xe; Ce++)
          _e = Pe, Pe = ce[2 * (Ce + 1) + 1], ++Fe < We && _e === Pe || (Fe < Qe ? oe.bl_tree[2 * _e] += Fe : _e !== 0 ? (_e !== Be && oe.bl_tree[2 * _e]++, oe.bl_tree[2 * R]++) : Fe <= 10 ? oe.bl_tree[2 * W]++ : oe.bl_tree[2 * O]++, Fe = 0, Be = _e, Pe === 0 ? (We = 138, Qe = 3) : _e === Pe ? (We = 6, Qe = 3) : (We = 7, Qe = 4));
      }
      function Ee(oe, ce, xe) {
        var Ce, _e, Be = -1, Pe = ce[1], Fe = 0, We = 7, Qe = 4;
        for (Pe === 0 && (We = 138, Qe = 3), Ce = 0; Ce <= xe; Ce++)
          if (_e = Pe, Pe = ce[2 * (Ce + 1) + 1], !(++Fe < We && _e === Pe)) {
            if (Fe < Qe)
              do
                h(oe, _e, oe.bl_tree);
              while (--Fe != 0);
            else
              _e !== 0 ? (_e !== Be && (h(oe, _e, oe.bl_tree), Fe--), h(oe, R, oe.bl_tree), K(oe, Fe - 3, 2)) : Fe <= 10 ? (h(oe, W, oe.bl_tree), K(oe, Fe - 3, 3)) : (h(oe, O, oe.bl_tree), K(oe, Fe - 11, 7));
            Fe = 0, Be = _e, Pe === 0 ? (We = 138, Qe = 3) : _e === Pe ? (We = 6, Qe = 3) : (We = 7, Qe = 4);
          }
      }
      u(le);
      var Me = !1;
      function ke(oe, ce, xe, Ce) {
        K(oe, (p << 1) + (Ce ? 1 : 0), 3), function(_e, Be, Pe, Fe) {
          ee(_e), Fe && (B(_e, Pe), B(_e, ~Pe)), a.arraySet(_e.pending_buf, _e.window, Be, Pe, _e.pending), _e.pending += Pe;
        }(oe, ce, xe, !0);
      }
      i._tr_init = function(oe) {
        Me || (function() {
          var ce, xe, Ce, _e, Be, Pe = new Array(V + 1);
          for (Ce = 0, _e = 0; _e < x - 1; _e++)
            for (re[_e] = Ce, ce = 0; ce < 1 << j[_e]; ce++)
              L[Ce++] = _e;
          for (L[Ce - 1] = _e, Be = 0, _e = 0; _e < 16; _e++)
            for (le[_e] = Be, ce = 0; ce < 1 << U[_e]; ce++)
              $[Be++] = _e;
          for (Be >>= 7; _e < M; _e++)
            for (le[_e] = Be << 7, ce = 0; ce < 1 << U[_e] - 7; ce++)
              $[256 + Be++] = _e;
          for (xe = 0; xe <= V; xe++)
            Pe[xe] = 0;
          for (ce = 0; ce <= 143; )
            J[2 * ce + 1] = 8, ce++, Pe[8]++;
          for (; ce <= 255; )
            J[2 * ce + 1] = 9, ce++, Pe[9]++;
          for (; ce <= 279; )
            J[2 * ce + 1] = 7, ce++, Pe[7]++;
          for (; ce <= 287; )
            J[2 * ce + 1] = 8, ce++, Pe[8]++;
          for (m(J, w + 1, Pe), ce = 0; ce < M; ce++)
            te[2 * ce + 1] = 5, te[2 * ce] = c(ce, 5);
          z = new he(J, j, b + 1, w, V), N = new he(te, U, 0, M, V), ne = new he(new Array(0), C, 0, G, I);
        }(), Me = !0), oe.l_desc = new k(oe.dyn_ltree, z), oe.d_desc = new k(oe.dyn_dtree, N), oe.bl_desc = new k(oe.bl_tree, ne), oe.bi_buf = 0, oe.bi_valid = 0, D(oe);
      }, i._tr_stored_block = ke, i._tr_flush_block = function(oe, ce, xe, Ce) {
        var _e, Be, Pe = 0;
        oe.level > 0 ? (oe.strm.data_type === n && (oe.strm.data_type = function(Fe) {
          var We, Qe = 4093624447;
          for (We = 0; We <= 31; We++, Qe >>>= 1)
            if (1 & Qe && Fe.dyn_ltree[2 * We] !== 0)
              return r;
          if (Fe.dyn_ltree[18] !== 0 || Fe.dyn_ltree[20] !== 0 || Fe.dyn_ltree[26] !== 0)
            return o;
          for (We = 32; We < b; We++)
            if (Fe.dyn_ltree[2 * We] !== 0)
              return o;
          return r;
        }(oe)), Y(oe, oe.l_desc), Y(oe, oe.d_desc), Pe = function(Fe) {
          var We;
          for (be(Fe, Fe.dyn_ltree, Fe.l_desc.max_code), be(Fe, Fe.dyn_dtree, Fe.d_desc.max_code), Y(Fe, Fe.bl_desc), We = G - 1; We >= 3 && Fe.bl_tree[2 * ae[We] + 1] === 0; We--)
            ;
          return Fe.opt_len += 3 * (We + 1) + 5 + 5 + 4, We;
        }(oe), _e = oe.opt_len + 3 + 7 >>> 3, (Be = oe.static_len + 3 + 7 >>> 3) <= _e && (_e = Be)) : _e = Be = xe + 5, xe + 4 <= _e && ce !== -1 ? ke(oe, ce, xe, Ce) : oe.strategy === t || Be === _e ? (K(oe, (g << 1) + (Ce ? 1 : 0), 3), se(oe, J, te)) : (K(oe, (v << 1) + (Ce ? 1 : 0), 3), function(Fe, We, Qe, lt) {
          var P;
          for (K(Fe, We - 257, 5), K(Fe, Qe - 1, 5), K(Fe, lt - 4, 4), P = 0; P < lt; P++)
            K(Fe, Fe.bl_tree[2 * ae[P] + 1], 3);
          Ee(Fe, Fe.dyn_ltree, We - 1), Ee(Fe, Fe.dyn_dtree, Qe - 1);
        }(oe, oe.l_desc.max_code + 1, oe.d_desc.max_code + 1, Pe + 1), se(oe, oe.dyn_ltree, oe.dyn_dtree)), D(oe), Ce && ee(oe);
      }, i._tr_tally = function(oe, ce, xe) {
        return oe.pending_buf[oe.d_buf + 2 * oe.last_lit] = ce >>> 8 & 255, oe.pending_buf[oe.d_buf + 2 * oe.last_lit + 1] = 255 & ce, oe.pending_buf[oe.l_buf + oe.last_lit] = 255 & xe, oe.last_lit++, ce === 0 ? oe.dyn_ltree[2 * xe]++ : (oe.matches++, ce--, oe.dyn_ltree[2 * (L[xe] + b + 1)]++, oe.dyn_dtree[2 * T(ce)]++), oe.last_lit === oe.lit_bufsize - 1;
      }, i._tr_align = function(oe) {
        K(oe, g << 1, 3), h(oe, _, J), function(ce) {
          ce.bi_valid === 16 ? (B(ce, ce.bi_buf), ce.bi_buf = 0, ce.bi_valid = 0) : ce.bi_valid >= 8 && (ce.pending_buf[ce.pending++] = 255 & ce.bi_buf, ce.bi_buf >>= 8, ce.bi_valid -= 8);
        }(oe);
      };
    }, { "../utils/common": 49 }], 59: [function(e, f, i) {
      f.exports = function() {
        this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0;
      };
    }, {}], 60: [function(e, f, i) {
      var a, t, r = f.exports = {};
      function o() {
        throw new Error("setTimeout has not been defined");
      }
      function n() {
        throw new Error("clearTimeout has not been defined");
      }
      function u(F) {
        if (a === setTimeout)
          return setTimeout(F, 0);
        if ((a === o || !a) && setTimeout)
          return a = setTimeout, setTimeout(F, 0);
        try {
          return a(F, 0);
        } catch {
          try {
            return a.call(null, F, 0);
          } catch {
            return a.call(this, F, 0);
          }
        }
      }
      (function() {
        try {
          a = typeof setTimeout == "function" ? setTimeout : o;
        } catch {
          a = o;
        }
        try {
          t = typeof clearTimeout == "function" ? clearTimeout : n;
        } catch {
          t = n;
        }
      })();
      var p, g = [], v = !1, x = -1;
      function b() {
        v && p && (v = !1, p.length ? g = p.concat(g) : x = -1, g.length && w());
      }
      function w() {
        if (!v) {
          var F = u(b);
          v = !0;
          for (var V = g.length; V; ) {
            for (p = g, g = []; ++x < V; )
              p && p[x].run();
            x = -1, V = g.length;
          }
          p = null, v = !1, function(q) {
            if (t === clearTimeout)
              return clearTimeout(q);
            if ((t === n || !t) && clearTimeout)
              return t = clearTimeout, clearTimeout(q);
            try {
              t(q);
            } catch {
              try {
                return t.call(null, q);
              } catch {
                return t.call(this, q);
              }
            }
          }(F);
        }
      }
      function M(F, V) {
        this.fun = F, this.array = V;
      }
      function G() {
      }
      r.nextTick = function(F) {
        var V = new Array(arguments.length - 1);
        if (arguments.length > 1)
          for (var q = 1; q < arguments.length; q++)
            V[q - 1] = arguments[q];
        g.push(new M(F, V)), g.length !== 1 || v || u(w);
      }, M.prototype.run = function() {
        this.fun.apply(null, this.array);
      }, r.title = "browser", r.browser = !0, r.env = {}, r.argv = [], r.version = "", r.versions = {}, r.on = G, r.addListener = G, r.once = G, r.off = G, r.removeListener = G, r.removeAllListeners = G, r.emit = G, r.prependListener = G, r.prependOnceListener = G, r.listeners = function(F) {
        return [];
      }, r.binding = function(F) {
        throw new Error("process.binding is not supported");
      }, r.cwd = function() {
        return "/";
      }, r.chdir = function(F) {
        throw new Error("process.chdir is not supported");
      }, r.umask = function() {
        return 0;
      };
    }, {}], 61: [function(e, f, i) {
      f.exports = t;
      var a = e("events").EventEmitter;
      function t() {
        a.call(this);
      }
      e("inherits")(t, a), t.Readable = e("readable-stream/lib/_stream_readable.js"), t.Writable = e("readable-stream/lib/_stream_writable.js"), t.Duplex = e("readable-stream/lib/_stream_duplex.js"), t.Transform = e("readable-stream/lib/_stream_transform.js"), t.PassThrough = e("readable-stream/lib/_stream_passthrough.js"), t.finished = e("readable-stream/lib/internal/streams/end-of-stream.js"), t.pipeline = e("readable-stream/lib/internal/streams/pipeline.js"), t.Stream = t, t.prototype.pipe = function(r, o) {
        var n = this;
        function u(M) {
          r.writable && r.write(M) === !1 && n.pause && n.pause();
        }
        function p() {
          n.readable && n.resume && n.resume();
        }
        n.on("data", u), r.on("drain", p), r._isStdio || o && o.end === !1 || (n.on("end", v), n.on("close", x));
        var g = !1;
        function v() {
          g || (g = !0, r.end());
        }
        function x() {
          g || (g = !0, typeof r.destroy == "function" && r.destroy());
        }
        function b(M) {
          if (w(), a.listenerCount(this, "error") === 0)
            throw M;
        }
        function w() {
          n.removeListener("data", u), r.removeListener("drain", p), n.removeListener("end", v), n.removeListener("close", x), n.removeListener("error", b), r.removeListener("error", b), n.removeListener("end", w), n.removeListener("close", w), r.removeListener("close", w);
        }
        return n.on("error", b), r.on("error", b), n.on("end", w), n.on("close", w), r.on("close", w), r.emit("pipe", n), r;
      };
    }, { events: 38, inherits: 45, "readable-stream/lib/_stream_duplex.js": 63, "readable-stream/lib/_stream_passthrough.js": 64, "readable-stream/lib/_stream_readable.js": 65, "readable-stream/lib/_stream_transform.js": 66, "readable-stream/lib/_stream_writable.js": 67, "readable-stream/lib/internal/streams/end-of-stream.js": 71, "readable-stream/lib/internal/streams/pipeline.js": 73 }], 62: [function(e, f, i) {
      var a = {};
      function t(o, n, u) {
        u || (u = Error);
        var p = function(g) {
          function v(w, M, G) {
            return g.call(this, function(F, V, q) {
              return typeof n == "string" ? n : n(F, V, q);
            }(w, M, G)) || this;
          }
          return b = g, (x = v).prototype = Object.create(b.prototype), x.prototype.constructor = x, x.__proto__ = b, v;
          var x, b;
        }(u);
        p.prototype.name = u.name, p.prototype.code = o, a[o] = p;
      }
      function r(o, n) {
        if (Array.isArray(o)) {
          var u = o.length;
          return o = o.map(function(p) {
            return String(p);
          }), u > 2 ? "one of ".concat(n, " ").concat(o.slice(0, u - 1).join(", "), ", or ") + o[u - 1] : u === 2 ? "one of ".concat(n, " ").concat(o[0], " or ").concat(o[1]) : "of ".concat(n, " ").concat(o[0]);
        }
        return "of ".concat(n, " ").concat(String(o));
      }
      t("ERR_INVALID_OPT_VALUE", function(o, n) {
        return 'The value "' + n + '" is invalid for option "' + o + '"';
      }, TypeError), t("ERR_INVALID_ARG_TYPE", function(o, n, u) {
        var p, g, v;
        if (typeof n == "string" && (v = "not ", n.substr(0, v.length) === v) ? (p = "must not be", n = n.replace(/^not /, "")) : p = "must be", function(b, w, M) {
          return (M === void 0 || M > b.length) && (M = b.length), b.substring(M - w.length, M) === w;
        }(o, " argument"))
          g = "The ".concat(o, " ").concat(p, " ").concat(r(n, "type"));
        else {
          var x = function(b, w, M) {
            return typeof M != "number" && (M = 0), !(M + w.length > b.length) && b.indexOf(w, M) !== -1;
          }(o, ".") ? "property" : "argument";
          g = 'The "'.concat(o, '" ').concat(x, " ").concat(p, " ").concat(r(n, "type"));
        }
        return g + ". Received type ".concat(typeof u);
      }, TypeError), t("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF"), t("ERR_METHOD_NOT_IMPLEMENTED", function(o) {
        return "The " + o + " method is not implemented";
      }), t("ERR_STREAM_PREMATURE_CLOSE", "Premature close"), t("ERR_STREAM_DESTROYED", function(o) {
        return "Cannot call " + o + " after a stream was destroyed";
      }), t("ERR_MULTIPLE_CALLBACK", "Callback called multiple times"), t("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable"), t("ERR_STREAM_WRITE_AFTER_END", "write after end"), t("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError), t("ERR_UNKNOWN_ENCODING", function(o) {
        return "Unknown encoding: " + o;
      }, TypeError), t("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event"), f.exports.codes = a;
    }, {}], 63: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = Object.keys || function(b) {
            var w = [];
            for (var M in b)
              w.push(M);
            return w;
          };
          f.exports = g;
          var r = e("./_stream_readable"), o = e("./_stream_writable");
          e("inherits")(g, r);
          for (var n = t(o.prototype), u = 0; u < n.length; u++) {
            var p = n[u];
            g.prototype[p] || (g.prototype[p] = o.prototype[p]);
          }
          function g(b) {
            if (!(this instanceof g))
              return new g(b);
            r.call(this, b), o.call(this, b), this.allowHalfOpen = !0, b && (b.readable === !1 && (this.readable = !1), b.writable === !1 && (this.writable = !1), b.allowHalfOpen === !1 && (this.allowHalfOpen = !1, this.once("end", v)));
          }
          function v() {
            this._writableState.ended || a.nextTick(x, this);
          }
          function x(b) {
            b.end();
          }
          Object.defineProperty(g.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), Object.defineProperty(g.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(g.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(g.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._writableState !== void 0 && this._readableState.destroyed && this._writableState.destroyed;
          }, set: function(b) {
            this._readableState !== void 0 && this._writableState !== void 0 && (this._readableState.destroyed = b, this._writableState.destroyed = b);
          } });
        }).call(this);
      }).call(this, e("_process"));
    }, { "./_stream_readable": 65, "./_stream_writable": 67, _process: 60, inherits: 45 }], 64: [function(e, f, i) {
      f.exports = t;
      var a = e("./_stream_transform");
      function t(r) {
        if (!(this instanceof t))
          return new t(r);
        a.call(this, r);
      }
      e("inherits")(t, a), t.prototype._transform = function(r, o, n) {
        n(null, r);
      };
    }, { "./_stream_transform": 66, inherits: 45 }], 65: [function(e, f, i) {
      (function(a, t) {
        (function() {
          var r;
          f.exports = U, U.ReadableState = j, e("events").EventEmitter;
          var o = function(h, c) {
            return h.listeners(c).length;
          }, n = e("./internal/streams/stream"), u = e("buffer").Buffer, p = t.Uint8Array || function() {
          }, g, v = e("util");
          g = v && v.debuglog ? v.debuglog("stream") : function() {
          };
          var x, b, w, M = e("./internal/streams/buffer_list"), G = e("./internal/streams/destroy"), F = e("./internal/streams/state").getHighWaterMark, V = e("../errors").codes, q = V.ERR_INVALID_ARG_TYPE, I = V.ERR_STREAM_PUSH_AFTER_EOF, _ = V.ERR_METHOD_NOT_IMPLEMENTED, R = V.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
          e("inherits")(U, n);
          var W = G.errorOrDestroy, O = ["error", "close", "destroy", "pause", "resume"];
          function j(h, c, m) {
            r = r || e("./_stream_duplex"), h = h || {}, typeof m != "boolean" && (m = c instanceof r), this.objectMode = !!h.objectMode, m && (this.objectMode = this.objectMode || !!h.readableObjectMode), this.highWaterMark = F(this, h, "readableHighWaterMark", m), this.buffer = new M(), this.length = 0, this.pipes = null, this.pipesCount = 0, this.flowing = null, this.ended = !1, this.endEmitted = !1, this.reading = !1, this.sync = !0, this.needReadable = !1, this.emittedReadable = !1, this.readableListening = !1, this.resumeScheduled = !1, this.paused = !0, this.emitClose = h.emitClose !== !1, this.autoDestroy = !!h.autoDestroy, this.destroyed = !1, this.defaultEncoding = h.defaultEncoding || "utf8", this.awaitDrain = 0, this.readingMore = !1, this.decoder = null, this.encoding = null, h.encoding && (x || (x = e("string_decoder/").StringDecoder), this.decoder = new x(h.encoding), this.encoding = h.encoding);
          }
          function U(h) {
            if (r = r || e("./_stream_duplex"), !(this instanceof U))
              return new U(h);
            var c = this instanceof r;
            this._readableState = new j(h, this, c), this.readable = !0, h && (typeof h.read == "function" && (this._read = h.read), typeof h.destroy == "function" && (this._destroy = h.destroy)), n.call(this);
          }
          function C(h, c, m, D, ee) {
            g("readableAddChunk", c);
            var E, Q = h._readableState;
            if (c === null)
              Q.reading = !1, function(se, Y) {
                if (g("onEofChunk"), !Y.ended) {
                  if (Y.decoder) {
                    var be = Y.decoder.end();
                    be && be.length && (Y.buffer.push(be), Y.length += Y.objectMode ? 1 : be.length);
                  }
                  Y.ended = !0, Y.sync ? $(se) : (Y.needReadable = !1, Y.emittedReadable || (Y.emittedReadable = !0, L(se)));
                }
              }(h, Q);
            else if (ee || (E = function(se, Y) {
              var be;
              return Ee = Y, u.isBuffer(Ee) || Ee instanceof p || typeof Y == "string" || Y === void 0 || se.objectMode || (be = new q("chunk", ["string", "Buffer", "Uint8Array"], Y)), be;
              var Ee;
            }(Q, c)), E)
              W(h, E);
            else if (Q.objectMode || c && c.length > 0)
              if (typeof c == "string" || Q.objectMode || Object.getPrototypeOf(c) === u.prototype || (c = function(se) {
                return u.from(se);
              }(c)), D)
                Q.endEmitted ? W(h, new R()) : ae(h, Q, c, !0);
              else if (Q.ended)
                W(h, new I());
              else {
                if (Q.destroyed)
                  return !1;
                Q.reading = !1, Q.decoder && !m ? (c = Q.decoder.write(c), Q.objectMode || c.length !== 0 ? ae(h, Q, c, !1) : re(h, Q)) : ae(h, Q, c, !1);
              }
            else
              D || (Q.reading = !1, re(h, Q));
            return !Q.ended && (Q.length < Q.highWaterMark || Q.length === 0);
          }
          function ae(h, c, m, D) {
            c.flowing && c.length === 0 && !c.sync ? (c.awaitDrain = 0, h.emit("data", m)) : (c.length += c.objectMode ? 1 : m.length, D ? c.buffer.unshift(m) : c.buffer.push(m), c.needReadable && $(h)), re(h, c);
          }
          Object.defineProperty(U.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._readableState !== void 0 && this._readableState.destroyed;
          }, set: function(h) {
            this._readableState && (this._readableState.destroyed = h);
          } }), U.prototype.destroy = G.destroy, U.prototype._undestroy = G.undestroy, U.prototype._destroy = function(h, c) {
            c(h);
          }, U.prototype.push = function(h, c) {
            var m, D = this._readableState;
            return D.objectMode ? m = !0 : typeof h == "string" && ((c = c || D.defaultEncoding) !== D.encoding && (h = u.from(h, c), c = ""), m = !0), C(this, h, c, !1, m);
          }, U.prototype.unshift = function(h) {
            return C(this, h, null, !0, !1);
          }, U.prototype.isPaused = function() {
            return this._readableState.flowing === !1;
          }, U.prototype.setEncoding = function(h) {
            x || (x = e("string_decoder/").StringDecoder);
            var c = new x(h);
            this._readableState.decoder = c, this._readableState.encoding = this._readableState.decoder.encoding;
            for (var m = this._readableState.buffer.head, D = ""; m !== null; )
              D += c.write(m.data), m = m.next;
            return this._readableState.buffer.clear(), D !== "" && this._readableState.buffer.push(D), this._readableState.length = D.length, this;
          };
          var J = 1073741824;
          function te(h, c) {
            return h <= 0 || c.length === 0 && c.ended ? 0 : c.objectMode ? 1 : h != h ? c.flowing && c.length ? c.buffer.head.data.length : c.length : (h > c.highWaterMark && (c.highWaterMark = function(m) {
              return m >= J ? m = J : (m--, m |= m >>> 1, m |= m >>> 2, m |= m >>> 4, m |= m >>> 8, m |= m >>> 16, m++), m;
            }(h)), h <= c.length ? h : c.ended ? c.length : (c.needReadable = !0, 0));
          }
          function $(h) {
            var c = h._readableState;
            g("emitReadable", c.needReadable, c.emittedReadable), c.needReadable = !1, c.emittedReadable || (g("emitReadable", c.flowing), c.emittedReadable = !0, a.nextTick(L, h));
          }
          function L(h) {
            var c = h._readableState;
            g("emitReadable_", c.destroyed, c.length, c.ended), c.destroyed || !c.length && !c.ended || (h.emit("readable"), c.emittedReadable = !1), c.needReadable = !c.flowing && !c.ended && c.length <= c.highWaterMark, he(h);
          }
          function re(h, c) {
            c.readingMore || (c.readingMore = !0, a.nextTick(z, h, c));
          }
          function z(h, c) {
            for (; !c.reading && !c.ended && (c.length < c.highWaterMark || c.flowing && c.length === 0); ) {
              var m = c.length;
              if (g("maybeReadMore read 0"), h.read(0), m === c.length)
                break;
            }
            c.readingMore = !1;
          }
          function N(h) {
            var c = h._readableState;
            c.readableListening = h.listenerCount("readable") > 0, c.resumeScheduled && !c.paused ? c.flowing = !0 : h.listenerCount("data") > 0 && h.resume();
          }
          function ne(h) {
            g("readable nexttick read 0"), h.read(0);
          }
          function le(h, c) {
            g("resume", c.reading), c.reading || h.read(0), c.resumeScheduled = !1, h.emit("resume"), he(h), c.flowing && !c.reading && h.read(0);
          }
          function he(h) {
            var c = h._readableState;
            for (g("flow", c.flowing); c.flowing && h.read() !== null; )
              ;
          }
          function k(h, c) {
            return c.length === 0 ? null : (c.objectMode ? m = c.buffer.shift() : !h || h >= c.length ? (m = c.decoder ? c.buffer.join("") : c.buffer.length === 1 ? c.buffer.first() : c.buffer.concat(c.length), c.buffer.clear()) : m = c.buffer.consume(h, c.decoder), m);
            var m;
          }
          function T(h) {
            var c = h._readableState;
            g("endReadable", c.endEmitted), c.endEmitted || (c.ended = !0, a.nextTick(B, c, h));
          }
          function B(h, c) {
            if (g("endReadableNT", h.endEmitted, h.length), !h.endEmitted && h.length === 0 && (h.endEmitted = !0, c.readable = !1, c.emit("end"), h.autoDestroy)) {
              var m = c._writableState;
              (!m || m.autoDestroy && m.finished) && c.destroy();
            }
          }
          function K(h, c) {
            for (var m = 0, D = h.length; m < D; m++)
              if (h[m] === c)
                return m;
            return -1;
          }
          U.prototype.read = function(h) {
            g("read", h), h = parseInt(h, 10);
            var c = this._readableState, m = h;
            if (h !== 0 && (c.emittedReadable = !1), h === 0 && c.needReadable && ((c.highWaterMark !== 0 ? c.length >= c.highWaterMark : c.length > 0) || c.ended))
              return g("read: emitReadable", c.length, c.ended), c.length === 0 && c.ended ? T(this) : $(this), null;
            if ((h = te(h, c)) === 0 && c.ended)
              return c.length === 0 && T(this), null;
            var D, ee = c.needReadable;
            return g("need readable", ee), (c.length === 0 || c.length - h < c.highWaterMark) && g("length less than watermark", ee = !0), c.ended || c.reading ? g("reading or ended", ee = !1) : ee && (g("do read"), c.reading = !0, c.sync = !0, c.length === 0 && (c.needReadable = !0), this._read(c.highWaterMark), c.sync = !1, c.reading || (h = te(m, c))), (D = h > 0 ? k(h, c) : null) === null ? (c.needReadable = c.length <= c.highWaterMark, h = 0) : (c.length -= h, c.awaitDrain = 0), c.length === 0 && (c.ended || (c.needReadable = !0), m !== h && c.ended && T(this)), D !== null && this.emit("data", D), D;
          }, U.prototype._read = function(h) {
            W(this, new _("_read()"));
          }, U.prototype.pipe = function(h, c) {
            var m = this, D = this._readableState;
            switch (D.pipesCount) {
              case 0:
                D.pipes = h;
                break;
              case 1:
                D.pipes = [D.pipes, h];
                break;
              default:
                D.pipes.push(h);
            }
            D.pipesCount += 1, g("pipe count=%d opts=%j", D.pipesCount, c);
            var ee = c && c.end === !1 || h === a.stdout || h === a.stderr ? oe : Q;
            function E(ce, xe) {
              g("onunpipe"), ce === m && xe && xe.hasUnpiped === !1 && (xe.hasUnpiped = !0, g("cleanup"), h.removeListener("close", Me), h.removeListener("finish", ke), h.removeListener("drain", se), h.removeListener("error", Ee), h.removeListener("unpipe", E), m.removeListener("end", Q), m.removeListener("end", oe), m.removeListener("data", be), Y = !0, !D.awaitDrain || h._writableState && !h._writableState.needDrain || se());
            }
            function Q() {
              g("onend"), h.end();
            }
            D.endEmitted ? a.nextTick(ee) : m.once("end", ee), h.on("unpipe", E);
            var se = function(ce) {
              return function() {
                var xe = ce._readableState;
                g("pipeOnDrain", xe.awaitDrain), xe.awaitDrain && xe.awaitDrain--, xe.awaitDrain === 0 && o(ce, "data") && (xe.flowing = !0, he(ce));
              };
            }(m);
            h.on("drain", se);
            var Y = !1;
            function be(ce) {
              g("ondata");
              var xe = h.write(ce);
              g("dest.write", xe), xe === !1 && ((D.pipesCount === 1 && D.pipes === h || D.pipesCount > 1 && K(D.pipes, h) !== -1) && !Y && (g("false write response, pause", D.awaitDrain), D.awaitDrain++), m.pause());
            }
            function Ee(ce) {
              g("onerror", ce), oe(), h.removeListener("error", Ee), o(h, "error") === 0 && W(h, ce);
            }
            function Me() {
              h.removeListener("finish", ke), oe();
            }
            function ke() {
              g("onfinish"), h.removeListener("close", Me), oe();
            }
            function oe() {
              g("unpipe"), m.unpipe(h);
            }
            return m.on("data", be), function(ce, xe, Ce) {
              if (typeof ce.prependListener == "function")
                return ce.prependListener(xe, Ce);
              ce._events && ce._events[xe] ? Array.isArray(ce._events[xe]) ? ce._events[xe].unshift(Ce) : ce._events[xe] = [Ce, ce._events[xe]] : ce.on(xe, Ce);
            }(h, "error", Ee), h.once("close", Me), h.once("finish", ke), h.emit("pipe", m), D.flowing || (g("pipe resume"), m.resume()), h;
          }, U.prototype.unpipe = function(h) {
            var c = this._readableState, m = { hasUnpiped: !1 };
            if (c.pipesCount === 0)
              return this;
            if (c.pipesCount === 1)
              return h && h !== c.pipes || (h || (h = c.pipes), c.pipes = null, c.pipesCount = 0, c.flowing = !1, h && h.emit("unpipe", this, m)), this;
            if (!h) {
              var D = c.pipes, ee = c.pipesCount;
              c.pipes = null, c.pipesCount = 0, c.flowing = !1;
              for (var E = 0; E < ee; E++)
                D[E].emit("unpipe", this, { hasUnpiped: !1 });
              return this;
            }
            var Q = K(c.pipes, h);
            return Q === -1 || (c.pipes.splice(Q, 1), c.pipesCount -= 1, c.pipesCount === 1 && (c.pipes = c.pipes[0]), h.emit("unpipe", this, m)), this;
          }, U.prototype.on = function(h, c) {
            var m = n.prototype.on.call(this, h, c), D = this._readableState;
            return h === "data" ? (D.readableListening = this.listenerCount("readable") > 0, D.flowing !== !1 && this.resume()) : h === "readable" && (D.endEmitted || D.readableListening || (D.readableListening = D.needReadable = !0, D.flowing = !1, D.emittedReadable = !1, g("on readable", D.length, D.reading), D.length ? $(this) : D.reading || a.nextTick(ne, this))), m;
          }, U.prototype.addListener = U.prototype.on, U.prototype.removeListener = function(h, c) {
            var m = n.prototype.removeListener.call(this, h, c);
            return h === "readable" && a.nextTick(N, this), m;
          }, U.prototype.removeAllListeners = function(h) {
            var c = n.prototype.removeAllListeners.apply(this, arguments);
            return h !== "readable" && h !== void 0 || a.nextTick(N, this), c;
          }, U.prototype.resume = function() {
            var h = this._readableState;
            return h.flowing || (g("resume"), h.flowing = !h.readableListening, function(c, m) {
              m.resumeScheduled || (m.resumeScheduled = !0, a.nextTick(le, c, m));
            }(this, h)), h.paused = !1, this;
          }, U.prototype.pause = function() {
            return g("call pause flowing=%j", this._readableState.flowing), this._readableState.flowing !== !1 && (g("pause"), this._readableState.flowing = !1, this.emit("pause")), this._readableState.paused = !0, this;
          }, U.prototype.wrap = function(h) {
            var c = this, m = this._readableState, D = !1;
            for (var ee in h.on("end", function() {
              if (g("wrapped end"), m.decoder && !m.ended) {
                var Q = m.decoder.end();
                Q && Q.length && c.push(Q);
              }
              c.push(null);
            }), h.on("data", function(Q) {
              g("wrapped data"), m.decoder && (Q = m.decoder.write(Q)), m.objectMode && Q == null || (m.objectMode || Q && Q.length) && (c.push(Q) || (D = !0, h.pause()));
            }), h)
              this[ee] === void 0 && typeof h[ee] == "function" && (this[ee] = function(Q) {
                return function() {
                  return h[Q].apply(h, arguments);
                };
              }(ee));
            for (var E = 0; E < O.length; E++)
              h.on(O[E], this.emit.bind(this, O[E]));
            return this._read = function(Q) {
              g("wrapped _read", Q), D && (D = !1, h.resume());
            }, this;
          }, typeof Symbol == "function" && (U.prototype[Symbol.asyncIterator] = function() {
            return b === void 0 && (b = e("./internal/streams/async_iterator")), b(this);
          }), Object.defineProperty(U.prototype, "readableHighWaterMark", { enumerable: !1, get: function() {
            return this._readableState.highWaterMark;
          } }), Object.defineProperty(U.prototype, "readableBuffer", { enumerable: !1, get: function() {
            return this._readableState && this._readableState.buffer;
          } }), Object.defineProperty(U.prototype, "readableFlowing", { enumerable: !1, get: function() {
            return this._readableState.flowing;
          }, set: function(h) {
            this._readableState && (this._readableState.flowing = h);
          } }), U._fromList = k, Object.defineProperty(U.prototype, "readableLength", { enumerable: !1, get: function() {
            return this._readableState.length;
          } }), typeof Symbol == "function" && (U.from = function(h, c) {
            return w === void 0 && (w = e("./internal/streams/from")), w(U, h, c);
          });
        }).call(this);
      }).call(this, e("_process"), s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 62, "./_stream_duplex": 63, "./internal/streams/async_iterator": 68, "./internal/streams/buffer_list": 69, "./internal/streams/destroy": 70, "./internal/streams/from": 72, "./internal/streams/state": 74, "./internal/streams/stream": 75, _process: 60, buffer: 33, events: 38, inherits: 45, "string_decoder/": 76, util: 30 }], 66: [function(e, f, i) {
      f.exports = g;
      var a = e("../errors").codes, t = a.ERR_METHOD_NOT_IMPLEMENTED, r = a.ERR_MULTIPLE_CALLBACK, o = a.ERR_TRANSFORM_ALREADY_TRANSFORMING, n = a.ERR_TRANSFORM_WITH_LENGTH_0, u = e("./_stream_duplex");
      function p(b, w) {
        var M = this._transformState;
        M.transforming = !1;
        var G = M.writecb;
        if (G === null)
          return this.emit("error", new r());
        M.writechunk = null, M.writecb = null, w != null && this.push(w), G(b);
        var F = this._readableState;
        F.reading = !1, (F.needReadable || F.length < F.highWaterMark) && this._read(F.highWaterMark);
      }
      function g(b) {
        if (!(this instanceof g))
          return new g(b);
        u.call(this, b), this._transformState = { afterTransform: p.bind(this), needTransform: !1, transforming: !1, writecb: null, writechunk: null, writeencoding: null }, this._readableState.needReadable = !0, this._readableState.sync = !1, b && (typeof b.transform == "function" && (this._transform = b.transform), typeof b.flush == "function" && (this._flush = b.flush)), this.on("prefinish", v);
      }
      function v() {
        var b = this;
        typeof this._flush != "function" || this._readableState.destroyed ? x(this, null, null) : this._flush(function(w, M) {
          x(b, w, M);
        });
      }
      function x(b, w, M) {
        if (w)
          return b.emit("error", w);
        if (M != null && b.push(M), b._writableState.length)
          throw new n();
        if (b._transformState.transforming)
          throw new o();
        return b.push(null);
      }
      e("inherits")(g, u), g.prototype.push = function(b, w) {
        return this._transformState.needTransform = !1, u.prototype.push.call(this, b, w);
      }, g.prototype._transform = function(b, w, M) {
        M(new t("_transform()"));
      }, g.prototype._write = function(b, w, M) {
        var G = this._transformState;
        if (G.writecb = M, G.writechunk = b, G.writeencoding = w, !G.transforming) {
          var F = this._readableState;
          (G.needTransform || F.needReadable || F.length < F.highWaterMark) && this._read(F.highWaterMark);
        }
      }, g.prototype._read = function(b) {
        var w = this._transformState;
        w.writechunk === null || w.transforming ? w.needTransform = !0 : (w.transforming = !0, this._transform(w.writechunk, w.writeencoding, w.afterTransform));
      }, g.prototype._destroy = function(b, w) {
        u.prototype._destroy.call(this, b, function(M) {
          w(M);
        });
      };
    }, { "../errors": 62, "./_stream_duplex": 63, inherits: 45 }], 67: [function(e, f, i) {
      (function(a, t) {
        (function() {
          function r(z) {
            var N = this;
            this.next = null, this.entry = null, this.finish = function() {
              (function(ne, le, he) {
                var k = ne.entry;
                for (ne.entry = null; k; ) {
                  var T = k.callback;
                  le.pendingcb--, T(he), k = k.next;
                }
                le.corkedRequestsFree.next = ne;
              })(N, z);
            };
          }
          var o;
          f.exports = U, U.WritableState = j;
          var n = { deprecate: e("util-deprecate") }, u = e("./internal/streams/stream"), p = e("buffer").Buffer, g = t.Uint8Array || function() {
          }, v, x = e("./internal/streams/destroy"), b = e("./internal/streams/state").getHighWaterMark, w = e("../errors").codes, M = w.ERR_INVALID_ARG_TYPE, G = w.ERR_METHOD_NOT_IMPLEMENTED, F = w.ERR_MULTIPLE_CALLBACK, V = w.ERR_STREAM_CANNOT_PIPE, q = w.ERR_STREAM_DESTROYED, I = w.ERR_STREAM_NULL_VALUES, _ = w.ERR_STREAM_WRITE_AFTER_END, R = w.ERR_UNKNOWN_ENCODING, W = x.errorOrDestroy;
          function O() {
          }
          function j(z, N, ne) {
            o = o || e("./_stream_duplex"), z = z || {}, typeof ne != "boolean" && (ne = N instanceof o), this.objectMode = !!z.objectMode, ne && (this.objectMode = this.objectMode || !!z.writableObjectMode), this.highWaterMark = b(this, z, "writableHighWaterMark", ne), this.finalCalled = !1, this.needDrain = !1, this.ending = !1, this.ended = !1, this.finished = !1, this.destroyed = !1;
            var le = z.decodeStrings === !1;
            this.decodeStrings = !le, this.defaultEncoding = z.defaultEncoding || "utf8", this.length = 0, this.writing = !1, this.corked = 0, this.sync = !0, this.bufferProcessing = !1, this.onwrite = function(he) {
              (function(k, T) {
                var B = k._writableState, K = B.sync, h = B.writecb;
                if (typeof h != "function")
                  throw new F();
                if (function(m) {
                  m.writing = !1, m.writecb = null, m.length -= m.writelen, m.writelen = 0;
                }(B), T)
                  (function(m, D, ee, E, Q) {
                    --D.pendingcb, ee ? (a.nextTick(Q, E), a.nextTick(re, m, D), m._writableState.errorEmitted = !0, W(m, E)) : (Q(E), m._writableState.errorEmitted = !0, W(m, E), re(m, D));
                  })(k, B, K, T, h);
                else {
                  var c = $(B) || k.destroyed;
                  c || B.corked || B.bufferProcessing || !B.bufferedRequest || te(k, B), K ? a.nextTick(J, k, B, c, h) : J(k, B, c, h);
                }
              })(N, he);
            }, this.writecb = null, this.writelen = 0, this.bufferedRequest = null, this.lastBufferedRequest = null, this.pendingcb = 0, this.prefinished = !1, this.errorEmitted = !1, this.emitClose = z.emitClose !== !1, this.autoDestroy = !!z.autoDestroy, this.bufferedRequestCount = 0, this.corkedRequestsFree = new r(this);
          }
          function U(z) {
            var N = this instanceof (o = o || e("./_stream_duplex"));
            if (!N && !v.call(U, this))
              return new U(z);
            this._writableState = new j(z, this, N), this.writable = !0, z && (typeof z.write == "function" && (this._write = z.write), typeof z.writev == "function" && (this._writev = z.writev), typeof z.destroy == "function" && (this._destroy = z.destroy), typeof z.final == "function" && (this._final = z.final)), u.call(this);
          }
          function C(z, N, ne, le, he, k) {
            if (!ne) {
              var T = function(c, m, D) {
                return c.objectMode || c.decodeStrings === !1 || typeof m != "string" || (m = p.from(m, D)), m;
              }(N, le, he);
              le !== T && (ne = !0, he = "buffer", le = T);
            }
            var B = N.objectMode ? 1 : le.length;
            N.length += B;
            var K = N.length < N.highWaterMark;
            if (K || (N.needDrain = !0), N.writing || N.corked) {
              var h = N.lastBufferedRequest;
              N.lastBufferedRequest = { chunk: le, encoding: he, isBuf: ne, callback: k, next: null }, h ? h.next = N.lastBufferedRequest : N.bufferedRequest = N.lastBufferedRequest, N.bufferedRequestCount += 1;
            } else
              ae(z, N, !1, B, le, he, k);
            return K;
          }
          function ae(z, N, ne, le, he, k, T) {
            N.writelen = le, N.writecb = T, N.writing = !0, N.sync = !0, N.destroyed ? N.onwrite(new q("write")) : ne ? z._writev(he, N.onwrite) : z._write(he, k, N.onwrite), N.sync = !1;
          }
          function J(z, N, ne, le) {
            ne || function(he, k) {
              k.length === 0 && k.needDrain && (k.needDrain = !1, he.emit("drain"));
            }(z, N), N.pendingcb--, le(), re(z, N);
          }
          function te(z, N) {
            N.bufferProcessing = !0;
            var ne = N.bufferedRequest;
            if (z._writev && ne && ne.next) {
              var le = N.bufferedRequestCount, he = new Array(le), k = N.corkedRequestsFree;
              k.entry = ne;
              for (var T = 0, B = !0; ne; )
                he[T] = ne, ne.isBuf || (B = !1), ne = ne.next, T += 1;
              he.allBuffers = B, ae(z, N, !0, N.length, he, "", k.finish), N.pendingcb++, N.lastBufferedRequest = null, k.next ? (N.corkedRequestsFree = k.next, k.next = null) : N.corkedRequestsFree = new r(N), N.bufferedRequestCount = 0;
            } else {
              for (; ne; ) {
                var K = ne.chunk, h = ne.encoding, c = ne.callback;
                if (ae(z, N, !1, N.objectMode ? 1 : K.length, K, h, c), ne = ne.next, N.bufferedRequestCount--, N.writing)
                  break;
              }
              ne === null && (N.lastBufferedRequest = null);
            }
            N.bufferedRequest = ne, N.bufferProcessing = !1;
          }
          function $(z) {
            return z.ending && z.length === 0 && z.bufferedRequest === null && !z.finished && !z.writing;
          }
          function L(z, N) {
            z._final(function(ne) {
              N.pendingcb--, ne && W(z, ne), N.prefinished = !0, z.emit("prefinish"), re(z, N);
            });
          }
          function re(z, N) {
            var ne = $(N);
            if (ne && (function(he, k) {
              k.prefinished || k.finalCalled || (typeof he._final != "function" || k.destroyed ? (k.prefinished = !0, he.emit("prefinish")) : (k.pendingcb++, k.finalCalled = !0, a.nextTick(L, he, k)));
            }(z, N), N.pendingcb === 0 && (N.finished = !0, z.emit("finish"), N.autoDestroy))) {
              var le = z._readableState;
              (!le || le.autoDestroy && le.endEmitted) && z.destroy();
            }
            return ne;
          }
          e("inherits")(U, u), j.prototype.getBuffer = function() {
            for (var z = this.bufferedRequest, N = []; z; )
              N.push(z), z = z.next;
            return N;
          }, function() {
            try {
              Object.defineProperty(j.prototype, "buffer", { get: n.deprecate(function() {
                return this.getBuffer();
              }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003") });
            } catch {
            }
          }(), typeof Symbol == "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] == "function" ? (v = Function.prototype[Symbol.hasInstance], Object.defineProperty(U, Symbol.hasInstance, { value: function(z) {
            return !!v.call(this, z) || this === U && z && z._writableState instanceof j;
          } })) : v = function(z) {
            return z instanceof this;
          }, U.prototype.pipe = function() {
            W(this, new V());
          }, U.prototype.write = function(z, N, ne) {
            var le, he = this._writableState, k = !1, T = !he.objectMode && (le = z, p.isBuffer(le) || le instanceof g);
            return T && !p.isBuffer(z) && (z = function(B) {
              return p.from(B);
            }(z)), typeof N == "function" && (ne = N, N = null), T ? N = "buffer" : N || (N = he.defaultEncoding), typeof ne != "function" && (ne = O), he.ending ? function(B, K) {
              var h = new _();
              W(B, h), a.nextTick(K, h);
            }(this, ne) : (T || function(B, K, h, c) {
              var m;
              return h === null ? m = new I() : typeof h == "string" || K.objectMode || (m = new M("chunk", ["string", "Buffer"], h)), !m || (W(B, m), a.nextTick(c, m), !1);
            }(this, he, z, ne)) && (he.pendingcb++, k = C(this, he, T, z, N, ne)), k;
          }, U.prototype.cork = function() {
            this._writableState.corked++;
          }, U.prototype.uncork = function() {
            var z = this._writableState;
            z.corked && (z.corked--, z.writing || z.corked || z.bufferProcessing || !z.bufferedRequest || te(this, z));
          }, U.prototype.setDefaultEncoding = function(z) {
            if (typeof z == "string" && (z = z.toLowerCase()), !(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((z + "").toLowerCase()) > -1))
              throw new R(z);
            return this._writableState.defaultEncoding = z, this;
          }, Object.defineProperty(U.prototype, "writableBuffer", { enumerable: !1, get: function() {
            return this._writableState && this._writableState.getBuffer();
          } }), Object.defineProperty(U.prototype, "writableHighWaterMark", { enumerable: !1, get: function() {
            return this._writableState.highWaterMark;
          } }), U.prototype._write = function(z, N, ne) {
            ne(new G("_write()"));
          }, U.prototype._writev = null, U.prototype.end = function(z, N, ne) {
            var le = this._writableState;
            return typeof z == "function" ? (ne = z, z = null, N = null) : typeof N == "function" && (ne = N, N = null), z != null && this.write(z, N), le.corked && (le.corked = 1, this.uncork()), le.ending || function(he, k, T) {
              k.ending = !0, re(he, k), T && (k.finished ? a.nextTick(T) : he.once("finish", T)), k.ended = !0, he.writable = !1;
            }(this, le, ne), this;
          }, Object.defineProperty(U.prototype, "writableLength", { enumerable: !1, get: function() {
            return this._writableState.length;
          } }), Object.defineProperty(U.prototype, "destroyed", { enumerable: !1, get: function() {
            return this._writableState !== void 0 && this._writableState.destroyed;
          }, set: function(z) {
            this._writableState && (this._writableState.destroyed = z);
          } }), U.prototype.destroy = x.destroy, U.prototype._undestroy = x.undestroy, U.prototype._destroy = function(z, N) {
            N(z);
          };
        }).call(this);
      }).call(this, e("_process"), s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "../errors": 62, "./_stream_duplex": 63, "./internal/streams/destroy": 70, "./internal/streams/state": 74, "./internal/streams/stream": 75, _process: 60, buffer: 33, inherits: 45, "util-deprecate": 78 }], 68: [function(e, f, i) {
      (function(a) {
        (function() {
          var t;
          function r(q, I, _) {
            return I in q ? Object.defineProperty(q, I, { value: _, enumerable: !0, configurable: !0, writable: !0 }) : q[I] = _, q;
          }
          var o = e("./end-of-stream"), n = Symbol("lastResolve"), u = Symbol("lastReject"), p = Symbol("error"), g = Symbol("ended"), v = Symbol("lastPromise"), x = Symbol("handlePromise"), b = Symbol("stream");
          function w(q, I) {
            return { value: q, done: I };
          }
          function M(q) {
            var I = q[n];
            if (I !== null) {
              var _ = q[b].read();
              _ !== null && (q[v] = null, q[n] = null, q[u] = null, I(w(_, !1)));
            }
          }
          function G(q) {
            a.nextTick(M, q);
          }
          var F = Object.getPrototypeOf(function() {
          }), V = Object.setPrototypeOf((r(t = { get stream() {
            return this[b];
          }, next: function() {
            var q = this, I = this[p];
            if (I !== null)
              return Promise.reject(I);
            if (this[g])
              return Promise.resolve(w(void 0, !0));
            if (this[b].destroyed)
              return new Promise(function(O, j) {
                a.nextTick(function() {
                  q[p] ? j(q[p]) : O(w(void 0, !0));
                });
              });
            var _, R = this[v];
            if (R)
              _ = new Promise(function(O, j) {
                return function(U, C) {
                  O.then(function() {
                    j[g] ? U(w(void 0, !0)) : j[x](U, C);
                  }, C);
                };
              }(R, this));
            else {
              var W = this[b].read();
              if (W !== null)
                return Promise.resolve(w(W, !1));
              _ = new Promise(this[x]);
            }
            return this[v] = _, _;
          } }, Symbol.asyncIterator, function() {
            return this;
          }), r(t, "return", function() {
            var q = this;
            return new Promise(function(I, _) {
              q[b].destroy(null, function(R) {
                R ? _(R) : I(w(void 0, !0));
              });
            });
          }), t), F);
          f.exports = function(q) {
            var I, _ = Object.create(V, (r(I = {}, b, { value: q, writable: !0 }), r(I, n, { value: null, writable: !0 }), r(I, u, { value: null, writable: !0 }), r(I, p, { value: null, writable: !0 }), r(I, g, { value: q._readableState.endEmitted, writable: !0 }), r(I, x, { value: function(R, W) {
              var O = _[b].read();
              O ? (_[v] = null, _[n] = null, _[u] = null, R(w(O, !1))) : (_[n] = R, _[u] = W);
            }, writable: !0 }), I));
            return _[v] = null, o(q, function(R) {
              if (R && R.code !== "ERR_STREAM_PREMATURE_CLOSE") {
                var W = _[u];
                return W !== null && (_[v] = null, _[n] = null, _[u] = null, W(R)), void (_[p] = R);
              }
              var O = _[n];
              O !== null && (_[v] = null, _[n] = null, _[u] = null, O(w(void 0, !0))), _[g] = !0;
            }), q.on("readable", G.bind(null, _)), _;
          };
        }).call(this);
      }).call(this, e("_process"));
    }, { "./end-of-stream": 71, _process: 60 }], 69: [function(e, f, i) {
      function a(p, g) {
        var v = Object.keys(p);
        if (Object.getOwnPropertySymbols) {
          var x = Object.getOwnPropertySymbols(p);
          g && (x = x.filter(function(b) {
            return Object.getOwnPropertyDescriptor(p, b).enumerable;
          })), v.push.apply(v, x);
        }
        return v;
      }
      function t(p, g, v) {
        return g in p ? Object.defineProperty(p, g, { value: v, enumerable: !0, configurable: !0, writable: !0 }) : p[g] = v, p;
      }
      function r(p, g) {
        for (var v = 0; v < g.length; v++) {
          var x = g[v];
          x.enumerable = x.enumerable || !1, x.configurable = !0, "value" in x && (x.writable = !0), Object.defineProperty(p, x.key, x);
        }
      }
      var o = e("buffer").Buffer, n = e("util").inspect, u = n && n.custom || "inspect";
      f.exports = function() {
        function p() {
          (function(b, w) {
            if (!(b instanceof w))
              throw new TypeError("Cannot call a class as a function");
          })(this, p), this.head = null, this.tail = null, this.length = 0;
        }
        return g = p, v = [{ key: "push", value: function(b) {
          var w = { data: b, next: null };
          this.length > 0 ? this.tail.next = w : this.head = w, this.tail = w, ++this.length;
        } }, { key: "unshift", value: function(b) {
          var w = { data: b, next: this.head };
          this.length === 0 && (this.tail = w), this.head = w, ++this.length;
        } }, { key: "shift", value: function() {
          if (this.length !== 0) {
            var b = this.head.data;
            return this.length === 1 ? this.head = this.tail = null : this.head = this.head.next, --this.length, b;
          }
        } }, { key: "clear", value: function() {
          this.head = this.tail = null, this.length = 0;
        } }, { key: "join", value: function(b) {
          if (this.length === 0)
            return "";
          for (var w = this.head, M = "" + w.data; w = w.next; )
            M += b + w.data;
          return M;
        } }, { key: "concat", value: function(b) {
          if (this.length === 0)
            return o.alloc(0);
          for (var w = o.allocUnsafe(b >>> 0), M = this.head, G = 0; M; )
            F = M.data, V = w, q = G, o.prototype.copy.call(F, V, q), G += M.data.length, M = M.next;
          var F, V, q;
          return w;
        } }, { key: "consume", value: function(b, w) {
          var M;
          return b < this.head.data.length ? (M = this.head.data.slice(0, b), this.head.data = this.head.data.slice(b)) : M = b === this.head.data.length ? this.shift() : w ? this._getString(b) : this._getBuffer(b), M;
        } }, { key: "first", value: function() {
          return this.head.data;
        } }, { key: "_getString", value: function(b) {
          var w = this.head, M = 1, G = w.data;
          for (b -= G.length; w = w.next; ) {
            var F = w.data, V = b > F.length ? F.length : b;
            if (V === F.length ? G += F : G += F.slice(0, b), (b -= V) == 0) {
              V === F.length ? (++M, w.next ? this.head = w.next : this.head = this.tail = null) : (this.head = w, w.data = F.slice(V));
              break;
            }
            ++M;
          }
          return this.length -= M, G;
        } }, { key: "_getBuffer", value: function(b) {
          var w = o.allocUnsafe(b), M = this.head, G = 1;
          for (M.data.copy(w), b -= M.data.length; M = M.next; ) {
            var F = M.data, V = b > F.length ? F.length : b;
            if (F.copy(w, w.length - b, 0, V), (b -= V) == 0) {
              V === F.length ? (++G, M.next ? this.head = M.next : this.head = this.tail = null) : (this.head = M, M.data = F.slice(V));
              break;
            }
            ++G;
          }
          return this.length -= G, w;
        } }, { key: u, value: function(b, w) {
          return n(this, function(M) {
            for (var G = 1; G < arguments.length; G++) {
              var F = arguments[G] != null ? arguments[G] : {};
              G % 2 ? a(Object(F), !0).forEach(function(V) {
                t(M, V, F[V]);
              }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(M, Object.getOwnPropertyDescriptors(F)) : a(Object(F)).forEach(function(V) {
                Object.defineProperty(M, V, Object.getOwnPropertyDescriptor(F, V));
              });
            }
            return M;
          }({}, w, { depth: 0, customInspect: !1 }));
        } }], v && r(g.prototype, v), x && r(g, x), p;
        var g, v, x;
      }();
    }, { buffer: 33, util: 30 }], 70: [function(e, f, i) {
      (function(a) {
        (function() {
          function t(n, u) {
            o(n, u), r(n);
          }
          function r(n) {
            n._writableState && !n._writableState.emitClose || n._readableState && !n._readableState.emitClose || n.emit("close");
          }
          function o(n, u) {
            n.emit("error", u);
          }
          f.exports = { destroy: function(n, u) {
            var p = this, g = this._readableState && this._readableState.destroyed, v = this._writableState && this._writableState.destroyed;
            return g || v ? (u ? u(n) : n && (this._writableState ? this._writableState.errorEmitted || (this._writableState.errorEmitted = !0, a.nextTick(o, this, n)) : a.nextTick(o, this, n)), this) : (this._readableState && (this._readableState.destroyed = !0), this._writableState && (this._writableState.destroyed = !0), this._destroy(n || null, function(x) {
              !u && x ? p._writableState ? p._writableState.errorEmitted ? a.nextTick(r, p) : (p._writableState.errorEmitted = !0, a.nextTick(t, p, x)) : a.nextTick(t, p, x) : u ? (a.nextTick(r, p), u(x)) : a.nextTick(r, p);
            }), this);
          }, undestroy: function() {
            this._readableState && (this._readableState.destroyed = !1, this._readableState.reading = !1, this._readableState.ended = !1, this._readableState.endEmitted = !1), this._writableState && (this._writableState.destroyed = !1, this._writableState.ended = !1, this._writableState.ending = !1, this._writableState.finalCalled = !1, this._writableState.prefinished = !1, this._writableState.finished = !1, this._writableState.errorEmitted = !1);
          }, errorOrDestroy: function(n, u) {
            var p = n._readableState, g = n._writableState;
            p && p.autoDestroy || g && g.autoDestroy ? n.destroy(u) : n.emit("error", u);
          } };
        }).call(this);
      }).call(this, e("_process"));
    }, { _process: 60 }], 71: [function(e, f, i) {
      var a = e("../../../errors").codes.ERR_STREAM_PREMATURE_CLOSE;
      function t() {
      }
      f.exports = function r(o, n, u) {
        if (typeof n == "function")
          return r(o, null, n);
        n || (n = {}), u = function(q) {
          var I = !1;
          return function() {
            if (!I) {
              I = !0;
              for (var _ = arguments.length, R = new Array(_), W = 0; W < _; W++)
                R[W] = arguments[W];
              q.apply(this, R);
            }
          };
        }(u || t);
        var p = n.readable || n.readable !== !1 && o.readable, g = n.writable || n.writable !== !1 && o.writable, v = function() {
          o.writable || b();
        }, x = o._writableState && o._writableState.finished, b = function() {
          g = !1, x = !0, p || u.call(o);
        }, w = o._readableState && o._readableState.endEmitted, M = function() {
          p = !1, w = !0, g || u.call(o);
        }, G = function(q) {
          u.call(o, q);
        }, F = function() {
          var q;
          return p && !w ? (o._readableState && o._readableState.ended || (q = new a()), u.call(o, q)) : g && !x ? (o._writableState && o._writableState.ended || (q = new a()), u.call(o, q)) : void 0;
        }, V = function() {
          o.req.on("finish", b);
        };
        return function(q) {
          return q.setHeader && typeof q.abort == "function";
        }(o) ? (o.on("complete", b), o.on("abort", F), o.req ? V() : o.on("request", V)) : g && !o._writableState && (o.on("end", v), o.on("close", v)), o.on("end", M), o.on("finish", b), n.error !== !1 && o.on("error", G), o.on("close", F), function() {
          o.removeListener("complete", b), o.removeListener("abort", F), o.removeListener("request", V), o.req && o.req.removeListener("finish", b), o.removeListener("end", v), o.removeListener("close", v), o.removeListener("finish", b), o.removeListener("end", M), o.removeListener("error", G), o.removeListener("close", F);
        };
      };
    }, { "../../../errors": 62 }], 72: [function(e, f, i) {
      f.exports = function() {
        throw new Error("Readable.from is not available in the browser");
      };
    }, {}], 73: [function(e, f, i) {
      var a, t = e("../../../errors").codes, r = t.ERR_MISSING_ARGS, o = t.ERR_STREAM_DESTROYED;
      function n(g) {
        if (g)
          throw g;
      }
      function u(g) {
        g();
      }
      function p(g, v) {
        return g.pipe(v);
      }
      f.exports = function() {
        for (var g = arguments.length, v = new Array(g), x = 0; x < g; x++)
          v[x] = arguments[x];
        var b, w = function(G) {
          return G.length ? typeof G[G.length - 1] != "function" ? n : G.pop() : n;
        }(v);
        if (Array.isArray(v[0]) && (v = v[0]), v.length < 2)
          throw new r("streams");
        var M = v.map(function(G, F) {
          var V = F < v.length - 1;
          return function(q, I, _, R) {
            R = function(j) {
              var U = !1;
              return function() {
                U || (U = !0, j.apply(void 0, arguments));
              };
            }(R);
            var W = !1;
            q.on("close", function() {
              W = !0;
            }), a === void 0 && (a = e("./end-of-stream")), a(q, { readable: I, writable: _ }, function(j) {
              if (j)
                return R(j);
              W = !0, R();
            });
            var O = !1;
            return function(j) {
              if (!W && !O)
                return O = !0, function(U) {
                  return U.setHeader && typeof U.abort == "function";
                }(q) ? q.abort() : typeof q.destroy == "function" ? q.destroy() : void R(j || new o("pipe"));
            };
          }(G, V, F > 0, function(q) {
            b || (b = q), q && M.forEach(u), V || (M.forEach(u), w(b));
          });
        });
        return v.reduce(p);
      };
    }, { "../../../errors": 62, "./end-of-stream": 71 }], 74: [function(e, f, i) {
      var a = e("../../../errors").codes.ERR_INVALID_OPT_VALUE;
      f.exports = { getHighWaterMark: function(t, r, o, n) {
        var u = function(p, g, v) {
          return p.highWaterMark != null ? p.highWaterMark : g ? p[v] : null;
        }(r, n, o);
        if (u != null) {
          if (!isFinite(u) || Math.floor(u) !== u || u < 0)
            throw new a(n ? o : "highWaterMark", u);
          return Math.floor(u);
        }
        return t.objectMode ? 16 : 16384;
      } };
    }, { "../../../errors": 62 }], 75: [function(e, f, i) {
      f.exports = e("events").EventEmitter;
    }, { events: 38 }], 76: [function(e, f, i) {
      var a = e("safe-buffer").Buffer, t = a.isEncoding || function(w) {
        switch ((w = "" + w) && w.toLowerCase()) {
          case "hex":
          case "utf8":
          case "utf-8":
          case "ascii":
          case "binary":
          case "base64":
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
          case "raw":
            return !0;
          default:
            return !1;
        }
      };
      function r(w) {
        var M;
        switch (this.encoding = function(G) {
          var F = function(V) {
            if (!V)
              return "utf8";
            for (var q; ; )
              switch (V) {
                case "utf8":
                case "utf-8":
                  return "utf8";
                case "ucs2":
                case "ucs-2":
                case "utf16le":
                case "utf-16le":
                  return "utf16le";
                case "latin1":
                case "binary":
                  return "latin1";
                case "base64":
                case "ascii":
                case "hex":
                  return V;
                default:
                  if (q)
                    return;
                  V = ("" + V).toLowerCase(), q = !0;
              }
          }(G);
          if (typeof F != "string" && (a.isEncoding === t || !t(G)))
            throw new Error("Unknown encoding: " + G);
          return F || G;
        }(w), this.encoding) {
          case "utf16le":
            this.text = u, this.end = p, M = 4;
            break;
          case "utf8":
            this.fillLast = n, M = 4;
            break;
          case "base64":
            this.text = g, this.end = v, M = 3;
            break;
          default:
            return this.write = x, void (this.end = b);
        }
        this.lastNeed = 0, this.lastTotal = 0, this.lastChar = a.allocUnsafe(M);
      }
      function o(w) {
        return w <= 127 ? 0 : w >> 5 == 6 ? 2 : w >> 4 == 14 ? 3 : w >> 3 == 30 ? 4 : w >> 6 == 2 ? -1 : -2;
      }
      function n(w) {
        var M = this.lastTotal - this.lastNeed, G = function(F, V, q) {
          if ((192 & V[0]) != 128)
            return F.lastNeed = 0, "";
          if (F.lastNeed > 1 && V.length > 1) {
            if ((192 & V[1]) != 128)
              return F.lastNeed = 1, "";
            if (F.lastNeed > 2 && V.length > 2 && (192 & V[2]) != 128)
              return F.lastNeed = 2, "";
          }
        }(this, w);
        return G !== void 0 ? G : this.lastNeed <= w.length ? (w.copy(this.lastChar, M, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal)) : (w.copy(this.lastChar, M, 0, w.length), void (this.lastNeed -= w.length));
      }
      function u(w, M) {
        if ((w.length - M) % 2 == 0) {
          var G = w.toString("utf16le", M);
          if (G) {
            var F = G.charCodeAt(G.length - 1);
            if (F >= 55296 && F <= 56319)
              return this.lastNeed = 2, this.lastTotal = 4, this.lastChar[0] = w[w.length - 2], this.lastChar[1] = w[w.length - 1], G.slice(0, -1);
          }
          return G;
        }
        return this.lastNeed = 1, this.lastTotal = 2, this.lastChar[0] = w[w.length - 1], w.toString("utf16le", M, w.length - 1);
      }
      function p(w) {
        var M = w && w.length ? this.write(w) : "";
        if (this.lastNeed) {
          var G = this.lastTotal - this.lastNeed;
          return M + this.lastChar.toString("utf16le", 0, G);
        }
        return M;
      }
      function g(w, M) {
        var G = (w.length - M) % 3;
        return G === 0 ? w.toString("base64", M) : (this.lastNeed = 3 - G, this.lastTotal = 3, G === 1 ? this.lastChar[0] = w[w.length - 1] : (this.lastChar[0] = w[w.length - 2], this.lastChar[1] = w[w.length - 1]), w.toString("base64", M, w.length - G));
      }
      function v(w) {
        var M = w && w.length ? this.write(w) : "";
        return this.lastNeed ? M + this.lastChar.toString("base64", 0, 3 - this.lastNeed) : M;
      }
      function x(w) {
        return w.toString(this.encoding);
      }
      function b(w) {
        return w && w.length ? this.write(w) : "";
      }
      i.StringDecoder = r, r.prototype.write = function(w) {
        if (w.length === 0)
          return "";
        var M, G;
        if (this.lastNeed) {
          if ((M = this.fillLast(w)) === void 0)
            return "";
          G = this.lastNeed, this.lastNeed = 0;
        } else
          G = 0;
        return G < w.length ? M ? M + this.text(w, G) : this.text(w, G) : M || "";
      }, r.prototype.end = function(w) {
        var M = w && w.length ? this.write(w) : "";
        return this.lastNeed ? M + "" : M;
      }, r.prototype.text = function(w, M) {
        var G = function(V, q, I) {
          var _ = q.length - 1;
          if (_ < I)
            return 0;
          var R = o(q[_]);
          return R >= 0 ? (R > 0 && (V.lastNeed = R - 1), R) : --_ < I || R === -2 ? 0 : (R = o(q[_])) >= 0 ? (R > 0 && (V.lastNeed = R - 2), R) : --_ < I || R === -2 ? 0 : (R = o(q[_])) >= 0 ? (R > 0 && (R === 2 ? R = 0 : V.lastNeed = R - 3), R) : 0;
        }(this, w, M);
        if (!this.lastNeed)
          return w.toString("utf8", M);
        this.lastTotal = G;
        var F = w.length - (G - this.lastNeed);
        return w.copy(this.lastChar, 0, F), w.toString("utf8", M, F);
      }, r.prototype.fillLast = function(w) {
        if (this.lastNeed <= w.length)
          return w.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed), this.lastChar.toString(this.encoding, 0, this.lastTotal);
        w.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, w.length), this.lastNeed -= w.length;
      };
    }, { "safe-buffer": 77 }], 77: [function(e, f, i) {
      var a = e("buffer"), t = a.Buffer;
      function r(n, u) {
        for (var p in n)
          u[p] = n[p];
      }
      function o(n, u, p) {
        return t(n, u, p);
      }
      t.from && t.alloc && t.allocUnsafe && t.allocUnsafeSlow ? f.exports = a : (r(a, i), i.Buffer = o), o.prototype = Object.create(t.prototype), r(t, o), o.from = function(n, u, p) {
        if (typeof n == "number")
          throw new TypeError("Argument must not be a number");
        return t(n, u, p);
      }, o.alloc = function(n, u, p) {
        if (typeof n != "number")
          throw new TypeError("Argument must be a number");
        var g = t(n);
        return u !== void 0 ? typeof p == "string" ? g.fill(u, p) : g.fill(u) : g.fill(0), g;
      }, o.allocUnsafe = function(n) {
        if (typeof n != "number")
          throw new TypeError("Argument must be a number");
        return t(n);
      }, o.allocUnsafeSlow = function(n) {
        if (typeof n != "number")
          throw new TypeError("Argument must be a number");
        return a.SlowBuffer(n);
      };
    }, { buffer: 33 }], 78: [function(e, f, i) {
      (function(a) {
        (function() {
          function t(r) {
            try {
              if (!a.localStorage)
                return !1;
            } catch {
              return !1;
            }
            var o = a.localStorage[r];
            return o != null && String(o).toLowerCase() === "true";
          }
          f.exports = function(r, o) {
            if (t("noDeprecation"))
              return r;
            var n = !1;
            return function() {
              if (!n) {
                if (t("throwDeprecation"))
                  throw new Error(o);
                t("traceDeprecation") ? console.trace(o) : console.warn(o), n = !0;
              }
              return r.apply(this, arguments);
            };
          };
        }).call(this);
      }).call(this, s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, {}], 79: [function(e, f, i) {
      arguments[4][25][0].apply(i, arguments);
    }, { dup: 25 }], 80: [function(e, f, i) {
      var a = e("is-arguments"), t = e("is-generator-function"), r = e("which-typed-array"), o = e("is-typed-array");
      function n(L) {
        return L.call.bind(L);
      }
      var u = typeof BigInt < "u", p = typeof Symbol < "u", g = n(Object.prototype.toString), v = n(Number.prototype.valueOf), x = n(String.prototype.valueOf), b = n(Boolean.prototype.valueOf);
      if (u)
        var w = n(BigInt.prototype.valueOf);
      if (p)
        var M = n(Symbol.prototype.valueOf);
      function G(L, re) {
        if (typeof L != "object")
          return !1;
        try {
          return re(L), !0;
        } catch {
          return !1;
        }
      }
      function F(L) {
        return g(L) === "[object Map]";
      }
      function V(L) {
        return g(L) === "[object Set]";
      }
      function q(L) {
        return g(L) === "[object WeakMap]";
      }
      function I(L) {
        return g(L) === "[object WeakSet]";
      }
      function _(L) {
        return g(L) === "[object ArrayBuffer]";
      }
      function R(L) {
        return typeof ArrayBuffer < "u" && (_.working ? _(L) : L instanceof ArrayBuffer);
      }
      function W(L) {
        return g(L) === "[object DataView]";
      }
      function O(L) {
        return typeof DataView < "u" && (W.working ? W(L) : L instanceof DataView);
      }
      function j(L) {
        return g(L) === "[object SharedArrayBuffer]";
      }
      function U(L) {
        return typeof SharedArrayBuffer < "u" && (j.working ? j(L) : L instanceof SharedArrayBuffer);
      }
      function C(L) {
        return G(L, v);
      }
      function ae(L) {
        return G(L, x);
      }
      function J(L) {
        return G(L, b);
      }
      function te(L) {
        return u && G(L, w);
      }
      function $(L) {
        return p && G(L, M);
      }
      i.isArgumentsObject = a, i.isGeneratorFunction = t, i.isTypedArray = o, i.isPromise = function(L) {
        return typeof Promise < "u" && L instanceof Promise || L !== null && typeof L == "object" && typeof L.then == "function" && typeof L.catch == "function";
      }, i.isArrayBufferView = function(L) {
        return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? ArrayBuffer.isView(L) : o(L) || O(L);
      }, i.isUint8Array = function(L) {
        return r(L) === "Uint8Array";
      }, i.isUint8ClampedArray = function(L) {
        return r(L) === "Uint8ClampedArray";
      }, i.isUint16Array = function(L) {
        return r(L) === "Uint16Array";
      }, i.isUint32Array = function(L) {
        return r(L) === "Uint32Array";
      }, i.isInt8Array = function(L) {
        return r(L) === "Int8Array";
      }, i.isInt16Array = function(L) {
        return r(L) === "Int16Array";
      }, i.isInt32Array = function(L) {
        return r(L) === "Int32Array";
      }, i.isFloat32Array = function(L) {
        return r(L) === "Float32Array";
      }, i.isFloat64Array = function(L) {
        return r(L) === "Float64Array";
      }, i.isBigInt64Array = function(L) {
        return r(L) === "BigInt64Array";
      }, i.isBigUint64Array = function(L) {
        return r(L) === "BigUint64Array";
      }, F.working = typeof Map < "u" && F(/* @__PURE__ */ new Map()), i.isMap = function(L) {
        return typeof Map < "u" && (F.working ? F(L) : L instanceof Map);
      }, V.working = typeof Set < "u" && V(/* @__PURE__ */ new Set()), i.isSet = function(L) {
        return typeof Set < "u" && (V.working ? V(L) : L instanceof Set);
      }, q.working = typeof WeakMap < "u" && q(/* @__PURE__ */ new WeakMap()), i.isWeakMap = function(L) {
        return typeof WeakMap < "u" && (q.working ? q(L) : L instanceof WeakMap);
      }, I.working = typeof WeakSet < "u" && I(/* @__PURE__ */ new WeakSet()), i.isWeakSet = function(L) {
        return I(L);
      }, _.working = typeof ArrayBuffer < "u" && _(new ArrayBuffer()), i.isArrayBuffer = R, W.working = typeof ArrayBuffer < "u" && typeof DataView < "u" && W(new DataView(new ArrayBuffer(1), 0, 1)), i.isDataView = O, j.working = typeof SharedArrayBuffer < "u" && j(new SharedArrayBuffer()), i.isSharedArrayBuffer = U, i.isAsyncFunction = function(L) {
        return g(L) === "[object AsyncFunction]";
      }, i.isMapIterator = function(L) {
        return g(L) === "[object Map Iterator]";
      }, i.isSetIterator = function(L) {
        return g(L) === "[object Set Iterator]";
      }, i.isGeneratorObject = function(L) {
        return g(L) === "[object Generator]";
      }, i.isWebAssemblyCompiledModule = function(L) {
        return g(L) === "[object WebAssembly.Module]";
      }, i.isNumberObject = C, i.isStringObject = ae, i.isBooleanObject = J, i.isBigIntObject = te, i.isSymbolObject = $, i.isBoxedPrimitive = function(L) {
        return C(L) || ae(L) || J(L) || te(L) || $(L);
      }, i.isAnyArrayBuffer = function(L) {
        return typeof Uint8Array < "u" && (R(L) || U(L));
      }, ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(L) {
        Object.defineProperty(i, L, { enumerable: !1, value: function() {
          throw new Error(L + " is not supported in userland");
        } });
      });
    }, { "is-arguments": 46, "is-generator-function": 47, "is-typed-array": 48, "which-typed-array": 82 }], 81: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = Object.getOwnPropertyDescriptors || function(L) {
            for (var re = Object.keys(L), z = {}, N = 0; N < re.length; N++)
              z[re[N]] = Object.getOwnPropertyDescriptor(L, re[N]);
            return z;
          }, r = /%[sdj%]/g;
          i.format = function(L) {
            if (!q(L)) {
              for (var re = [], z = 0; z < arguments.length; z++)
                re.push(p(arguments[z]));
              return re.join(" ");
            }
            z = 1;
            for (var N = arguments, ne = N.length, le = String(L).replace(r, function(k) {
              if (k === "%%")
                return "%";
              if (z >= ne)
                return k;
              switch (k) {
                case "%s":
                  return String(N[z++]);
                case "%d":
                  return Number(N[z++]);
                case "%j":
                  try {
                    return JSON.stringify(N[z++]);
                  } catch {
                    return "[Circular]";
                  }
                default:
                  return k;
              }
            }), he = N[z]; z < ne; he = N[++z])
              F(he) || !R(he) ? le += " " + he : le += " " + p(he);
            return le;
          }, i.deprecate = function(L, re) {
            if (a !== void 0 && a.noDeprecation === !0)
              return L;
            if (a === void 0)
              return function() {
                return i.deprecate(L, re).apply(this, arguments);
              };
            var z = !1;
            return function() {
              if (!z) {
                if (a.throwDeprecation)
                  throw new Error(re);
                a.traceDeprecation ? console.trace(re) : console.error(re), z = !0;
              }
              return L.apply(this, arguments);
            };
          };
          var o = {}, n = /^$/;
          if (a.env.NODE_DEBUG) {
            var u = a.env.NODE_DEBUG;
            u = u.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase(), n = new RegExp("^" + u + "$", "i");
          }
          function p(L, re) {
            var z = { seen: [], stylize: v };
            return arguments.length >= 3 && (z.depth = arguments[2]), arguments.length >= 4 && (z.colors = arguments[3]), G(re) ? z.showHidden = re : re && i._extend(z, re), I(z.showHidden) && (z.showHidden = !1), I(z.depth) && (z.depth = 2), I(z.colors) && (z.colors = !1), I(z.customInspect) && (z.customInspect = !0), z.colors && (z.stylize = g), x(z, L, z.depth);
          }
          function g(L, re) {
            var z = p.styles[re];
            return z ? "\x1B[" + p.colors[z][0] + "m" + L + "\x1B[" + p.colors[z][1] + "m" : L;
          }
          function v(L, re) {
            return L;
          }
          function x(L, re, z) {
            if (L.customInspect && re && j(re.inspect) && re.inspect !== i.inspect && (!re.constructor || re.constructor.prototype !== re)) {
              var N = re.inspect(z, L);
              return q(N) || (N = x(L, N, z)), N;
            }
            var ne = function(c, m) {
              if (I(m))
                return c.stylize("undefined", "undefined");
              if (q(m)) {
                var D = "'" + JSON.stringify(m).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
                return c.stylize(D, "string");
              }
              return V(m) ? c.stylize("" + m, "number") : G(m) ? c.stylize("" + m, "boolean") : F(m) ? c.stylize("null", "null") : void 0;
            }(L, re);
            if (ne)
              return ne;
            var le = Object.keys(re), he = function(c) {
              var m = {};
              return c.forEach(function(D, ee) {
                m[D] = !0;
              }), m;
            }(le);
            if (L.showHidden && (le = Object.getOwnPropertyNames(re)), O(re) && (le.indexOf("message") >= 0 || le.indexOf("description") >= 0))
              return b(re);
            if (le.length === 0) {
              if (j(re)) {
                var k = re.name ? ": " + re.name : "";
                return L.stylize("[Function" + k + "]", "special");
              }
              if (_(re))
                return L.stylize(RegExp.prototype.toString.call(re), "regexp");
              if (W(re))
                return L.stylize(Date.prototype.toString.call(re), "date");
              if (O(re))
                return b(re);
            }
            var T, B = "", K = !1, h = ["{", "}"];
            return M(re) && (K = !0, h = ["[", "]"]), j(re) && (B = " [Function" + (re.name ? ": " + re.name : "") + "]"), _(re) && (B = " " + RegExp.prototype.toString.call(re)), W(re) && (B = " " + Date.prototype.toUTCString.call(re)), O(re) && (B = " " + b(re)), le.length !== 0 || K && re.length != 0 ? z < 0 ? _(re) ? L.stylize(RegExp.prototype.toString.call(re), "regexp") : L.stylize("[Object]", "special") : (L.seen.push(re), T = K ? function(c, m, D, ee, E) {
              for (var Q = [], se = 0, Y = m.length; se < Y; ++se)
                J(m, String(se)) ? Q.push(w(c, m, D, ee, String(se), !0)) : Q.push("");
              return E.forEach(function(be) {
                be.match(/^\d+$/) || Q.push(w(c, m, D, ee, be, !0));
              }), Q;
            }(L, re, z, he, le) : le.map(function(c) {
              return w(L, re, z, he, c, K);
            }), L.seen.pop(), function(c, m, D) {
              return c.reduce(function(ee, E) {
                return E.indexOf(`
`), ee + E.replace(/\u001b\[\d\d?m/g, "").length + 1;
              }, 0) > 60 ? D[0] + (m === "" ? "" : m + `
 `) + " " + c.join(`,
  `) + " " + D[1] : D[0] + m + " " + c.join(", ") + " " + D[1];
            }(T, B, h)) : h[0] + B + h[1];
          }
          function b(L) {
            return "[" + Error.prototype.toString.call(L) + "]";
          }
          function w(L, re, z, N, ne, le) {
            var he, k, T;
            if ((T = Object.getOwnPropertyDescriptor(re, ne) || { value: re[ne] }).get ? k = T.set ? L.stylize("[Getter/Setter]", "special") : L.stylize("[Getter]", "special") : T.set && (k = L.stylize("[Setter]", "special")), J(N, ne) || (he = "[" + ne + "]"), k || (L.seen.indexOf(T.value) < 0 ? (k = F(z) ? x(L, T.value, null) : x(L, T.value, z - 1)).indexOf(`
`) > -1 && (k = le ? k.split(`
`).map(function(B) {
              return "  " + B;
            }).join(`
`).substr(2) : `
` + k.split(`
`).map(function(B) {
              return "   " + B;
            }).join(`
`)) : k = L.stylize("[Circular]", "special")), I(he)) {
              if (le && ne.match(/^\d+$/))
                return k;
              (he = JSON.stringify("" + ne)).match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/) ? (he = he.substr(1, he.length - 2), he = L.stylize(he, "name")) : (he = he.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'"), he = L.stylize(he, "string"));
            }
            return he + ": " + k;
          }
          function M(L) {
            return Array.isArray(L);
          }
          function G(L) {
            return typeof L == "boolean";
          }
          function F(L) {
            return L === null;
          }
          function V(L) {
            return typeof L == "number";
          }
          function q(L) {
            return typeof L == "string";
          }
          function I(L) {
            return L === void 0;
          }
          function _(L) {
            return R(L) && U(L) === "[object RegExp]";
          }
          function R(L) {
            return typeof L == "object" && L !== null;
          }
          function W(L) {
            return R(L) && U(L) === "[object Date]";
          }
          function O(L) {
            return R(L) && (U(L) === "[object Error]" || L instanceof Error);
          }
          function j(L) {
            return typeof L == "function";
          }
          function U(L) {
            return Object.prototype.toString.call(L);
          }
          function C(L) {
            return L < 10 ? "0" + L.toString(10) : L.toString(10);
          }
          i.debuglog = function(L) {
            if (L = L.toUpperCase(), !o[L])
              if (n.test(L)) {
                var re = a.pid;
                o[L] = function() {
                  var z = i.format.apply(i, arguments);
                  console.error("%s %d: %s", L, re, z);
                };
              } else
                o[L] = function() {
                };
            return o[L];
          }, i.inspect = p, p.colors = { bold: [1, 22], italic: [3, 23], underline: [4, 24], inverse: [7, 27], white: [37, 39], grey: [90, 39], black: [30, 39], blue: [34, 39], cyan: [36, 39], green: [32, 39], magenta: [35, 39], red: [31, 39], yellow: [33, 39] }, p.styles = { special: "cyan", number: "yellow", boolean: "yellow", undefined: "grey", null: "bold", string: "green", date: "magenta", regexp: "red" }, i.types = e("./support/types"), i.isArray = M, i.isBoolean = G, i.isNull = F, i.isNullOrUndefined = function(L) {
            return L == null;
          }, i.isNumber = V, i.isString = q, i.isSymbol = function(L) {
            return typeof L == "symbol";
          }, i.isUndefined = I, i.isRegExp = _, i.types.isRegExp = _, i.isObject = R, i.isDate = W, i.types.isDate = W, i.isError = O, i.types.isNativeError = O, i.isFunction = j, i.isPrimitive = function(L) {
            return L === null || typeof L == "boolean" || typeof L == "number" || typeof L == "string" || typeof L == "symbol" || L === void 0;
          }, i.isBuffer = e("./support/isBuffer");
          var ae = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
          function J(L, re) {
            return Object.prototype.hasOwnProperty.call(L, re);
          }
          i.log = function() {
            var L, re;
            console.log("%s - %s", (L = /* @__PURE__ */ new Date(), re = [C(L.getHours()), C(L.getMinutes()), C(L.getSeconds())].join(":"), [L.getDate(), ae[L.getMonth()], re].join(" ")), i.format.apply(i, arguments));
          }, i.inherits = e("inherits"), i._extend = function(L, re) {
            if (!re || !R(re))
              return L;
            for (var z = Object.keys(re), N = z.length; N--; )
              L[z[N]] = re[z[N]];
            return L;
          };
          var te = typeof Symbol < "u" ? Symbol("util.promisify.custom") : void 0;
          function $(L, re) {
            if (!L) {
              var z = new Error("Promise was rejected with a falsy value");
              z.reason = L, L = z;
            }
            return re(L);
          }
          i.promisify = function(L) {
            if (typeof L != "function")
              throw new TypeError('The "original" argument must be of type Function');
            if (te && L[te]) {
              var re;
              if (typeof (re = L[te]) != "function")
                throw new TypeError('The "util.promisify.custom" argument must be of type Function');
              return Object.defineProperty(re, te, { value: re, enumerable: !1, writable: !1, configurable: !0 }), re;
            }
            function re() {
              for (var z, N, ne = new Promise(function(k, T) {
                z = k, N = T;
              }), le = [], he = 0; he < arguments.length; he++)
                le.push(arguments[he]);
              le.push(function(k, T) {
                k ? N(k) : z(T);
              });
              try {
                L.apply(this, le);
              } catch (k) {
                N(k);
              }
              return ne;
            }
            return Object.setPrototypeOf(re, Object.getPrototypeOf(L)), te && Object.defineProperty(re, te, { value: re, enumerable: !1, writable: !1, configurable: !0 }), Object.defineProperties(re, t(L));
          }, i.promisify.custom = te, i.callbackify = function(L) {
            if (typeof L != "function")
              throw new TypeError('The "original" argument must be of type Function');
            function re() {
              for (var z = [], N = 0; N < arguments.length; N++)
                z.push(arguments[N]);
              var ne = z.pop();
              if (typeof ne != "function")
                throw new TypeError("The last argument must be of type Function");
              var le = this, he = function() {
                return ne.apply(le, arguments);
              };
              L.apply(this, z).then(function(k) {
                a.nextTick(he.bind(null, null, k));
              }, function(k) {
                a.nextTick($.bind(null, k, he));
              });
            }
            return Object.setPrototypeOf(re, Object.getPrototypeOf(L)), Object.defineProperties(re, t(L)), re;
          };
        }).call(this);
      }).call(this, e("_process"));
    }, { "./support/isBuffer": 79, "./support/types": 80, _process: 60, inherits: 45 }], 82: [function(e, f, i) {
      (function(a) {
        (function() {
          var t = e("foreach"), r = e("available-typed-arrays"), o = e("es-abstract/helpers/callBound"), n = o("Object.prototype.toString"), u = e("has-symbols")() && typeof Symbol.toStringTag == "symbol", p = r(), g = o("String.prototype.slice"), v = {}, x = e("es-abstract/helpers/getOwnPropertyDescriptor"), b = Object.getPrototypeOf;
          u && x && b && t(p, function(M) {
            if (typeof a[M] == "function") {
              var G = new a[M]();
              if (!(Symbol.toStringTag in G))
                throw new EvalError("this engine has support for Symbol.toStringTag, but " + M + " does not have the property! Please report this.");
              var F = b(G), V = x(F, Symbol.toStringTag);
              if (!V) {
                var q = b(F);
                V = x(q, Symbol.toStringTag);
              }
              v[M] = V.get;
            }
          });
          var w = e("is-typed-array");
          f.exports = function(M) {
            return !!w(M) && (u ? function(G) {
              var F = !1;
              return t(v, function(V, q) {
                if (!F)
                  try {
                    var I = V.call(G);
                    I === q && (F = I);
                  } catch {
                  }
              }), F;
            }(M) : g(n(M), 8, -1));
          };
        }).call(this);
      }).call(this, s.g !== void 0 ? s.g : typeof self < "u" ? self : typeof window < "u" ? window : {});
    }, { "available-typed-arrays": 27, "es-abstract/helpers/callBound": 36, "es-abstract/helpers/getOwnPropertyDescriptor": 37, foreach: 39, "has-symbols": 42, "is-typed-array": 48 }] }, {}, [20])(20);
  }, 4406: (d) => {
    var l = d.exports = {};
    l.nextTick = function() {
      var s = typeof window < "u" && window.setImmediate, e = typeof window < "u" && window.postMessage && window.addEventListener;
      if (s)
        return function(i) {
          return window.setImmediate(i);
        };
      if (e) {
        var f = [];
        return window.addEventListener("message", function(i) {
          var a = i.source;
          a !== window && a !== null || i.data !== "process-tick" || (i.stopPropagation(), f.length > 0 && f.shift()());
        }, !0), function(i) {
          f.push(i), window.postMessage("process-tick", "*");
        };
      }
      return function(i) {
        setTimeout(i, 0);
      };
    }(), l.title = "browser", l.browser = !0, l.env = {}, l.argv = [], l.binding = function(s) {
      throw new Error("process.binding is not supported");
    }, l.cwd = function() {
      return "/";
    }, l.chdir = function(s) {
      throw new Error("process.chdir is not supported");
    };
  }, 6197: (d, l, s) => {
    var e = s(8834).lW;
    Object.defineProperty(l, "__esModule", { value: !0 }), l.AbstractTokenizer = void 0;
    const f = s(4644);
    l.AbstractTokenizer = class {
      constructor(i) {
        this.position = 0, this.numBuffer = new Uint8Array(8), this.fileInfo = i || {};
      }
      async readToken(i, a = this.position) {
        const t = e.alloc(i.len);
        if (await this.readBuffer(t, { position: a }) < i.len)
          throw new f.EndOfStreamError();
        return i.get(t, 0);
      }
      async peekToken(i, a = this.position) {
        const t = e.alloc(i.len);
        if (await this.peekBuffer(t, { position: a }) < i.len)
          throw new f.EndOfStreamError();
        return i.get(t, 0);
      }
      async readNumber(i) {
        if (await this.readBuffer(this.numBuffer, { length: i.len }) < i.len)
          throw new f.EndOfStreamError();
        return i.get(this.numBuffer, 0);
      }
      async peekNumber(i) {
        if (await this.peekBuffer(this.numBuffer, { length: i.len }) < i.len)
          throw new f.EndOfStreamError();
        return i.get(this.numBuffer, 0);
      }
      async ignore(i) {
        if (this.fileInfo.size !== void 0) {
          const a = this.fileInfo.size - this.position;
          if (i > a)
            return this.position += a, a;
        }
        return this.position += i, i;
      }
      async close() {
      }
      normalizeOptions(i, a) {
        if (a && a.position !== void 0 && a.position < this.position)
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        return a ? { mayBeLess: a.mayBeLess === !0, offset: a.offset ? a.offset : 0, length: a.length ? a.length : i.length - (a.offset ? a.offset : 0), position: a.position ? a.position : this.position } : { mayBeLess: !1, offset: 0, length: i.length, position: this.position };
      }
    };
  }, 932: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.BufferTokenizer = void 0;
    const e = s(4644), f = s(6197);
    class i extends f.AbstractTokenizer {
      constructor(t, r) {
        super(r), this.uint8Array = t, this.fileInfo.size = this.fileInfo.size ? this.fileInfo.size : t.length;
      }
      async readBuffer(t, r) {
        if (r && r.position) {
          if (r.position < this.position)
            throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
          this.position = r.position;
        }
        const o = await this.peekBuffer(t, r);
        return this.position += o, o;
      }
      async peekBuffer(t, r) {
        const o = this.normalizeOptions(t, r), n = Math.min(this.uint8Array.length - o.position, o.length);
        if (!o.mayBeLess && n < o.length)
          throw new e.EndOfStreamError();
        return t.set(this.uint8Array.subarray(o.position, o.position + n), o.offset), n;
      }
      async close() {
      }
    }
    l.BufferTokenizer = i;
  }, 9425: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.fromFile = l.FileTokenizer = void 0;
    const e = s(6197), f = s(4644), i = s(5187);
    class a extends e.AbstractTokenizer {
      constructor(r, o) {
        super(o), this.fd = r;
      }
      async readBuffer(r, o) {
        const n = this.normalizeOptions(r, o);
        this.position = n.position;
        const u = await i.read(this.fd, r, n.offset, n.length, n.position);
        if (this.position += u.bytesRead, u.bytesRead < n.length && (!o || !o.mayBeLess))
          throw new f.EndOfStreamError();
        return u.bytesRead;
      }
      async peekBuffer(r, o) {
        const n = this.normalizeOptions(r, o), u = await i.read(this.fd, r, n.offset, n.length, n.position);
        if (!n.mayBeLess && u.bytesRead < n.length)
          throw new f.EndOfStreamError();
        return u.bytesRead;
      }
      async close() {
        return i.close(this.fd);
      }
    }
    l.FileTokenizer = a, l.fromFile = async function(t) {
      const r = await i.stat(t);
      if (!r.isFile)
        throw new Error(`File not a file: ${t}`);
      const o = await i.open(t, "r");
      return new a(o, { path: t, size: r.size });
    };
  }, 5187: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.readFile = l.writeFileSync = l.writeFile = l.read = l.open = l.close = l.stat = l.createReadStream = l.pathExists = void 0;
    const e = s(6777);
    l.pathExists = e.existsSync, l.createReadStream = e.createReadStream, l.stat = async function(f) {
      return new Promise((i, a) => {
        e.stat(f, (t, r) => {
          t ? a(t) : i(r);
        });
      });
    }, l.close = async function(f) {
      return new Promise((i, a) => {
        e.close(f, (t) => {
          t ? a(t) : i();
        });
      });
    }, l.open = async function(f, i) {
      return new Promise((a, t) => {
        e.open(f, i, (r, o) => {
          r ? t(r) : a(o);
        });
      });
    }, l.read = async function(f, i, a, t, r) {
      return new Promise((o, n) => {
        e.read(f, i, a, t, r, (u, p, g) => {
          u ? n(u) : o({ bytesRead: p, buffer: g });
        });
      });
    }, l.writeFile = async function(f, i) {
      return new Promise((a, t) => {
        e.writeFile(f, i, (r) => {
          r ? t(r) : a();
        });
      });
    }, l.writeFileSync = function(f, i) {
      e.writeFileSync(f, i);
    }, l.readFile = async function(f) {
      return new Promise((i, a) => {
        e.readFile(f, (t, r) => {
          t ? a(t) : i(r);
        });
      });
    };
  }, 8286: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.ReadStreamTokenizer = void 0;
    const e = s(6197), f = s(4644);
    class i extends e.AbstractTokenizer {
      constructor(t, r) {
        super(r), this.streamReader = new f.StreamReader(t);
      }
      async getFileInfo() {
        return this.fileInfo;
      }
      async readBuffer(t, r) {
        const o = this.normalizeOptions(t, r), n = o.position - this.position;
        if (n > 0)
          return await this.ignore(n), this.readBuffer(t, r);
        if (n < 0)
          throw new Error("`options.position` must be equal or greater than `tokenizer.position`");
        if (o.length === 0)
          return 0;
        const u = await this.streamReader.read(t, o.offset, o.length);
        if (this.position += u, (!r || !r.mayBeLess) && u < o.length)
          throw new f.EndOfStreamError();
        return u;
      }
      async peekBuffer(t, r) {
        const o = this.normalizeOptions(t, r);
        let n = 0;
        if (o.position) {
          const u = o.position - this.position;
          if (u > 0) {
            const p = new Uint8Array(o.length + u);
            return n = await this.peekBuffer(p, { mayBeLess: o.mayBeLess }), t.set(p.subarray(u), o.offset), n - u;
          }
          if (u < 0)
            throw new Error("Cannot peek from a negative offset in a stream");
        }
        if (o.length > 0) {
          try {
            n = await this.streamReader.peek(t, o.offset, o.length);
          } catch (u) {
            if (r && r.mayBeLess && u instanceof f.EndOfStreamError)
              return 0;
            throw u;
          }
          if (!o.mayBeLess && n < o.length)
            throw new f.EndOfStreamError();
        }
        return n;
      }
      async ignore(t) {
        const r = Math.min(256e3, t), o = new Uint8Array(r);
        let n = 0;
        for (; n < t; ) {
          const u = t - n, p = await this.readBuffer(o, { length: Math.min(r, u) });
          if (p < 0)
            return p;
          n += p;
        }
        return n;
      }
    }
    l.ReadStreamTokenizer = i;
  }, 7378: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.fromBuffer = l.fromStream = l.EndOfStreamError = void 0;
    const e = s(8286), f = s(932);
    var i = s(4644);
    Object.defineProperty(l, "EndOfStreamError", { enumerable: !0, get: function() {
      return i.EndOfStreamError;
    } }), l.fromStream = function(a, t) {
      return t = t || {}, new e.ReadStreamTokenizer(a, t);
    }, l.fromBuffer = function(a, t) {
      return new f.BufferTokenizer(a, t);
    };
  }, 3569: (d, l, s) => {
    Object.defineProperty(l, "__esModule", { value: !0 }), l.fromStream = l.fromBuffer = l.EndOfStreamError = l.fromFile = void 0;
    const e = s(5187), f = s(7378);
    var i = s(9425);
    Object.defineProperty(l, "fromFile", { enumerable: !0, get: function() {
      return i.fromFile;
    } });
    var a = s(7378);
    Object.defineProperty(l, "EndOfStreamError", { enumerable: !0, get: function() {
      return a.EndOfStreamError;
    } }), Object.defineProperty(l, "fromBuffer", { enumerable: !0, get: function() {
      return a.fromBuffer;
    } }), l.fromStream = async function(t, r) {
      if (r = r || {}, t.path) {
        const o = await e.stat(t.path);
        r.path = t.path, r.size = o.size;
      }
      return f.fromStream(t, r);
    };
  }, 643: (d, l) => {
    var s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(o) {
      return typeof o;
    } : function(o) {
      return o && typeof Symbol == "function" && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
    };
    l.Ee = function(o, n, u, p, g, v) {
      for (var x = arguments.length, b = Array(x > 6 ? x - 6 : 0), w = 6; w < x; w++)
        b[w - 6] = arguments[w];
      return b.length ? t.call.apply(t, [null, !1, !0, o, n, u, p, g, v].concat(b)) : t(!1, !0, o, n, u, p, g, v);
    };
    var e = "INVALID_ARGS";
    function f(o) {
      throw new Error(o);
    }
    function i(o) {
      var n = Object.keys(o);
      return Object.getOwnPropertySymbols ? n.concat(Object.getOwnPropertySymbols(o)) : n;
    }
    function a(o) {
      if (Array.isArray(o))
        return o.slice();
      for (var n = i(o), u = {}, p = 0; p < n.length; p++) {
        var g = n[p];
        u[g] = o[g];
      }
      return u;
    }
    function t(o, n, u) {
      var p = u;
      p == null && f(e);
      for (var g = !1, v = arguments.length, x = Array(v > 3 ? v - 3 : 0), b = 3; b < v; b++)
        x[b - 3] = arguments[b];
      for (var w = 0; w < x.length; w++) {
        var M = x[w];
        if (M != null) {
          var G = i(M);
          if (G.length)
            for (var F = 0; F <= G.length; F++) {
              var V = G[F];
              if (!o || p[V] === void 0) {
                var q = M[V];
                n && r(p[V]) && r(q) && (q = t(o, n, p[V], q)), q !== void 0 && q !== p[V] && (g || (g = !0, p = a(p)), p[V] = q);
              }
            }
        }
      }
      return p;
    }
    function r(o) {
      var n = o === void 0 ? "undefined" : s(o);
      return o != null && n === "object";
    }
  }, 5010: (d, l, s) => {
    var e = s(8834).lW;
    Object.defineProperty(l, "__esModule", { value: !0 }), l.AnsiStringType = l.StringType = l.BufferType = l.Uint8ArrayType = l.IgnoreType = l.Float80_LE = l.Float80_BE = l.Float64_LE = l.Float64_BE = l.Float32_LE = l.Float32_BE = l.Float16_LE = l.Float16_BE = l.INT64_BE = l.UINT64_BE = l.INT64_LE = l.UINT64_LE = l.INT32_LE = l.INT32_BE = l.INT24_BE = l.INT24_LE = l.INT16_LE = l.INT16_BE = l.INT8 = l.UINT32_BE = l.UINT32_LE = l.UINT24_BE = l.UINT24_LE = l.UINT16_BE = l.UINT16_LE = l.UINT8 = void 0;
    const f = s(2333);
    function i(t) {
      return new DataView(t.buffer, t.byteOffset);
    }
    l.UINT8 = { len: 1, get: (t, r) => i(t).getUint8(r), put: (t, r, o) => (i(t).setUint8(r, o), r + 1) }, l.UINT16_LE = { len: 2, get: (t, r) => i(t).getUint16(r, !0), put: (t, r, o) => (i(t).setUint16(r, o, !0), r + 2) }, l.UINT16_BE = { len: 2, get: (t, r) => i(t).getUint16(r), put: (t, r, o) => (i(t).setUint16(r, o), r + 2) }, l.UINT24_LE = { len: 3, get(t, r) {
      const o = i(t);
      return o.getUint8(r) + (o.getUint16(r + 1, !0) << 8);
    }, put(t, r, o) {
      const n = i(t);
      return n.setUint8(r, 255 & o), n.setUint16(r + 1, o >> 8, !0), r + 3;
    } }, l.UINT24_BE = { len: 3, get(t, r) {
      const o = i(t);
      return (o.getUint16(r) << 8) + o.getUint8(r + 2);
    }, put(t, r, o) {
      const n = i(t);
      return n.setUint16(r, o >> 8), n.setUint8(r + 2, 255 & o), r + 3;
    } }, l.UINT32_LE = { len: 4, get: (t, r) => i(t).getUint32(r, !0), put: (t, r, o) => (i(t).setUint32(r, o, !0), r + 4) }, l.UINT32_BE = { len: 4, get: (t, r) => i(t).getUint32(r), put: (t, r, o) => (i(t).setUint32(r, o), r + 4) }, l.INT8 = { len: 1, get: (t, r) => i(t).getInt8(r), put: (t, r, o) => (i(t).setInt8(r, o), r + 1) }, l.INT16_BE = { len: 2, get: (t, r) => i(t).getInt16(r), put: (t, r, o) => (i(t).setInt16(r, o), r + 2) }, l.INT16_LE = { len: 2, get: (t, r) => i(t).getInt16(r, !0), put: (t, r, o) => (i(t).setInt16(r, o, !0), r + 2) }, l.INT24_LE = { len: 3, get(t, r) {
      const o = l.UINT24_LE.get(t, r);
      return o > 8388607 ? o - 16777216 : o;
    }, put(t, r, o) {
      const n = i(t);
      return n.setUint8(r, 255 & o), n.setUint16(r + 1, o >> 8, !0), r + 3;
    } }, l.INT24_BE = { len: 3, get(t, r) {
      const o = l.UINT24_BE.get(t, r);
      return o > 8388607 ? o - 16777216 : o;
    }, put(t, r, o) {
      const n = i(t);
      return n.setUint16(r, o >> 8), n.setUint8(r + 2, 255 & o), r + 3;
    } }, l.INT32_BE = { len: 4, get: (t, r) => i(t).getInt32(r), put: (t, r, o) => (i(t).setInt32(r, o), r + 4) }, l.INT32_LE = { len: 4, get: (t, r) => i(t).getInt32(r, !0), put: (t, r, o) => (i(t).setInt32(r, o, !0), r + 4) }, l.UINT64_LE = { len: 8, get: (t, r) => i(t).getBigUint64(r, !0), put: (t, r, o) => (i(t).setBigUint64(r, o, !0), r + 8) }, l.INT64_LE = { len: 8, get: (t, r) => i(t).getBigInt64(r, !0), put: (t, r, o) => (i(t).setBigInt64(r, o, !0), r + 8) }, l.UINT64_BE = { len: 8, get: (t, r) => i(t).getBigUint64(r), put: (t, r, o) => (i(t).setBigUint64(r, o), r + 8) }, l.INT64_BE = { len: 8, get: (t, r) => i(t).getBigInt64(r), put: (t, r, o) => (i(t).setBigInt64(r, o), r + 8) }, l.Float16_BE = { len: 2, get(t, r) {
      return f.read(t, r, !1, 10, this.len);
    }, put(t, r, o) {
      return f.write(t, o, r, !1, 10, this.len), r + this.len;
    } }, l.Float16_LE = { len: 2, get(t, r) {
      return f.read(t, r, !0, 10, this.len);
    }, put(t, r, o) {
      return f.write(t, o, r, !0, 10, this.len), r + this.len;
    } }, l.Float32_BE = { len: 4, get: (t, r) => i(t).getFloat32(r), put: (t, r, o) => (i(t).setFloat32(r, o), r + 4) }, l.Float32_LE = { len: 4, get: (t, r) => i(t).getFloat32(r, !0), put: (t, r, o) => (i(t).setFloat32(r, o, !0), r + 4) }, l.Float64_BE = { len: 8, get: (t, r) => i(t).getFloat64(r), put: (t, r, o) => (i(t).setFloat64(r, o), r + 8) }, l.Float64_LE = { len: 8, get: (t, r) => i(t).getFloat64(r, !0), put: (t, r, o) => (i(t).setFloat64(r, o, !0), r + 8) }, l.Float80_BE = { len: 10, get(t, r) {
      return f.read(t, r, !1, 63, this.len);
    }, put(t, r, o) {
      return f.write(t, o, r, !1, 63, this.len), r + this.len;
    } }, l.Float80_LE = { len: 10, get(t, r) {
      return f.read(t, r, !0, 63, this.len);
    }, put(t, r, o) {
      return f.write(t, o, r, !0, 63, this.len), r + this.len;
    } }, l.IgnoreType = class {
      constructor(t) {
        this.len = t;
      }
      get(t, r) {
      }
    }, l.Uint8ArrayType = class {
      constructor(t) {
        this.len = t;
      }
      get(t, r) {
        return t.subarray(r, r + this.len);
      }
    }, l.BufferType = class {
      constructor(t) {
        this.len = t;
      }
      get(t, r) {
        return e.from(t.subarray(r, r + this.len));
      }
    }, l.StringType = class {
      constructor(t, r) {
        this.len = t, this.encoding = r;
      }
      get(t, r) {
        return e.from(t).toString(this.encoding, r, r + this.len);
      }
    };
    class a {
      constructor(r) {
        this.len = r;
      }
      static decode(r, o, n) {
        let u = "";
        for (let p = o; p < n; ++p)
          u += a.codePointToString(a.singleByteDecoder(r[p]));
        return u;
      }
      static inRange(r, o, n) {
        return o <= r && r <= n;
      }
      static codePointToString(r) {
        return r <= 65535 ? String.fromCharCode(r) : (r -= 65536, String.fromCharCode(55296 + (r >> 10), 56320 + (1023 & r)));
      }
      static singleByteDecoder(r) {
        if (a.inRange(r, 0, 127))
          return r;
        const o = a.windows1252[r - 128];
        if (o === null)
          throw Error("invaliding encoding");
        return o;
      }
      get(r, o = 0) {
        return a.decode(r, o, o + this.len);
      }
    }
    l.AnsiStringType = a, a.windows1252 = [8364, 129, 8218, 402, 8222, 8230, 8224, 8225, 710, 8240, 352, 8249, 338, 141, 381, 143, 144, 8216, 8217, 8220, 8221, 8226, 8211, 8212, 732, 8482, 353, 8250, 339, 157, 382, 376, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255];
  }, 311: (d, l) => {
    (l = d.exports = function(s) {
      return s.replace(/^\s*|\s*$/g, "");
    }).left = function(s) {
      return s.replace(/^\s*/, "");
    }, l.right = function(s) {
      return s.replace(/\s*$/, "");
    };
  }, 9299: (d, l, s) => {
    var e = s(4406);
    (function() {
      var f = {};
      function i() {
        e === void 0 && console.log.apply(console, arguments);
      }
      d.exports = f, function(a, t) {
        var r, o, n, u, p, g, v, x, b, w, M, G, F, V, q;
        (function() {
          var I = function() {
            function W(O) {
              this.message = "JPEG error: " + O;
            }
            return W.prototype = new Error(), W.prototype.name = "JpegError", W.constructor = W, W;
          }(), _ = function() {
            var W = new Uint8Array([0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]), O = 4017, j = 799, U = 3406, C = 2276, ae = 1567, J = 3784, te = 5793, $ = 2896;
            function L(k) {
              k == null && (k = {}), k.w == null && (k.w = -1), this.V = k.n, this.N = k.w;
            }
            function re(k, T) {
              for (var B, K, h, c = 0, m = [], D = 16; D > 0 && !k[D - 1]; )
                D--;
              m.push({ children: [], index: 0 });
              var ee = m[0];
              for (B = 0; B < D; B++) {
                for (K = 0; K < k[B]; K++) {
                  for ((ee = m.pop()).children[ee.index] = T[c]; ee.index > 0; )
                    ee = m.pop();
                  for (ee.index++, m.push(ee); m.length <= B; )
                    m.push(h = { children: [], index: 0 }), ee.children[ee.index] = h.children, ee = h;
                  c++;
                }
                B + 1 < D && (m.push(h = { children: [], index: 0 }), ee.children[ee.index] = h.children, ee = h);
              }
              return m[0].children;
            }
            function z(k, T, B) {
              return 64 * ((k.P + 1) * T + B);
            }
            function N(k, T, B, K, h, c, m, D, ee, E) {
              E == null && (E = !1);
              var Q, se, Y, be, Ee, Me, ke, oe, ce, xe, Ce, _e = B.m, Be = B.Z, Pe = T, Fe = 0, We = 0, Qe = 0, lt = 0, P = 0, we = 0;
              function X() {
                if (We > 0)
                  return We--, Fe >> We & 1;
                if ((Fe = k[T++]) === 255) {
                  var Ie = k[T++];
                  if (Ie) {
                    if (Ie === 220 && E) {
                      var at = R(k, T += 2);
                      if (T += 2, at > 0 && at !== B.s)
                        throw new DNLMarkerError("Found DNL marker (0xFFDC) while parsing scan data", at);
                    } else if (Ie === 217) {
                      if (E) {
                        var st = 8 * P;
                        if (st > 0 && st < B.s / 10)
                          throw new DNLMarkerError("Found EOI marker (0xFFD9) while parsing scan data, possibly caused by incorrect `scanLines` parameter", st);
                      }
                      throw new EOIMarkerError("Found EOI marker (0xFFD9) while parsing scan data");
                    }
                    throw new I("unexpected marker");
                  }
                }
                return We = 7, Fe >>> 7;
              }
              function de(Ie) {
                for (var at = Ie; ; ) {
                  switch (typeof (at = at[X()])) {
                    case "number":
                      return at;
                    case "object":
                      continue;
                  }
                  throw new I("invalid huffman sequence");
                }
              }
              function Ze(Ie) {
                for (var at = 0; Ie > 0; )
                  at = at << 1 | X(), Ie--;
                return at;
              }
              function Re(Ie) {
                if (Ie === 1)
                  return X() === 1 ? 1 : -1;
                var at = Ze(Ie);
                return at >= 1 << Ie - 1 ? at : at + (-1 << Ie) + 1;
              }
              function rt(Ie, at, st, tt, mt) {
                var It = st % _e;
                P = (st / _e | 0) * Ie.A + tt;
                var wt = It * Ie.h + mt;
                at(Ie, z(Ie, P, wt));
              }
              function De(Ie, at, st) {
                P = st / Ie.P | 0;
                var tt = st % Ie.P;
                at(Ie, z(Ie, P, tt));
              }
              var Je = K.length;
              for (ke = Be ? c === 0 ? D === 0 ? function(Ie, at) {
                var st = de(Ie.J), tt = st === 0 ? 0 : Re(st) << ee;
                Ie.D[at] = Ie.Q += tt;
              } : function(Ie, at) {
                Ie.D[at] |= X() << ee;
              } : D === 0 ? function(Ie, at) {
                if (Qe > 0)
                  Qe--;
                else
                  for (var st = c, tt = m; st <= tt; ) {
                    var mt = de(Ie.i), It = 15 & mt, wt = mt >> 4;
                    if (It !== 0) {
                      var ot = W[st += wt];
                      Ie.D[at + ot] = Re(It) * (1 << ee), st++;
                    } else {
                      if (wt < 15) {
                        Qe = Ze(wt) + (1 << wt) - 1;
                        break;
                      }
                      st += 16;
                    }
                  }
              } : function(Ie, at) {
                for (var st, tt, mt = c, It = m, wt = 0; mt <= It; ) {
                  var ot = at + W[mt], kt = Ie.D[ot] < 0 ? -1 : 1;
                  switch (lt) {
                    case 0:
                      if (wt = (tt = de(Ie.i)) >> 4, (st = 15 & tt) == 0)
                        wt < 15 ? (Qe = Ze(wt) + (1 << wt), lt = 4) : (wt = 16, lt = 1);
                      else {
                        if (st !== 1)
                          throw new I("invalid ACn encoding");
                        Q = Re(st), lt = wt ? 2 : 3;
                      }
                      continue;
                    case 1:
                    case 2:
                      Ie.D[ot] ? Ie.D[ot] += kt * (X() << ee) : --wt == 0 && (lt = lt === 2 ? 3 : 0);
                      break;
                    case 3:
                      Ie.D[ot] ? Ie.D[ot] += kt * (X() << ee) : (Ie.D[ot] = Q << ee, lt = 0);
                      break;
                    case 4:
                      Ie.D[ot] && (Ie.D[ot] += kt * (X() << ee));
                  }
                  mt++;
                }
                lt === 4 && --Qe == 0 && (lt = 0);
              } : function(Ie, at) {
                var st = de(Ie.J), tt = st === 0 ? 0 : Re(st), mt = 1;
                for (Ie.D[at] = Ie.Q += tt; mt < 64; ) {
                  var It = de(Ie.i), wt = 15 & It, ot = It >> 4;
                  if (wt !== 0) {
                    var kt = W[mt += ot];
                    Ie.D[at + kt] = Re(wt), mt++;
                  } else {
                    if (ot < 15)
                      break;
                    mt += 16;
                  }
                }
              }, ce = Je === 1 ? K[0].P * K[0].c : _e * B.R; we <= ce; ) {
                var Ne = h ? Math.min(ce - we, h) : ce;
                if (Ne > 0) {
                  for (Y = 0; Y < Je; Y++)
                    K[Y].Q = 0;
                  if (Qe = 0, Je === 1)
                    for (se = K[0], Me = 0; Me < Ne; Me++)
                      De(se, ke, we), we++;
                  else
                    for (Me = 0; Me < Ne; Me++) {
                      for (Y = 0; Y < Je; Y++)
                        for (xe = (se = K[Y]).h, Ce = se.A, be = 0; be < Ce; be++)
                          for (Ee = 0; Ee < xe; Ee++)
                            rt(se, ke, we, be, Ee);
                      we++;
                    }
                }
                if (We = 0, !(oe = he(k, T)) || (oe.u && (T = oe.offset), !(oe.M >= 65488 && oe.M <= 65495)))
                  break;
                T += 2;
              }
              return T - Pe;
            }
            function ne(k, T, B) {
              var K, h, c, m, D, ee, E, Q, se, Y, be, Ee, Me, ke, oe, ce, xe, Ce = k.$, _e = k.D;
              if (!Ce)
                throw new I("missing required Quantization Table.");
              for (var Be = 0; Be < 64; Be += 8)
                se = _e[T + Be], Y = _e[T + Be + 1], be = _e[T + Be + 2], Ee = _e[T + Be + 3], Me = _e[T + Be + 4], ke = _e[T + Be + 5], oe = _e[T + Be + 6], ce = _e[T + Be + 7], se *= Ce[Be], Y | be | Ee | Me | ke | oe | ce ? (Y *= Ce[Be + 1], be *= Ce[Be + 2], Ee *= Ce[Be + 3], Me *= Ce[Be + 4], ke *= Ce[Be + 5], oe *= Ce[Be + 6], ce *= Ce[Be + 7], h = (K = (K = te * se + 128 >> 8) + (h = te * Me + 128 >> 8) + 1 >> 1) - h, xe = (c = be) * J + (m = oe) * ae + 128 >> 8, c = c * ae - m * J + 128 >> 8, E = (D = (D = $ * (Y - ce) + 128 >> 8) + (E = ke << 4) + 1 >> 1) - E, ee = (Q = (Q = $ * (Y + ce) + 128 >> 8) + (ee = Ee << 4) + 1 >> 1) - ee, m = (K = K + (m = xe) + 1 >> 1) - m, c = (h = h + c + 1 >> 1) - c, xe = D * C + Q * U + 2048 >> 12, D = D * U - Q * C + 2048 >> 12, Q = xe, xe = ee * j + E * O + 2048 >> 12, ee = ee * O - E * j + 2048 >> 12, E = xe, B[Be] = K + Q, B[Be + 7] = K - Q, B[Be + 1] = h + E, B[Be + 6] = h - E, B[Be + 2] = c + ee, B[Be + 5] = c - ee, B[Be + 3] = m + D, B[Be + 4] = m - D) : (xe = te * se + 512 >> 10, B[Be] = xe, B[Be + 1] = xe, B[Be + 2] = xe, B[Be + 3] = xe, B[Be + 4] = xe, B[Be + 5] = xe, B[Be + 6] = xe, B[Be + 7] = xe);
              for (var Pe = 0; Pe < 8; ++Pe)
                se = B[Pe], (Y = B[Pe + 8]) | (be = B[Pe + 16]) | (Ee = B[Pe + 24]) | (Me = B[Pe + 32]) | (ke = B[Pe + 40]) | (oe = B[Pe + 48]) | (ce = B[Pe + 56]) ? (h = (K = 4112 + ((K = te * se + 2048 >> 12) + (h = te * Me + 2048 >> 12) + 1 >> 1)) - h, xe = (c = be) * J + (m = oe) * ae + 2048 >> 12, c = c * ae - m * J + 2048 >> 12, m = xe, E = (D = (D = $ * (Y - ce) + 2048 >> 12) + (E = ke) + 1 >> 1) - E, ee = (Q = (Q = $ * (Y + ce) + 2048 >> 12) + (ee = Ee) + 1 >> 1) - ee, xe = D * C + Q * U + 2048 >> 12, D = D * U - Q * C + 2048 >> 12, Q = xe, xe = ee * j + E * O + 2048 >> 12, ee = ee * O - E * j + 2048 >> 12, (se = (K = K + m + 1 >> 1) + Q) < 16 ? se = 0 : se >= 4080 ? se = 255 : se >>= 4, (Y = (h = h + c + 1 >> 1) + (E = xe)) < 16 ? Y = 0 : Y >= 4080 ? Y = 255 : Y >>= 4, (be = (c = h - c) + ee) < 16 ? be = 0 : be >= 4080 ? be = 255 : be >>= 4, (Ee = (m = K - m) + D) < 16 ? Ee = 0 : Ee >= 4080 ? Ee = 255 : Ee >>= 4, (Me = m - D) < 16 ? Me = 0 : Me >= 4080 ? Me = 255 : Me >>= 4, (ke = c - ee) < 16 ? ke = 0 : ke >= 4080 ? ke = 255 : ke >>= 4, (oe = h - E) < 16 ? oe = 0 : oe >= 4080 ? oe = 255 : oe >>= 4, (ce = K - Q) < 16 ? ce = 0 : ce >= 4080 ? ce = 255 : ce >>= 4, _e[T + Pe] = se, _e[T + Pe + 8] = Y, _e[T + Pe + 16] = be, _e[T + Pe + 24] = Ee, _e[T + Pe + 32] = Me, _e[T + Pe + 40] = ke, _e[T + Pe + 48] = oe, _e[T + Pe + 56] = ce) : (xe = (xe = te * se + 8192 >> 14) < -2040 ? 0 : xe >= 2024 ? 255 : xe + 2056 >> 4, _e[T + Pe] = xe, _e[T + Pe + 8] = xe, _e[T + Pe + 16] = xe, _e[T + Pe + 24] = xe, _e[T + Pe + 32] = xe, _e[T + Pe + 40] = xe, _e[T + Pe + 48] = xe, _e[T + Pe + 56] = xe);
            }
            function le(k, T) {
              for (var B = T.P, K = T.c, h = new Int16Array(64), c = 0; c < K; c++)
                for (var m = 0; m < B; m++)
                  ne(T, z(T, c, m), h);
              return T.D;
            }
            function he(k, T, B) {
              B == null && (B = T);
              var K = k.length - 1, h = B < T ? B : T;
              if (T >= K)
                return null;
              var c = R(k, T);
              if (c >= 65472 && c <= 65534)
                return { u: null, M: c, offset: T };
              for (var m = R(k, h); !(m >= 65472 && m <= 65534); ) {
                if (++h >= K)
                  return null;
                m = R(k, h);
              }
              return { u: c.toString(16), M: m, offset: h };
            }
            return L.prototype = { parse(k, T) {
              T == null && (T = {});
              var B, K, h = T.F, c = 0, m = null, D = null, ee = 0;
              function E() {
                var Rt = R(k, c), qt = (c += 2) + Rt - 2, Lt = he(k, qt, c);
                Lt && Lt.u && (qt = Lt.offset);
                var Se = k.subarray(c, qt);
                return c += Se.length, Se;
              }
              function Q(Rt) {
                for (var qt = Math.ceil(Rt.o / 8 / Rt.X), Lt = Math.ceil(Rt.s / 8 / Rt.B), Se = 0; Se < Rt.W.length; Se++) {
                  De = Rt.W[Se];
                  var Ye = Math.ceil(Math.ceil(Rt.o / 8) * De.h / Rt.X), Ke = Math.ceil(Math.ceil(Rt.s / 8) * De.A / Rt.B), ut = qt * De.h, bt = Lt * De.A * 64 * (ut + 1);
                  De.D = new Int16Array(bt), De.P = Ye, De.c = Ke;
                }
                Rt.m = qt, Rt.R = Lt;
              }
              var se = [], Y = [], be = [], Ee = R(k, c);
              if (c += 2, Ee !== 65496)
                throw new I("SOI not found");
              Ee = R(k, c), c += 2;
              e:
                for (; Ee !== 65497; ) {
                  var Me, ke, oe;
                  switch (Ee) {
                    case 65504:
                    case 65505:
                    case 65506:
                    case 65507:
                    case 65508:
                    case 65509:
                    case 65510:
                    case 65511:
                    case 65512:
                    case 65513:
                    case 65514:
                    case 65515:
                    case 65516:
                    case 65517:
                    case 65518:
                    case 65519:
                    case 65534:
                      var ce = E();
                      Ee === 65504 && ce[0] === 74 && ce[1] === 70 && ce[2] === 73 && ce[3] === 70 && ce[4] === 0 && (m = { version: { d: ce[5], T: ce[6] }, K: ce[7], j: ce[8] << 8 | ce[9], H: ce[10] << 8 | ce[11], S: ce[12], I: ce[13], C: ce.subarray(14, 14 + 3 * ce[12] * ce[13]) }), Ee === 65518 && ce[0] === 65 && ce[1] === 100 && ce[2] === 111 && ce[3] === 98 && ce[4] === 101 && (D = { version: ce[5] << 8 | ce[6], k: ce[7] << 8 | ce[8], q: ce[9] << 8 | ce[10], a: ce[11] });
                      break;
                    case 65499:
                      for (var xe = R(k, c) + (c += 2) - 2; c < xe; ) {
                        var Ce = k[c++], _e = new Uint16Array(64);
                        if (Ce >> 4) {
                          if (Ce >> 4 != 1)
                            throw new I("DQT - invalid table spec");
                          for (ke = 0; ke < 64; ke++)
                            _e[W[ke]] = R(k, c), c += 2;
                        } else
                          for (ke = 0; ke < 64; ke++)
                            _e[W[ke]] = k[c++];
                        se[15 & Ce] = _e;
                      }
                      break;
                    case 65472:
                    case 65473:
                    case 65474:
                      if (B)
                        throw new I("Only single frame JPEGs supported");
                      c += 2, (B = {}).G = Ee === 65473, B.Z = Ee === 65474, B.precision = k[c++];
                      var Be, Pe = R(k, c), Fe = 0, We = 0;
                      c += 2, B.s = h || Pe, B.o = R(k, c), c += 2, B.W = [], B._ = {};
                      var Qe = k[c++];
                      for (Me = 0; Me < Qe; Me++) {
                        Be = k[c];
                        var lt = k[c + 1] >> 4, P = 15 & k[c + 1];
                        Fe < lt && (Fe = lt), We < P && (We = P);
                        var we = k[c + 2];
                        oe = B.W.push({ h: lt, A: P, L: we, $: null }), B._[Be] = oe - 1, c += 3;
                      }
                      B.X = Fe, B.B = We, Q(B);
                      break;
                    case 65476:
                      var X = R(k, c);
                      for (c += 2, Me = 2; Me < X; ) {
                        var de = k[c++], Ze = new Uint8Array(16), Re = 0;
                        for (ke = 0; ke < 16; ke++, c++)
                          Re += Ze[ke] = k[c];
                        var rt = new Uint8Array(Re);
                        for (ke = 0; ke < Re; ke++, c++)
                          rt[ke] = k[c];
                        Me += 17 + Re, (de >> 4 ? Y : be)[15 & de] = re(Ze, rt);
                      }
                      break;
                    case 65501:
                      K = R(k, c += 2), c += 2;
                      break;
                    case 65498:
                      var De, Je = ++ee == 1 && !h;
                      c += 2;
                      var Ne = k[c++], Ie = [];
                      for (Me = 0; Me < Ne; Me++) {
                        var at = k[c++], st = B._[at];
                        (De = B.W[st]).index = at;
                        var tt = k[c++];
                        De.J = be[tt >> 4], De.i = Y[15 & tt], Ie.push(De);
                      }
                      var mt = k[c++], It = k[c++], wt = k[c++];
                      try {
                        var ot = N(k, c, B, Ie, K, mt, It, wt >> 4, 15 & wt, Je);
                        c += ot;
                      } catch (Rt) {
                        if (Rt instanceof DNLMarkerError)
                          return this.parse(k, { F: Rt.s });
                        if (Rt instanceof EOIMarkerError)
                          break e;
                        throw Rt;
                      }
                      break;
                    case 65500:
                      c += 4;
                      break;
                    case 65535:
                      k[c] !== 255 && c--;
                      break;
                    default:
                      var kt = he(k, c - 2, c - 3);
                      if (kt && kt.u) {
                        c = kt.offset;
                        break;
                      }
                      if (c >= k.length - 1)
                        break e;
                      throw new I("JpegImage.parse - unknown marker: " + Ee.toString(16));
                  }
                  Ee = R(k, c), c += 2;
                }
              for (this.width = B.o, this.height = B.s, this.g = m, this.b = D, this.W = [], Me = 0; Me < B.W.length; Me++) {
                var Ft = se[(De = B.W[Me]).L];
                Ft && (De.$ = Ft), this.W.push({ index: De.index, e: le(0, De), l: De.h / B.X, t: De.A / B.B, P: De.P, c: De.c });
              }
              this.p = this.W.length;
            }, Y(k, T, B) {
              B == null && (B = !1);
              var K, h, c, m, D, ee, E, Q, se, Y, be, Ee, Me = this.width / k, ke = this.height / T, oe = 0, ce = this.W.length, xe = k * T * ce, Ce = new Uint8ClampedArray(xe), _e = new Uint32Array(k), Be = 4294967288;
              for (E = 0; E < ce; E++) {
                if (h = (K = this.W[E]).l * Me, c = K.t * ke, oe = E, be = K.e, m = K.P + 1 << 3, h !== Ee) {
                  for (D = 0; D < k; D++)
                    Q = 0 | D * h, _e[D] = (Q & Be) << 3 | 7 & Q;
                  Ee = h;
                }
                for (ee = 0; ee < T; ee++)
                  for (Y = m * ((Q = 0 | ee * c) & Be) | (7 & Q) << 3, D = 0; D < k; D++)
                    Ce[oe] = be[Y + _e[D]], oe += ce;
              }
              var Pe = this.V;
              if (B || ce !== 4 || Pe || (Pe = new Int32Array([-256, 255, -256, 255, -256, 255, -256, 255])), Pe)
                for (E = 0; E < xe; )
                  for (Q = 0, se = 0; Q < ce; Q++, E++, se += 2)
                    Ce[E] = (Ce[E] * Pe[se] >> 8) + Pe[se + 1];
              return Ce;
            }, get f() {
              return this.b ? !!this.b.a : this.p === 3 ? this.N !== 0 && (this.W[0].index !== 82 || this.W[1].index !== 71 || this.W[2].index !== 66) : this.N === 1;
            }, z: function(k) {
              for (var T, B, K, h = 0, c = k.length; h < c; h += 3)
                T = k[h], B = k[h + 1], K = k[h + 2], k[h] = T - 179.456 + 1.402 * K, k[h + 1] = T + 135.459 - 0.344 * B - 0.714 * K, k[h + 2] = T - 226.816 + 1.772 * B;
              return k;
            }, O: function(k) {
              for (var T, B, K, h, c = 0, m = 0, D = k.length; m < D; m += 4)
                T = k[m], B = k[m + 1], K = k[m + 2], h = k[m + 3], k[c++] = B * (-660635669420364e-19 * B + 437130475926232e-18 * K - 54080610064599e-18 * T + 48449797120281e-17 * h - 0.154362151871126) - 122.67195406894 + K * (-957964378445773e-18 * K + 817076911346625e-18 * T - 0.00477271405408747 * h + 1.53380253221734) + T * (961250184130688e-18 * T - 0.00266257332283933 * h + 0.48357088451265) + h * (-336197177618394e-18 * h + 0.484791561490776), k[c++] = 107.268039397724 + B * (219927104525741e-19 * B - 640992018297945e-18 * K + 659397001245577e-18 * T + 426105652938837e-18 * h - 0.176491792462875) + K * (-778269941513683e-18 * K + 0.00130872261408275 * T + 770482631801132e-18 * h - 0.151051492775562) + T * (0.00126935368114843 * T - 0.00265090189010898 * h + 0.25802910206845) + h * (-318913117588328e-18 * h - 0.213742400323665), k[c++] = B * (-570115196973677e-18 * B - 263409051004589e-19 * K + 0.0020741088115012 * T - 0.00288260236853442 * h + 0.814272968359295) - 20.810012546947 + K * (-153496057440975e-19 * K - 132689043961446e-18 * T + 560833691242812e-18 * h - 0.195152027534049) + T * (0.00174418132927582 * T - 0.00255243321439347 * h + 0.116935020465145) + h * (-343531996510555e-18 * h + 0.24165260232407);
              return k.subarray(0, c);
            }, r: function(k) {
              for (var T, B, K, h = 0, c = k.length; h < c; h += 4)
                T = k[h], B = k[h + 1], K = k[h + 2], k[h] = 434.456 - T - 1.402 * K, k[h + 1] = 119.541 - T + 0.344 * B + 0.714 * K, k[h + 2] = 481.816 - T - 1.772 * B;
              return k;
            }, U: function(k) {
              for (var T, B, K, h, c = 0, m = 0, D = k.length; m < D; m += 4)
                T = k[m], B = k[m + 1], K = k[m + 2], h = k[m + 3], k[c++] = 255 + T * (-6747147073602441e-20 * T + 8379262121013727e-19 * B + 2894718188643294e-19 * K + 0.003264231057537806 * h - 1.1185611867203937) + B * (26374107616089405e-21 * B - 8626949158638572e-20 * K - 2748769067499491e-19 * h - 0.02155688794978967) + K * (-3878099212869363e-20 * K - 3267808279485286e-19 * h + 0.0686742238595345) - h * (3361971776183937e-19 * h + 0.7430659151342254), k[c++] = 255 + T * (13596372813588848e-20 * T + 924537132573585e-18 * B + 10567359618683593e-20 * K + 4791864687436512e-19 * h - 0.3109689587515875) + B * (-23545346108370344e-20 * B + 2702845253534714e-19 * K + 0.0020200308977307156 * h - 0.7488052167015494) + K * (6834815998235662e-20 * K + 15168452363460973e-20 * h - 0.09751927774728933) - h * (3189131175883281e-19 * h + 0.7364883807733168), k[c++] = 255 + T * (13598650411385307e-21 * T + 12423956175490851e-20 * B + 4751985097583589e-19 * K - 36729317476630422e-22 * h - 0.05562186980264034) + B * (16141380598724676e-20 * B + 9692239130725186e-19 * K + 7782692450036253e-19 * h - 0.44015232367526463) + K * (5068882914068769e-22 * K + 0.0017778369011375071 * h - 0.7591454649749609) - h * (3435319965105553e-19 * h + 0.7063770186160144);
              return k.subarray(0, c);
            }, getData: function(k) {
              var T = k.width, B = k.height, K = k.forceRGB, h = k.isSourcePDF;
              if (this.p > 4)
                throw new I("Unsupported color mode");
              var c = this.Y(T, B, h);
              if (this.p === 1 && K) {
                for (var m = c.length, D = new Uint8ClampedArray(3 * m), ee = 0, E = 0; E < m; E++) {
                  var Q = c[E];
                  D[ee++] = Q, D[ee++] = Q, D[ee++] = Q;
                }
                return D;
              }
              if (this.p === 3 && this.f)
                return this.z(c);
              if (this.p === 4) {
                if (this.f)
                  return K ? this.O(c) : this.r(c);
                if (K)
                  return this.U(c);
              }
              return c;
            } }, L;
          }();
          function R(W, O) {
            return W[O] << 8 | W[O + 1];
          }
          a.JpegDecoder = _;
        })(), a.encodeImage = function(I, _, R, W) {
          var O = { t256: [_], t257: [R], t258: [8, 8, 8, 8], t259: [1], t262: [2], t273: [1e3], t277: [4], t278: [R], t279: [_ * R * 4], t282: [[72, 1]], t283: [[72, 1]], t284: [1], t286: [[0, 1]], t287: [[0, 1]], t296: [1], t305: ["Photopea (UTIF.js)"], t338: [1] };
          if (W)
            for (var j in W)
              O[j] = W[j];
          var U = new Uint8Array(a.encode([O])), C = new Uint8Array(I), ae = new Uint8Array(1e3 + _ * R * 4);
          for (j = 0; j < U.length; j++)
            ae[j] = U[j];
          for (j = 0; j < C.length; j++)
            ae[1e3 + j] = C[j];
          return ae.buffer;
        }, a.encode = function(I) {
          var _ = new Uint8Array(2e4), R = 4, W = a._binBE;
          _[0] = _[1] = 77, W.writeUshort(_, 2, 42);
          var O = 8;
          W.writeUint(_, R, O), R += 4;
          for (var j = 0; j < I.length; j++) {
            var U = a._writeIFD(W, a._types.basic, _, O, I[j]);
            O = U[1], j < I.length - 1 && (3 & O && (O += 4 - (3 & O)), W.writeUint(_, U[0], O));
          }
          return _.slice(0, O).buffer;
        }, a.decode = function(I, _) {
          _ == null && (_ = { parseMN: !0, debug: !1 });
          var R = new Uint8Array(I), W = 0, O = a._binBE.readASCII(R, W, 2);
          W += 2;
          var j = O == "II" ? a._binLE : a._binBE;
          j.readUshort(R, W), W += 2;
          var U = j.readUint(R, W);
          W += 4;
          for (var C = []; ; ) {
            var ae = j.readUshort(R, U), J = j.readUshort(R, U + 4);
            if (ae != 0 && (J < 1 || 13 < J)) {
              i("error in TIFF");
              break;
            }
            if (a._readIFD(j, R, U, C, 0, _), (U = j.readUint(R, U + 2 + 12 * ae)) == 0)
              break;
          }
          return C;
        }, a.decodeImage = function(I, _, R) {
          if (!_.data) {
            var W = new Uint8Array(I), O = a._binBE.readASCII(W, 0, 2);
            if (_.t256 != null) {
              _.isLE = O == "II", _.width = _.t256[0], _.height = _.t257[0];
              var j, U = _.t259 ? _.t259[0] : 1, C = _.t266 ? _.t266[0] : 1;
              _.t284 && _.t284[0] == 2 && i("PlanarConfiguration 2 should not be used!"), U == 7 && _.t258 && _.t258.length > 3 && (_.t258 = _.t258.slice(0, 3)), j = _.t258 ? Math.min(32, _.t258[0]) * _.t258.length : _.t277 ? _.t277[0] : 1, U == 1 && _.t279 != null && _.t278 && _.t262[0] == 32803 && (j = Math.round(8 * _.t279[0] / (_.width * _.t278[0]))), _.t50885 && _.t50885[0] == 4 && (j = 3 * _.t258[0]);
              var ae = 8 * Math.ceil(_.width * j / 8), J = _.t273;
              (J == null || _.t322) && (J = _.t324);
              var te = _.t279;
              U == 1 && J.length == 1 && (te = [_.height * (ae >>> 3)]), (te == null || _.t322) && (te = _.t325);
              var $ = new Uint8Array(_.height * (ae >>> 3)), L = 0;
              if (_.t322 != null) {
                var re = _.t322[0], z = _.t323[0], N = Math.floor((_.width + re - 1) / re), ne = Math.floor((_.height + z - 1) / z), le = new Uint8Array(0 | Math.ceil(re * z * j / 8));
                console.log("====", N, ne);
                for (var he = 0; he < ne; he++)
                  for (var k = 0; k < N; k++) {
                    var T = he * N + k;
                    le.fill(0), a.decode._decompress(_, R, W, J[T], te[T], U, le, 0, C), U == 6 ? $ = le : a._copyTile(le, 0 | Math.ceil(re * j / 8), z, $, 0 | Math.ceil(_.width * j / 8), _.height, 0 | Math.ceil(k * re * j / 8), he * z);
                  }
                L = 8 * $.length;
              } else {
                var B = _.t278 ? _.t278[0] : _.height;
                for (B = Math.min(B, _.height), console.log("====", _.width, B), T = 0; T < J.length; T++)
                  a.decode._decompress(_, R, W, J[T], te[T], U, $, 0 | Math.ceil(L / 8), C), L += ae * B;
                L = Math.min(L, 8 * $.length);
              }
              _.data = new Uint8Array($.buffer, 0, 0 | Math.ceil(L / 8));
            }
          }
        }, a.decode._decompress = function(I, _, R, W, O, j, U, C, ae) {
          if (j == 1)
            for (var J = 0; J < O; J++)
              U[C + J] = R[W + J];
          else if (j == 2)
            a.decode._decodeG2(R, W, O, U, C, I.width, ae);
          else if (j == 3)
            a.decode._decodeG3(R, W, O, U, C, I.width, ae, !!I.t292 && (1 & I.t292[0]) == 1);
          else if (j == 4)
            a.decode._decodeG4(R, W, O, U, C, I.width, ae);
          else if (j == 5)
            a.decode._decodeLZW(R, W, O, U, C, 8);
          else if (j == 6)
            a.decode._decodeOldJPEG(I, R, W, O, U, C);
          else if (j == 7 || j == 34892)
            a.decode._decodeNewJPEG(I, R, W, O, U, C);
          else if (j == 8 || j == 32946)
            for (var te = new Uint8Array(R.buffer, W, O), $ = t.inflate(te), L = 0; L < $.length; L++)
              U[C + L] = $[L];
          else
            j == 9 ? a.decode._decodeVC5(R, W, O, U, C) : j == 32767 ? a.decode._decodeARW(I, R, W, O, U, C) : j == 32773 ? a.decode._decodePackBits(R, W, O, U, C) : j == 32809 ? a.decode._decodeThunder(R, W, O, U, C) : j == 34713 ? a.decode._decodeNikon(I, _, R, W, O, U, C) : j == 34676 ? a.decode._decodeLogLuv32(I, R, W, O, U, C) : i("Unknown compression", j);
          var re = I.t258 ? Math.min(32, I.t258[0]) : 1, z = I.t277 ? I.t277[0] : 1, N = re * z >>> 3, ne = I.t278 ? I.t278[0] : I.height, le = Math.ceil(re * z * I.width / 8);
          if (re == 16 && !I.isLE && I.t33422 == null)
            for (var he = 0; he < ne; he++)
              for (var k = C + he * le, T = 1; T < le; T += 2) {
                var B = U[k + T];
                U[k + T] = U[k + T - 1], U[k + T - 1] = B;
              }
          if (I.t317 && I.t317[0] == 2)
            for (he = 0; he < ne; he++) {
              var K = C + he * le;
              if (re == 16)
                for (J = N; J < le; J += 2) {
                  var h = (U[K + J + 1] << 8 | U[K + J]) + (U[K + J - N + 1] << 8 | U[K + J - N]);
                  U[K + J] = 255 & h, U[K + J + 1] = h >>> 8 & 255;
                }
              else if (z == 3)
                for (J = 3; J < le; J += 3)
                  U[K + J] = U[K + J] + U[K + J - 3] & 255, U[K + J + 1] = U[K + J + 1] + U[K + J - 2] & 255, U[K + J + 2] = U[K + J + 2] + U[K + J - 1] & 255;
              else
                for (J = N; J < le; J++)
                  U[K + J] = U[K + J] + U[K + J - N] & 255;
            }
        }, a.decode._decodeVC5 = a.decode._decodeVC5 = function() {
          var I, _, R, W = [1, 0, 1, 0, 2, 2, 1, 1, 3, 7, 1, 2, 5, 25, 1, 3, 6, 48, 1, 4, 6, 54, 1, 5, 7, 111, 1, 8, 7, 99, 1, 6, 7, 105, 12, 0, 7, 107, 1, 7, 8, 209, 20, 0, 8, 212, 1, 9, 8, 220, 1, 10, 9, 393, 1, 11, 9, 394, 32, 0, 9, 416, 1, 12, 9, 427, 1, 13, 10, 887, 1, 18, 10, 784, 1, 14, 10, 790, 1, 15, 10, 835, 60, 0, 10, 852, 1, 16, 10, 885, 1, 17, 11, 1571, 1, 19, 11, 1668, 1, 20, 11, 1669, 100, 0, 11, 1707, 1, 21, 11, 1772, 1, 22, 12, 3547, 1, 29, 12, 3164, 1, 24, 12, 3166, 1, 25, 12, 3140, 1, 23, 12, 3413, 1, 26, 12, 3537, 1, 27, 12, 3539, 1, 28, 13, 7093, 1, 35, 13, 6283, 1, 30, 13, 6331, 1, 31, 13, 6335, 180, 0, 13, 6824, 1, 32, 13, 7072, 1, 33, 13, 7077, 320, 0, 13, 7076, 1, 34, 14, 12565, 1, 36, 14, 12661, 1, 37, 14, 12669, 1, 38, 14, 13651, 1, 39, 14, 14184, 1, 40, 15, 28295, 1, 46, 15, 28371, 1, 47, 15, 25320, 1, 42, 15, 25336, 1, 43, 15, 25128, 1, 41, 15, 27300, 1, 44, 15, 28293, 1, 45, 16, 50259, 1, 48, 16, 50643, 1, 49, 16, 50675, 1, 50, 16, 56740, 1, 53, 16, 56584, 1, 51, 16, 56588, 1, 52, 17, 113483, 1, 61, 17, 113482, 1, 60, 17, 101285, 1, 55, 17, 101349, 1, 56, 17, 109205, 1, 57, 17, 109207, 1, 58, 17, 100516, 1, 54, 17, 113171, 1, 59, 18, 202568, 1, 62, 18, 202696, 1, 63, 18, 218408, 1, 64, 18, 218412, 1, 65, 18, 226340, 1, 66, 18, 226356, 1, 67, 18, 226358, 1, 68, 19, 402068, 1, 69, 19, 405138, 1, 70, 19, 405394, 1, 71, 19, 436818, 1, 72, 19, 436826, 1, 73, 19, 452714, 1, 75, 19, 452718, 1, 76, 19, 452682, 1, 74, 20, 804138, 1, 77, 20, 810279, 1, 78, 20, 810790, 1, 79, 20, 873638, 1, 80, 20, 873654, 1, 81, 20, 905366, 1, 82, 20, 905430, 1, 83, 20, 905438, 1, 84, 21, 1608278, 1, 85, 21, 1620557, 1, 86, 21, 1621582, 1, 87, 21, 1621583, 1, 88, 21, 1747310, 1, 89, 21, 1810734, 1, 90, 21, 1810735, 1, 91, 21, 1810863, 1, 92, 21, 1810879, 1, 93, 22, 3621725, 1, 99, 22, 3621757, 1, 100, 22, 3241112, 1, 94, 22, 3494556, 1, 95, 22, 3494557, 1, 96, 22, 3494622, 1, 97, 22, 3494623, 1, 98, 23, 6482227, 1, 102, 23, 6433117, 1, 101, 23, 6989117, 1, 103, 23, 6989119, 1, 105, 23, 6989118, 1, 104, 23, 7243449, 1, 106, 23, 7243512, 1, 107, 24, 13978233, 1, 111, 24, 12964453, 1, 109, 24, 12866232, 1, 108, 24, 14486897, 1, 113, 24, 13978232, 1, 110, 24, 14486896, 1, 112, 24, 14487026, 1, 114, 24, 14487027, 1, 115, 25, 25732598, 1, 225, 25, 25732597, 1, 189, 25, 25732596, 1, 188, 25, 25732595, 1, 203, 25, 25732594, 1, 202, 25, 25732593, 1, 197, 25, 25732592, 1, 207, 25, 25732591, 1, 169, 25, 25732590, 1, 223, 25, 25732589, 1, 159, 25, 25732522, 1, 235, 25, 25732579, 1, 152, 25, 25732575, 1, 192, 25, 25732489, 1, 179, 25, 25732573, 1, 201, 25, 25732472, 1, 172, 25, 25732576, 1, 149, 25, 25732488, 1, 178, 25, 25732566, 1, 120, 25, 25732571, 1, 219, 25, 25732577, 1, 150, 25, 25732487, 1, 127, 25, 25732506, 1, 211, 25, 25732548, 1, 125, 25, 25732588, 1, 158, 25, 25732486, 1, 247, 25, 25732467, 1, 238, 25, 25732508, 1, 163, 25, 25732552, 1, 228, 25, 25732603, 1, 183, 25, 25732513, 1, 217, 25, 25732587, 1, 168, 25, 25732520, 1, 122, 25, 25732484, 1, 128, 25, 25732562, 1, 249, 25, 25732505, 1, 187, 25, 25732504, 1, 186, 25, 25732483, 1, 136, 25, 25928905, 1, 181, 25, 25732560, 1, 255, 25, 25732500, 1, 230, 25, 25732482, 1, 135, 25, 25732555, 1, 233, 25, 25732568, 1, 222, 25, 25732583, 1, 145, 25, 25732481, 1, 134, 25, 25732586, 1, 167, 25, 25732521, 1, 248, 25, 25732518, 1, 209, 25, 25732480, 1, 243, 25, 25732512, 1, 216, 25, 25732509, 1, 164, 25, 25732547, 1, 140, 25, 25732479, 1, 157, 25, 25732544, 1, 239, 25, 25732574, 1, 191, 25, 25732564, 1, 251, 25, 25732478, 1, 156, 25, 25732546, 1, 139, 25, 25732498, 1, 242, 25, 25732557, 1, 133, 25, 25732477, 1, 162, 25, 25732515, 1, 213, 25, 25732584, 1, 165, 25, 25732514, 1, 212, 25, 25732476, 1, 227, 25, 25732494, 1, 198, 25, 25732531, 1, 236, 25, 25732530, 1, 234, 25, 25732529, 1, 117, 25, 25732528, 1, 215, 25, 25732527, 1, 124, 25, 25732526, 1, 123, 25, 25732525, 1, 254, 25, 25732524, 1, 253, 25, 25732523, 1, 148, 25, 25732570, 1, 218, 25, 25732580, 1, 146, 25, 25732581, 1, 147, 25, 25732569, 1, 224, 25, 25732533, 1, 143, 25, 25732540, 1, 184, 25, 25732541, 1, 185, 25, 25732585, 1, 166, 25, 25732556, 1, 132, 25, 25732485, 1, 129, 25, 25732563, 1, 250, 25, 25732578, 1, 151, 25, 25732501, 1, 119, 25, 25732502, 1, 193, 25, 25732536, 1, 176, 25, 25732496, 1, 245, 25, 25732553, 1, 229, 25, 25732516, 1, 206, 25, 25732582, 1, 144, 25, 25732517, 1, 208, 25, 25732558, 1, 137, 25, 25732543, 1, 241, 25, 25732466, 1, 237, 25, 25732507, 1, 190, 25, 25732542, 1, 240, 25, 25732551, 1, 131, 25, 25732554, 1, 232, 25, 25732565, 1, 252, 25, 25732475, 1, 171, 25, 25732493, 1, 205, 25, 25732492, 1, 204, 25, 25732491, 1, 118, 25, 25732490, 1, 214, 25, 25928904, 1, 180, 25, 25732549, 1, 126, 25, 25732602, 1, 182, 25, 25732539, 1, 175, 25, 25732545, 1, 141, 25, 25732559, 1, 138, 25, 25732537, 1, 177, 25, 25732534, 1, 153, 25, 25732503, 1, 194, 25, 25732606, 1, 160, 25, 25732567, 1, 121, 25, 25732538, 1, 174, 25, 25732497, 1, 246, 25, 25732550, 1, 130, 25, 25732572, 1, 200, 25, 25732474, 1, 170, 25, 25732511, 1, 221, 25, 25732601, 1, 196, 25, 25732532, 1, 142, 25, 25732519, 1, 210, 25, 25732495, 1, 199, 25, 25732605, 1, 155, 25, 25732535, 1, 154, 25, 25732499, 1, 244, 25, 25732510, 1, 220, 25, 25732600, 1, 195, 25, 25732607, 1, 161, 25, 25732604, 1, 231, 25, 25732473, 1, 173, 25, 25732599, 1, 226, 26, 51465122, 1, 116, 26, 51465123, 0, 1], O = [3, 3, 3, 3, 2, 2, 2, 1, 1, 1];
          function j(re) {
            var z = re[1], N = re[0][z >>> 3] >>> 7 - (7 & z) & 1;
            return re[1]++, N;
          }
          function U(re, z) {
            if (I == null) {
              I = {};
              for (var N = 0; N < W.length; N += 4)
                I[W[N + 1]] = W.slice(N, N + 4);
            }
            for (var ne = j(re), le = I[ne]; le == null; )
              ne = ne << 1 | j(re), le = I[ne];
            var he = le[3];
            he != 0 && (he = j(re) == 0 ? he : -he), z[0] = le[2], z[1] = he;
          }
          function C(re, z) {
            for (var N = 0; N < z; N++)
              (1 & re) == 1 && re++, re >>>= 1;
            return re;
          }
          function ae(re, z) {
            return re >> z;
          }
          function J(re, z, N, ne, le, he) {
            z[N] = ae(ae(11 * re[le] - 4 * re[le + he] + re[le + he + he] + 4, 3) + re[ne], 1), z[N + he] = ae(ae(5 * re[le] + 4 * re[le + he] - re[le + he + he] + 4, 3) - re[ne], 1);
          }
          function te(re, z, N, ne, le, he) {
            var k = re[le - he] - re[le + he], T = re[le], B = re[ne];
            z[N] = ae(ae(k + 4, 3) + T + B, 1), z[N + he] = ae(ae(4 - k, 3) + T - B, 1);
          }
          function $(re, z, N, ne, le, he) {
            z[N] = ae(ae(5 * re[le] + 4 * re[le - he] - re[le - he - he] + 4, 3) + re[ne], 1), z[N + he] = ae(ae(11 * re[le] - 4 * re[le - he] + re[le - he - he] + 4, 3) - re[ne], 1);
          }
          function L(re) {
            return R[re = re < 0 ? 0 : re > 4095 ? 4095 : re] >>> 2;
          }
          return function(re, z, N, ne, le) {
            ne = new Uint16Array(ne.buffer);
            var he, k, T, B, K, h, c, m, D = Date.now(), ee = a._binBE, E = z + N;
            for (z += 4; z < E; ) {
              var Q = ee.readShort(re, z), se = ee.readUshort(re, z + 2);
              if (z += 4, Q == 12)
                ce = se;
              else if (Q == 20)
                he = se;
              else if (Q == 21)
                k = se;
              else if (Q == 48)
                T = se;
              else if (Q == 53)
                B = se;
              else if (Q != 35) {
                if (Q == 62)
                  K = se;
                else if (Q != 101) {
                  if (Q == 109)
                    h = se;
                  else if (Q != 84) {
                    if (Q != 106) {
                      if (Q != 107) {
                        if (Q != 108) {
                          if (Q != 102) {
                            if (Q == 104)
                              Ie = se;
                            else if (Q != 105) {
                              var Y = Q < 0 ? -Q : Q, be = 65280 & Y, Ee = 0;
                              if (24576 & Y && (8192 & Y ? (Ee = 65535 & se, Ee += (255 & Y) << 16) : Ee = 65535 & se), (24576 & Y) == 24576) {
                                if (c == null) {
                                  c = [];
                                  for (var Me = 0; Me < 4; Me++)
                                    c[Me] = new Int16Array((he >>> 1) * (k >>> 1));
                                  for (m = new Int16Array((he >>> 1) * (k >>> 1)), _ = new Int16Array(1024), Me = 0; Me < 1024; Me++) {
                                    var ke = Me - 512, oe = Math.abs(ke), ce = Math.floor(768 * oe * oe * oe / 16581375) + oe;
                                    _[Me] = Math.sign(ke) * ce;
                                  }
                                  for (R = new Uint16Array(4096), Me = 0; Me < 4096; Me++) {
                                    var xe = Me, Ce = 65535 * (Math.pow(113, xe / 4095) - 1) / 112;
                                    R[Me] = Math.min(Ce, 65535);
                                  }
                                }
                                var _e = c[K], Be = C(he, 1 + O[T]), Pe = C(k, 1 + O[T]);
                                if (T == 0)
                                  for (var Fe = 0; Fe < Pe; Fe++)
                                    for (var We = 0; We < Be; We++) {
                                      var Qe = z + 2 * (Fe * Be + We);
                                      _e[Fe * (he >>> 1) + We] = re[Qe] << 8 | re[Qe + 1];
                                    }
                                else {
                                  var lt = [re, 8 * z], P = [], we = 0, X = Be * Pe, de = [0, 0], Ze = 0;
                                  for (se = 0; we < X; )
                                    for (U(lt, de), Ze = de[0], se = de[1]; Ze > 0; )
                                      P[we++] = se, Ze--;
                                  var Re = (T - 1) % 3, rt = Re != 1 ? Be : 0, De = Re != 0 ? Pe : 0;
                                  for (Fe = 0; Fe < Pe; Fe++) {
                                    var Je = (Fe + De) * (he >>> 1) + rt, Ne = Fe * Be;
                                    for (We = 0; We < Be; We++)
                                      _e[Je + We] = _[P[Ne + We] + 512] * B;
                                  }
                                  if (Re == 2) {
                                    var Ie = he >>> 1, at = 2 * Be, st = 2 * Pe;
                                    for (Fe = 0; Fe < Pe; Fe++)
                                      for (We = 0; We < at; We++) {
                                        Me = 2 * Fe * Ie + We;
                                        var tt = Pe * Ie + (It = Fe * Ie + We);
                                        Fe == 0 ? J(_e, m, Me, tt, It, Ie) : Fe == Pe - 1 ? $(_e, m, Me, tt, It, Ie) : te(_e, m, Me, tt, It, Ie);
                                      }
                                    var mt = _e;
                                    for (_e = m, m = mt, Fe = 0; Fe < st; Fe++)
                                      for (We = 0; We < Be; We++) {
                                        var It;
                                        Me = Fe * Ie + 2 * We, tt = Be + (It = Fe * Ie + We), We == 0 ? J(_e, m, Me, tt, It, 1) : We == Be - 1 ? $(_e, m, Me, tt, It, 1) : te(_e, m, Me, tt, It, 1);
                                      }
                                    mt = _e, _e = m, m = mt;
                                    for (var wt = [], ot = 2 - ~~((T - 1) / 3), kt = 0; kt < 3; kt++)
                                      wt[kt] = h >> 14 - 2 * kt & 3;
                                    var Ft = wt[ot];
                                    if (Ft != 0)
                                      for (Fe = 0; Fe < st; Fe++)
                                        for (We = 0; We < at; We++)
                                          _e[Me = Fe * Ie + We] = _e[Me] << Ft;
                                  }
                                }
                                if (T == 9 && K == 3) {
                                  var Rt = c[0], qt = c[1], Lt = c[2], Se = c[3];
                                  for (Fe = 0; Fe < k; Fe += 2)
                                    for (We = 0; We < he; We += 2) {
                                      var Ye = Fe * he + We, Ke = Rt[Qe = (Fe >>> 1) * (he >>> 1) + (We >>> 1)], ut = qt[Qe] - 2048, bt = Lt[Qe] - 2048, At = Se[Qe] - 2048, Ct = (ut << 1) + Ke, vt = (bt << 1) + Ke, Dt = Ke + At, Nt = Ke - At;
                                      ne[Ye] = L(Ct), ne[Ye + 1] = L(Dt), ne[Ye + he] = L(Nt), ne[Ye + he + 1] = L(vt);
                                    }
                                }
                                z += 4 * Ee;
                              } else if (Y == 16388)
                                z += 4 * Ee;
                              else if (be != 8192 && be != 8448 && be != 9216)
                                throw Y.toString(16);
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
            console.log(Date.now() - D);
          };
        }(), a.decode._decodeLogLuv32 = function(I, _, R, W, O, j) {
          for (var U = I.width, C = 4 * U, ae = 0, J = new Uint8Array(C); ae < W; ) {
            for (var te = 0; te < C; ) {
              var $ = _[R + ae];
              if (ae++, $ < 128) {
                for (var L = 0; L < $; L++)
                  J[te + L] = _[R + ae + L];
                te += $, ae += $;
              } else {
                for ($ -= 126, L = 0; L < $; L++)
                  J[te + L] = _[R + ae];
                te += $, ae++;
              }
            }
            for (var re = 0; re < U; re++)
              O[j + 0] = J[re], O[j + 1] = J[re + U], O[j + 2] = J[re + 2 * U], O[j + 4] = J[re + 3 * U], j += 6;
          }
        }, a.decode._ljpeg_diff = function(I, _, R) {
          var W, O, j = a.decode._getbithuff;
          return W = j(I, _, R[0], R), !((O = j(I, _, W, 0)) & 1 << W - 1) && (O -= (1 << W) - 1), O;
        }, a.decode._decodeARW = function(I, _, R, W, O, j) {
          var U = I.t256[0], C = I.t257[0], ae = I.t258[0], J = I.isLE ? a._binLE : a._binBE;
          if (U * C == W || U * C * 1.5 == W)
            if (U * C * 1.5 != W) {
              var te, $, L, re, z, N, ne, le, he = new Uint16Array(16), k = new Uint8Array(U + 1);
              for (ee = 0; ee < C; ee++) {
                for (var T = 0; T < U; T++)
                  k[T] = _[R++];
                for (le = 0, D = 0; D < U - 30; le += 16) {
                  for ($ = 2047 & (te = J.readUint(k, le)), L = 2047 & te >>> 11, re = 15 & te >>> 22, z = 15 & te >>> 26, N = 0; N < 4 && 128 << N <= $ - L; N++)
                    ;
                  for (ne = 30, B = 0; B < 16; B++)
                    B == re ? he[B] = $ : B == z ? he[B] = L : (he[B] = ((J.readUshort(k, le + (ne >> 3)) >>> (7 & ne) & 127) << N) + L, he[B] > 2047 && (he[B] = 2047), ne += 7);
                  for (B = 0; B < 16; B++, D += 2)
                    ke = he[B] << 1, a.decode._putsF(O, (ee * U + D) * ae, ke << 16 - ae);
                  D -= 1 & D ? 1 : 31;
                }
              }
            } else
              for (var B = 0; B < W; B += 3) {
                var K = _[R + B + 0], h = _[R + B + 1], c = _[R + B + 2];
                O[j + B] = h << 4 | K >>> 4, O[j + B + 1] = K << 4 | c >>> 4, O[j + B + 2] = c << 4 | h >>> 4;
              }
          else {
            C += 8;
            var m, D, ee, E = [R, 0, 0, 0], Q = new Uint16Array(32770), se = [3857, 3856, 3599, 3342, 3085, 2828, 2571, 2314, 2057, 1800, 1543, 1286, 1029, 772, 771, 768, 514, 513], Y = 0, be = a.decode._ljpeg_diff;
            for (Q[0] = 15, m = B = 0; B < 18; B++)
              for (var Ee = 32768 >>> (se[B] >>> 8), Me = 0; Me < Ee; Me++)
                Q[++m] = se[B];
            for (D = U; D--; )
              for (ee = 0; ee < C + 1; ee += 2)
                if (ee == C && (ee = 1), Y += be(_, E, Q), ee < C) {
                  var ke = 4095 & Y;
                  a.decode._putsF(O, (ee * U + D) * ae, ke << 16 - ae);
                }
          }
        }, a.decode._decodeNikon = function(I, _, R, W, O, j, U) {
          var C = [[0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 4, 3, 6, 2, 7, 1, 0, 8, 9, 11, 10, 12], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 57, 90, 56, 39, 22, 5, 4, 3, 2, 1, 0, 11, 12, 12], [0, 0, 1, 4, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 5, 4, 6, 3, 7, 2, 8, 1, 9, 0, 10, 11, 12], [0, 0, 1, 4, 3, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 0, 5, 6, 4, 7, 8, 3, 9, 2, 1, 0, 10, 11, 12, 13, 14], [0, 0, 1, 5, 1, 1, 1, 1, 1, 1, 1, 2, 0, 0, 0, 0, 0, 8, 92, 75, 58, 41, 7, 6, 5, 4, 3, 2, 1, 0, 13, 14], [0, 0, 1, 4, 2, 2, 3, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 7, 6, 8, 5, 9, 4, 10, 3, 11, 12, 2, 0, 1, 13, 14]], ae = I.t256[0], J = I.t257[0], te = I.t258[0], $ = 0, L = 0, re = a.decode._make_decoder, z = a.decode._getbithuff, N = _[0].exifIFD.makerNote, ne = N.t150 ? N.t150 : N.t140, le = 0, he = ne[le++], k = ne[le++];
          he != 73 && k != 88 || (le += 2110), he == 70 && ($ = 2), te == 14 && ($ += 3);
          for (var T = [[0, 0], [0, 0]], B = I.isLE ? a._binLE : a._binBE, K = 0; K < 2; K++)
            for (var h = 0; h < 2; h++)
              T[K][h] = B.readShort(ne, le), le += 2;
          var c, m, D, ee, E, Q = 1 << te & 32767, se = 0, Y = B.readShort(ne, le);
          le += 2, Y > 1 && (se = Math.floor(Q / (Y - 1))), he == 68 && k == 32 && se > 0 && (L = B.readShort(ne, 562));
          var be = [0, 0], Ee = re(C[$]), Me = [W, 0, 0, 0];
          for (c = 0; c < J; c++)
            for (L && c == L && (Ee = re(C[$ + 1])), m = 0; m < ae; m++) {
              K = z(R, Me, Ee[0], Ee), !((E = 1 + (z(R, Me, (D = 15 & K) - (ee = K >>> 4), 0) << 1) << ee >>> 1) & 1 << D - 1) && (E -= (1 << D) - (ee == 0 ? 1 : 0)), m < 2 ? be[m] = T[1 & c][m] += E : be[1 & m] += E;
              var ke = Math.min(Math.max(be[1 & m], 0), (1 << te) - 1), oe = (c * ae + m) * te;
              a.decode._putsF(j, oe, ke << 16 - te);
            }
        }, a.decode._putsF = function(I, _, R) {
          R <<= 8 - (7 & _);
          var W = _ >>> 3;
          I[W] |= R >>> 16, I[W + 1] |= R >>> 8, I[W + 2] |= R;
        }, a.decode._getbithuff = function(I, _, R, W) {
          a.decode._get_byte;
          var O, j = _[0], U = _[1], C = _[2], ae = _[3];
          if (R == 0 || C < 0)
            return 0;
          for (; !ae && C < R && (O = I[j++]) != -1 && !(ae = 0); )
            U = (U << 8) + O, C += 8;
          if (O = U << 32 - C >>> 32 - R, W ? (C -= W[O + 1] >>> 8, O = 255 & W[O + 1]) : C -= R, C < 0)
            throw "e";
          return _[0] = j, _[1] = U, _[2] = C, _[3] = ae, O;
        }, a.decode._make_decoder = function(I) {
          var _, R, W, O, j, U = [];
          for (_ = 16; _ != 0 && !I[_]; _--)
            ;
          var C = 17;
          for (U[0] = _, W = R = 1; R <= _; R++)
            for (O = 0; O < I[R]; O++, ++C)
              for (j = 0; j < 1 << _ - R; j++)
                W <= 1 << _ && (U[W++] = R << 8 | I[C]);
          return U;
        }, a.decode._decodeNewJPEG = function(I, _, R, W, O, j) {
          W = Math.min(W, _.length - R);
          var U = I.t347, C = U ? U.length : 0, ae = new Uint8Array(C + W);
          if (U) {
            for (var J = 0, te = 0; te < C - 1 && (U[te] != 255 || U[te + 1] != 217); te++)
              ae[J++] = U[te];
            var $ = _[R], L = _[R + 1];
            for ($ == 255 && L == 216 || (ae[J++] = $, ae[J++] = L), te = 2; te < W; te++)
              ae[J++] = _[R + te];
          } else
            for (te = 0; te < W; te++)
              ae[te] = _[R + te];
          if (I.t262[0] == 32803 || I.t259[0] == 7 && I.t262[0] == 34892) {
            var re = I.t258[0], z = a.LosslessJpegDecode(ae), N = z.length;
            if (re == 16)
              if (I.isLE)
                for (te = 0; te < N; te++)
                  O[j + (te << 1)] = 255 & z[te], O[j + (te << 1) + 1] = z[te] >>> 8;
              else
                for (te = 0; te < N; te++)
                  O[j + (te << 1)] = z[te] >>> 8, O[j + (te << 1) + 1] = 255 & z[te];
            else if (re == 14 || re == 12) {
              var ne = 16 - re;
              for (te = 0; te < N; te++)
                a.decode._putsF(O, te * re, z[te] << ne);
            } else {
              if (re != 8)
                throw new Error("unsupported bit depth " + re);
              for (te = 0; te < N; te++)
                O[j + te] = z[te];
            }
          } else {
            var le = new a.JpegDecoder();
            le.parse(ae);
            var he = le.getData({ width: le.width, height: le.height, forceRGB: !0, isSourcePDF: !1 });
            for (te = 0; te < he.length; te++)
              O[j + te] = he[te];
          }
          I.t262[0] == 6 && (I.t262[0] = 2);
        }, a.decode._decodeOldJPEGInit = function(I, _, R, W) {
          var O, j, U, C, ae, J = 216, te = 0, $ = 0, L = !1, re = I.t513, z = re ? re[0] : 0, N = I.t514, ne = N ? N[0] : 0, le = I.t324 || I.t273 || re, he = I.t530, k = 0, T = 0, B = I.t277 ? I.t277[0] : 1, K = I.t515;
          if (le && ($ = le[0], L = le.length > 1), !L) {
            if (_[R] == 255 && _[R + 1] == J)
              return { jpegOffset: R };
            if (re != null && (_[R + z] == 255 && _[R + z + 1] == J ? te = R + z : i("JPEGInterchangeFormat does not point to SOI"), N == null ? i("JPEGInterchangeFormatLength field is missing") : (z >= $ || z + ne <= $) && i("JPEGInterchangeFormatLength field value is invalid"), te != null))
              return { jpegOffset: te };
          }
          if (he != null && (k = he[0], T = he[1]), re != null && N != null)
            if (ne >= 2 && z + ne <= $) {
              for (O = _[R + z + ne - 2] == 255 && _[R + z + ne - 1] == J ? new Uint8Array(ne - 2) : new Uint8Array(ne), U = 0; U < O.length; U++)
                O[U] = _[R + z + U];
              i("Incorrect JPEG interchange format: using JPEGInterchangeFormat offset to derive tables");
            } else
              i("JPEGInterchangeFormat+JPEGInterchangeFormatLength > offset to first strip or tile");
          if (O == null) {
            var h = 0, c = [];
            c[h++] = 255, c[h++] = J;
            var m = I.t519;
            if (m == null)
              throw new Error("JPEGQTables tag is missing");
            for (U = 0; U < m.length; U++)
              for (c[h++] = 255, c[h++] = 219, c[h++] = 0, c[h++] = 67, c[h++] = U, C = 0; C < 64; C++)
                c[h++] = _[R + m[U] + C];
            for (ae = 0; ae < 2; ae++) {
              var D = I[ae == 0 ? "t520" : "t521"];
              if (D == null)
                throw new Error((ae == 0 ? "JPEGDCTables" : "JPEGACTables") + " tag is missing");
              for (U = 0; U < D.length; U++) {
                c[h++] = 255, c[h++] = 196;
                var ee = 19;
                for (C = 0; C < 16; C++)
                  ee += _[R + D[U] + C];
                for (c[h++] = ee >>> 8, c[h++] = 255 & ee, c[h++] = U | ae << 4, C = 0; C < 16; C++)
                  c[h++] = _[R + D[U] + C];
                for (C = 0; C < ee; C++)
                  c[h++] = _[R + D[U] + 16 + C];
              }
            }
            if (c[h++] = 255, c[h++] = 192, c[h++] = 0, c[h++] = 8 + 3 * B, c[h++] = 8, c[h++] = I.height >>> 8 & 255, c[h++] = 255 & I.height, c[h++] = I.width >>> 8 & 255, c[h++] = 255 & I.width, c[h++] = B, B == 1)
              c[h++] = 1, c[h++] = 17, c[h++] = 0;
            else
              for (U = 0; U < 3; U++)
                c[h++] = U + 1, c[h++] = U != 0 ? 17 : (15 & k) << 4 | 15 & T, c[h++] = U;
            K != null && K[0] != 0 && (c[h++] = 255, c[h++] = 221, c[h++] = 0, c[h++] = 4, c[h++] = K[0] >>> 8 & 255, c[h++] = 255 & K[0]), O = new Uint8Array(c);
          }
          var E = -1;
          for (U = 0; U < O.length - 1; ) {
            if (O[U] == 255 && O[U + 1] == 192) {
              E = U;
              break;
            }
            U++;
          }
          if (E == -1) {
            var Q = new Uint8Array(O.length + 10 + 3 * B);
            Q.set(O);
            var se = O.length;
            if (E = O.length, (O = Q)[se++] = 255, O[se++] = 192, O[se++] = 0, O[se++] = 8 + 3 * B, O[se++] = 8, O[se++] = I.height >>> 8 & 255, O[se++] = 255 & I.height, O[se++] = I.width >>> 8 & 255, O[se++] = 255 & I.width, O[se++] = B, B == 1)
              O[se++] = 1, O[se++] = 17, O[se++] = 0;
            else
              for (U = 0; U < 3; U++)
                O[se++] = U + 1, O[se++] = U != 0 ? 17 : (15 & k) << 4 | 15 & T, O[se++] = U;
          }
          if (_[$] == 255 && _[$ + 1] == 218) {
            var Y = _[$ + 2] << 8 | _[$ + 3];
            for ((j = new Uint8Array(Y + 2))[0] = _[$], j[1] = _[$ + 1], j[2] = _[$ + 2], j[3] = _[$ + 3], U = 0; U < Y - 2; U++)
              j[U + 4] = _[$ + U + 4];
          } else {
            var be = 0;
            if ((j = new Uint8Array(8 + 2 * B))[be++] = 255, j[be++] = 218, j[be++] = 0, j[be++] = 6 + 2 * B, j[be++] = B, B == 1)
              j[be++] = 1, j[be++] = 0;
            else
              for (U = 0; U < 3; U++)
                j[be++] = U + 1, j[be++] = U << 4 | U;
            j[be++] = 0, j[be++] = 63, j[be++] = 0;
          }
          return { jpegOffset: R, tables: O, sosMarker: j, sofPosition: E };
        }, a.decode._decodeOldJPEG = function(I, _, R, W, O, j) {
          var U, C, ae, J, te = a.decode._decodeOldJPEGInit(I, _, R, W);
          if (te.jpegOffset != null)
            for (U = R + W - te.jpegOffset, ae = new Uint8Array(U), re = 0; re < U; re++)
              ae[re] = _[te.jpegOffset + re];
          else {
            for (C = te.tables.length, (ae = new Uint8Array(C + te.sosMarker.length + W + 2)).set(te.tables), J = C, ae[te.sofPosition + 5] = I.height >>> 8 & 255, ae[te.sofPosition + 6] = 255 & I.height, ae[te.sofPosition + 7] = I.width >>> 8 & 255, ae[te.sofPosition + 8] = 255 & I.width, _[R] == 255 && _[R + 1] == SOS || (ae.set(te.sosMarker, J), J += sosMarker.length), re = 0; re < W; re++)
              ae[J++] = _[R + re];
            ae[J++] = 255, ae[J++] = EOI;
          }
          var $ = new a.JpegDecoder();
          $.parse(ae);
          for (var L = $.getData({ width: $.width, height: $.height, forceRGB: !0, isSourcePDF: !1 }), re = 0; re < L.length; re++)
            O[j + re] = L[re];
          I.t262 && I.t262[0] == 6 && (I.t262[0] = 2);
        }, a.decode._decodePackBits = function(I, _, R, W, O) {
          for (var j = new Int8Array(I.buffer), U = new Int8Array(W.buffer), C = _ + R; _ < C; ) {
            var ae = j[_];
            if (_++, ae >= 0 && ae < 128)
              for (var J = 0; J < ae + 1; J++)
                U[O] = j[_], O++, _++;
            if (ae >= -127 && ae < 0) {
              for (J = 0; J < 1 - ae; J++)
                U[O] = j[_], O++;
              _++;
            }
          }
          return O;
        }, a.decode._decodeThunder = function(I, _, R, W, O) {
          for (var j = [0, 1, 0, -1], U = [0, 1, 2, 3, 0, -3, -2, -1], C = _ + R, ae = 2 * O, J = 0; _ < C; ) {
            var te = I[_], $ = te >>> 6, L = 63 & te;
            if (_++, $ == 3 && (J = 15 & L, W[ae >>> 1] |= J << 4 * (1 - ae & 1), ae++), $ == 0)
              for (var re = 0; re < L; re++)
                W[ae >>> 1] |= J << 4 * (1 - ae & 1), ae++;
            if ($ == 2)
              for (re = 0; re < 2; re++)
                (z = L >>> 3 * (1 - re) & 7) != 4 && (J += U[z], W[ae >>> 1] |= J << 4 * (1 - ae & 1), ae++);
            if ($ == 1)
              for (re = 0; re < 3; re++) {
                var z;
                (z = L >>> 2 * (2 - re) & 3) != 2 && (J += j[z], W[ae >>> 1] |= J << 4 * (1 - ae & 1), ae++);
              }
          }
        }, a.decode._dmap = { 1: 0, "011": 1, "000011": 2, "0000011": 3, "010": -1, "000010": -2, "0000010": -3 }, a.decode._lens = function() {
          var I = function(ae, J, te, $) {
            for (var L = 0; L < J.length; L++)
              ae[J[L]] = te + L * $;
          }, _ = "00110101,000111,0111,1000,1011,1100,1110,1111,10011,10100,00111,01000,001000,000011,110100,110101,101010,101011,0100111,0001100,0001000,0010111,0000011,0000100,0101000,0101011,0010011,0100100,0011000,00000010,00000011,00011010,00011011,00010010,00010011,00010100,00010101,00010110,00010111,00101000,00101001,00101010,00101011,00101100,00101101,00000100,00000101,00001010,00001011,01010010,01010011,01010100,01010101,00100100,00100101,01011000,01011001,01011010,01011011,01001010,01001011,00110010,00110011,00110100", R = "0000110111,010,11,10,011,0011,0010,00011,000101,000100,0000100,0000101,0000111,00000100,00000111,000011000,0000010111,0000011000,0000001000,00001100111,00001101000,00001101100,00000110111,00000101000,00000010111,00000011000,000011001010,000011001011,000011001100,000011001101,000001101000,000001101001,000001101010,000001101011,000011010010,000011010011,000011010100,000011010101,000011010110,000011010111,000001101100,000001101101,000011011010,000011011011,000001010100,000001010101,000001010110,000001010111,000001100100,000001100101,000001010010,000001010011,000000100100,000000110111,000000111000,000000100111,000000101000,000001011000,000001011001,000000101011,000000101100,000001011010,000001100110,000001100111", W = "11011,10010,010111,0110111,00110110,00110111,01100100,01100101,01101000,01100111,011001100,011001101,011010010,011010011,011010100,011010101,011010110,011010111,011011000,011011001,011011010,011011011,010011000,010011001,010011010,011000,010011011", O = "0000001111,000011001000,000011001001,000001011011,000000110011,000000110100,000000110101,0000001101100,0000001101101,0000001001010,0000001001011,0000001001100,0000001001101,0000001110010,0000001110011,0000001110100,0000001110101,0000001110110,0000001110111,0000001010010,0000001010011,0000001010100,0000001010101,0000001011010,0000001011011,0000001100100,0000001100101", j = "00000001000,00000001100,00000001101,000000010010,000000010011,000000010100,000000010101,000000010110,000000010111,000000011100,000000011101,000000011110,000000011111";
          _ = _.split(","), R = R.split(","), W = W.split(","), O = O.split(","), j = j.split(",");
          var U = {}, C = {};
          return I(U, _, 0, 1), I(U, W, 64, 64), I(U, j, 1792, 64), I(C, R, 0, 1), I(C, O, 64, 64), I(C, j, 1792, 64), [U, C];
        }(), a.decode._decodeG4 = function(I, _, R, W, O, j, U) {
          for (var C = a.decode, ae = _ << 3, J = 0, te = "", $ = [], L = [], re = 0; re < j; re++)
            L.push(0);
          L = C._makeDiff(L);
          for (var z = 0, N = 0, ne = 0, le = 0, he = 0, k = 0, T = "", B = 0, K = 8 * Math.ceil(j / 8); ae >>> 3 < _ + R; ) {
            ne = C._findDiff(L, z + (z == 0 ? 0 : 1), 1 - he), le = C._findDiff(L, ne, he);
            var h = 0;
            if (U == 1 && (h = I[ae >>> 3] >>> 7 - (7 & ae) & 1), U == 2 && (h = I[ae >>> 3] >>> (7 & ae) & 1), ae++, te += h, T == "H") {
              if (C._lens[he][te] != null) {
                var c = C._lens[he][te];
                te = "", J += c, c < 64 && (C._addNtimes($, J, he), z += J, he = 1 - he, J = 0, --B == 0 && (T = ""));
              }
            } else
              te == "0001" && (te = "", C._addNtimes($, le - z, he), z = le), te == "001" && (te = "", T = "H", B = 2), C._dmap[te] != null && (N = ne + C._dmap[te], C._addNtimes($, N - z, he), z = N, te = "", he = 1 - he);
            $.length == j && T == "" && (C._writeBits($, W, 8 * O + k * K), he = 0, k++, z = 0, L = C._makeDiff($), $ = []);
          }
        }, a.decode._findDiff = function(I, _, R) {
          for (var W = 0; W < I.length; W += 2)
            if (I[W] >= _ && I[W + 1] == R)
              return I[W];
        }, a.decode._makeDiff = function(I) {
          var _ = [];
          I[0] == 1 && _.push(0, 1);
          for (var R = 1; R < I.length; R++)
            I[R - 1] != I[R] && _.push(R, I[R]);
          return _.push(I.length, 0, I.length, 1), _;
        }, a.decode._decodeG2 = function(I, _, R, W, O, j, U) {
          for (var C = a.decode, ae = _ << 3, J = 0, te = "", $ = [], L = 0, re = 0, z = 8 * Math.ceil(j / 8); ae >>> 3 < _ + R; ) {
            var N = 0;
            U == 1 && (N = I[ae >>> 3] >>> 7 - (7 & ae) & 1), U == 2 && (N = I[ae >>> 3] >>> (7 & ae) & 1), ae++, te += N, (J = C._lens[L][te]) != null && (C._addNtimes($, J, L), te = "", J < 64 && (L = 1 - L), $.length == j && (C._writeBits($, W, 8 * O + re * z), $ = [], re++, L = 0, 7 & ae && (ae += 8 - (7 & ae)), J >= 64 && (ae += 8)));
          }
        }, a.decode._decodeG3 = function(I, _, R, W, O, j, U, C) {
          for (var ae = a.decode, J = _ << 3, te = 0, $ = "", L = [], re = [], z = 0; z < j; z++)
            L.push(0);
          for (var N = 0, ne = 0, le = 0, he = 0, k = 0, T = -1, B = "", K = 0, h = !0, c = 8 * Math.ceil(j / 8); J >>> 3 < _ + R; ) {
            le = ae._findDiff(re, N + (N == 0 ? 0 : 1), 1 - k), he = ae._findDiff(re, le, k);
            var m = 0;
            if (U == 1 && (m = I[J >>> 3] >>> 7 - (7 & J) & 1), U == 2 && (m = I[J >>> 3] >>> (7 & J) & 1), J++, $ += m, h) {
              if (ae._lens[k][$] != null) {
                var D = ae._lens[k][$];
                $ = "", te += D, D < 64 && (ae._addNtimes(L, te, k), k = 1 - k, te = 0);
              }
            } else
              B == "H" ? ae._lens[k][$] != null && (D = ae._lens[k][$], $ = "", te += D, D < 64 && (ae._addNtimes(L, te, k), N += te, k = 1 - k, te = 0, --K == 0 && (B = ""))) : ($ == "0001" && ($ = "", ae._addNtimes(L, he - N, k), N = he), $ == "001" && ($ = "", B = "H", K = 2), ae._dmap[$] != null && (ne = le + ae._dmap[$], ae._addNtimes(L, ne - N, k), N = ne, $ = "", k = 1 - k));
            $.endsWith("000000000001") && (T >= 0 && ae._writeBits(L, W, 8 * O + T * c), C && (U == 1 && (h = (I[J >>> 3] >>> 7 - (7 & J) & 1) == 1), U == 2 && (h = (I[J >>> 3] >>> (7 & J) & 1) == 1), J++), $ = "", k = 0, T++, N = 0, re = ae._makeDiff(L), L = []);
          }
          L.length == j && ae._writeBits(L, W, 8 * O + T * c);
        }, a.decode._addNtimes = function(I, _, R) {
          for (var W = 0; W < _; W++)
            I.push(R);
        }, a.decode._writeBits = function(I, _, R) {
          for (var W = 0; W < I.length; W++)
            _[R + W >>> 3] |= I[W] << 7 - (R + W & 7);
        }, a.decode._decodeLZW = a.decode._decodeLZW = (p = 0, g = 0, v = 0, x = 0, b = function() {
          var I = r >>> 3, _ = (o[I] << 16 | o[I + 1] << 8 | o[I + 2]) >>> 24 - (7 & r) - g & (1 << g) - 1;
          return r += g, _;
        }, w = new Uint32Array(16384), M = 0, G = function(I) {
          g = I + 1, p = x + 1;
        }, F = function(I) {
          for (var _ = I << 2, R = w[_ + 2], W = u + R - 1; _ != 65535; )
            n[W--] = w[_], _ = w[_ + 1];
          u += R;
        }, V = function(I, _) {
          var R = p << 2, W = I << 2;
          w[R] = w[3 + (_ << 2)], w[R + 1] = W, w[R + 2] = w[W + 2] + 1, w[R + 3] = w[W + 3], 1 + ++p == 1 << g && g != 12 && g++;
        }, function(I, _, R, W, O, j) {
          r = _ << 3, o = I, n = W, u = O;
          var U = _ + R << 3, C = 0, ae = 0;
          for (function(J) {
            if (J != M) {
              M = J, x = 1 + (v = 1 << J);
              for (var te = 0; te < x + 1; te++)
                w[4 * te] = w[4 * te + 3] = te, w[4 * te + 1] = 65535, w[4 * te + 2] = 1;
            }
          }(j), G(j); r < U && (C = b()) != x; ) {
            if (C == v) {
              if (G(j), (C = b()) == x)
                break;
              F(C);
            } else
              C < p ? (F(C), V(ae, C)) : (V(ae, ae), F(p - 1));
            ae = C;
          }
          return u;
        }), a.tags = {}, a._types = ((q = new Array(250)).fill(0), { basic: { main: q = q.concat([0, 0, 0, 0, 4, 3, 3, 3, 3, 3, 0, 0, 3, 0, 0, 0, 3, 0, 0, 2, 2, 2, 2, 4, 3, 0, 0, 3, 4, 4, 3, 3, 5, 5, 3, 2, 5, 5, 0, 0, 0, 0, 4, 4, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 3, 5, 5, 3, 0, 3, 3, 4, 4, 4, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 3, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]), rest: { 33432: 2, 33434: 5, 33437: 5, 34665: 4, 34850: 3, 34853: 4, 34855: 3, 34864: 3, 34866: 4, 36864: 7, 36867: 2, 36868: 2, 37121: 7, 37377: 10, 37378: 5, 37380: 10, 37381: 5, 37383: 3, 37384: 3, 37385: 3, 37386: 5, 37510: 7, 37520: 2, 37521: 2, 37522: 2, 40960: 7, 40961: 3, 40962: 4, 40963: 4, 40965: 4, 41486: 5, 41487: 5, 41488: 3, 41985: 3, 41986: 3, 41987: 3, 41988: 5, 41989: 3, 41990: 3, 41993: 3, 41994: 3, 41995: 7, 41996: 3, 42032: 2, 42033: 2, 42034: 5, 42036: 2, 42037: 2, 59932: 7 } }, gps: { main: [1, 2, 5, 2, 5, 1, 5, 5, 0, 9], rest: { 18: 2, 29: 2 } } }), a._readIFD = function(I, _, R, W, O, j) {
          var U = I.readUshort(_, R);
          R += 2;
          var C = {};
          j.debug && i("   ".repeat(O), W.length - 1, ">>>----------------");
          for (var ae = 0; ae < U; ae++) {
            var J = I.readUshort(_, R);
            R += 2;
            var te = I.readUshort(_, R);
            R += 2;
            var $ = I.readUint(_, R);
            R += 4;
            var L = I.readUint(_, R);
            R += 4;
            var re = [];
            if (te != 1 && te != 7 || (re = new Uint8Array(_.buffer, $ < 5 ? R - 4 : L, $)), te == 2) {
              var z = $ < 5 ? R - 4 : L, N = _[z], ne = Math.max(0, Math.min($ - 1, _.length - z));
              N < 128 || ne == 0 ? re.push(I.readASCII(_, z, ne)) : re = new Uint8Array(_.buffer, z, ne);
            }
            if (te == 3)
              for (var le = 0; le < $; le++)
                re.push(I.readUshort(_, ($ < 3 ? R - 4 : L) + 2 * le));
            if (te == 4 || te == 13)
              for (le = 0; le < $; le++)
                re.push(I.readUint(_, ($ < 2 ? R - 4 : L) + 4 * le));
            if (te == 5 || te == 10) {
              var he = te == 5 ? I.readUint : I.readInt;
              for (le = 0; le < $; le++)
                re.push([he(_, L + 8 * le), he(_, L + 8 * le + 4)]);
            }
            if (te == 8)
              for (le = 0; le < $; le++)
                re.push(I.readShort(_, ($ < 3 ? R - 4 : L) + 2 * le));
            if (te == 9)
              for (le = 0; le < $; le++)
                re.push(I.readInt(_, ($ < 2 ? R - 4 : L) + 4 * le));
            if (te == 11)
              for (le = 0; le < $; le++)
                re.push(I.readFloat(_, L + 4 * le));
            if (te == 12)
              for (le = 0; le < $; le++)
                re.push(I.readDouble(_, L + 8 * le));
            if ($ == 0 || re.length != 0) {
              if (j.debug && i("   ".repeat(O), J, te, a.tags[J], re), C["t" + J] = re, !(J == 330 && C.t272 && C.t272[0] == "DSLR-A100")) {
                if (J == 330 || J == 34665 || J == 34853 || J == 50740 && I.readUshort(_, I.readUint(re, 0)) < 300 || J == 61440) {
                  var k = J == 50740 ? [I.readUint(re, 0)] : re, T = [];
                  for (le = 0; le < k.length; le++)
                    a._readIFD(I, _, k[le], T, O + 1, j);
                  J == 330 && (C.subIFD = T), J == 34665 && (C.exifIFD = T[0]), J == 34853 && (C.gpsiIFD = T[0]), J == 50740 && (C.dngPrvt = T[0]), J == 61440 && (C.fujiIFD = T[0]);
                }
              }
              if (J == 37500 && j.parseMN) {
                var B = re;
                if (I.readASCII(B, 0, 5) == "Nikon")
                  C.makerNote = a.decode(B.slice(10).buffer)[0];
                else if (I.readUshort(_, L) < 300 && I.readUshort(_, L + 4) <= 12) {
                  var K = [];
                  a._readIFD(I, _, L, K, O + 1, j), C.makerNote = K[0];
                }
              }
            } else if (i(J, "unknown TIFF tag type: ", te, "num:", $), ae == 0)
              return;
          }
          return W.push(C), j.debug && i("   ".repeat(O), "<<<---------------"), R;
        }, a._writeIFD = function(I, _, R, W, O) {
          var j = Object.keys(O), U = j.length;
          O.exifIFD && U--, O.gpsiIFD && U--, I.writeUshort(R, W, U);
          for (var C = (W += 2) + 12 * U + 4, ae = 0; ae < j.length; ae++) {
            var J = j[ae];
            if (J != "t34665" && J != "t34853") {
              J == "exifIFD" && (J = "t34665"), J == "gpsiIFD" && (J = "t34853");
              var te = parseInt(J.slice(1)), $ = _.main[te];
              if ($ == null && ($ = _.rest[te]), $ == null || $ == 0)
                throw new Error("unknown type of tag: " + te);
              var L = O[J];
              te == 34665 && (L = [C], C = a._writeIFD(I, _, R, C, O.exifIFD)[1]), te == 34853 && (L = [C], C = a._writeIFD(I, a._types.gps, R, C, O.gpsiIFD)[1]), $ == 2 && (L = L[0] + "\0");
              var re = L.length;
              I.writeUshort(R, W, te), W += 2, I.writeUshort(R, W, $), W += 2, I.writeUint(R, W, re);
              var z = [-1, 1, 1, 2, 4, 8, 0, 1, 0, 4, 8, 0, 8][$] * re, N = W += 4;
              if (z > 4 && (I.writeUint(R, W, C), N = C), $ == 1 || $ == 7)
                for (var ne = 0; ne < re; ne++)
                  R[N + ne] = L[ne];
              else if ($ == 2)
                I.writeASCII(R, N, L);
              else if ($ == 3)
                for (ne = 0; ne < re; ne++)
                  I.writeUshort(R, N + 2 * ne, L[ne]);
              else if ($ == 4)
                for (ne = 0; ne < re; ne++)
                  I.writeUint(R, N + 4 * ne, L[ne]);
              else if ($ == 5 || $ == 10) {
                var le = $ == 5 ? I.writeUint : I.writeInt;
                for (ne = 0; ne < re; ne++) {
                  var he = L[ne], k = he[0], T = he[1];
                  if (k == null)
                    throw "e";
                  le(R, N + 8 * ne, k), le(R, N + 8 * ne + 4, T);
                }
              } else if ($ == 9)
                for (ne = 0; ne < re; ne++)
                  I.writeInt(R, N + 4 * ne, L[ne]);
              else {
                if ($ != 12)
                  throw $;
                for (ne = 0; ne < re; ne++)
                  I.writeDouble(R, N + 8 * ne, L[ne]);
              }
              z > 4 && (C += z += 1 & z), W += 4;
            }
          }
          return [W, C];
        }, a.toRGBA8 = function(I, _) {
          var R = I.width, W = I.height, O = R * W, j = 4 * O, U = I.data, C = new Uint8Array(4 * O), ae = I.t262 ? I.t262[0] : 2, J = I.t258 ? Math.min(32, I.t258[0]) : 1;
          if (I.t262 == null && J == 1 && (ae = 0), ae == 0)
            for (var te = Math.ceil(J * R / 8), $ = 0; $ < W; $++) {
              var L = $ * te, re = $ * R;
              if (J == 1)
                for (var z = 0; z < R; z++) {
                  var N = re + z << 2, ne = U[L + (z >> 3)] >> 7 - (7 & z) & 1;
                  C[N] = C[N + 1] = C[N + 2] = 255 * (1 - ne), C[N + 3] = 255;
                }
              if (J == 4)
                for (z = 0; z < R; z++)
                  N = re + z << 2, ne = U[L + (z >> 1)] >> 4 - 4 * (1 & z) & 15, C[N] = C[N + 1] = C[N + 2] = 17 * (15 - ne), C[N + 3] = 255;
              if (J == 8)
                for (z = 0; z < R; z++)
                  N = re + z << 2, ne = U[L + z], C[N] = C[N + 1] = C[N + 2] = 255 - ne, C[N + 3] = 255;
            }
          else if (ae == 1) {
            var le = I.t258 ? I.t258.length : 1;
            for (te = Math.ceil(le * J * R / 8), _ == null && (_ = 390625e-8), $ = 0; $ < W; $++) {
              if (L = $ * te, re = $ * R, J == 1)
                for (z = 0; z < R; z++)
                  N = re + z << 2, ne = U[L + (z >> 3)] >> 7 - (7 & z) & 1, C[N] = C[N + 1] = C[N + 2] = 255 * ne, C[N + 3] = 255;
              if (J == 2)
                for (z = 0; z < R; z++)
                  N = re + z << 2, ne = U[L + (z >> 2)] >> 6 - 2 * (3 & z) & 3, C[N] = C[N + 1] = C[N + 2] = 85 * ne, C[N + 3] = 255;
              if (J == 8)
                for (z = 0; z < R; z++)
                  N = re + z << 2, ne = U[L + z * le], C[N] = C[N + 1] = C[N + 2] = ne, C[N + 3] = 255;
              if (J == 16)
                for (z = 0; z < R; z++) {
                  N = re + z << 2;
                  var he = L + 2 * z;
                  ne = U[he + 1] << 8 | U[he], C[N] = C[N + 1] = C[N + 2] = Math.min(255, ~~(ne * _)), C[N + 3] = 255;
                }
            }
          } else if (ae == 2)
            if (le = I.t258 ? I.t258.length : 3, J == 8) {
              if (le == 4)
                for (z = 0; z < j; z++)
                  C[z] = U[z];
              if (le == 3)
                for (z = 0; z < O; z++) {
                  var k = 3 * z;
                  C[N = z << 2] = U[k], C[N + 1] = U[k + 1], C[N + 2] = U[k + 2], C[N + 3] = 255;
                }
            } else if (J == 16) {
              if (le == 4)
                for (z = 0; z < O; z++)
                  k = 8 * z + 1, C[N = z << 2] = U[k], C[N + 1] = U[k + 2], C[N + 2] = U[k + 4], C[N + 3] = U[k + 6];
              if (le == 3)
                for (z = 0; z < O; z++)
                  k = 6 * z + 1, C[N = z << 2] = U[k], C[N + 1] = U[k + 2], C[N + 2] = U[k + 4], C[N + 3] = 255;
            } else {
              if (J != 32)
                throw J;
              if (!C.isLE)
                for (z = 0; z < U.length; z += 4) {
                  var T = U[z];
                  U[z] = U[z + 3], U[z + 3] = T, T = U[z + 1], U[z + 1] = U[z + 2], U[z + 2] = T;
                }
              var B = new Float32Array(U.buffer);
              if (le != 3)
                throw le;
              for (z = 0; z < O; z++)
                k = 3 * z, C[N = z << 2] = ~~(0.5 + 255 * B[k]), C[N + 1] = ~~(0.5 + 255 * B[k + 1]), C[N + 2] = ~~(0.5 + 255 * B[k + 2]), C[N + 3] = 255;
            }
          else if (ae == 3) {
            var K = I.t320, h = (le = I.t258 ? I.t258.length : 1, te = Math.ceil(le * J * R / 8), 1 << J);
            for ($ = 0; $ < W; $++)
              for (var c = 0; c < R; c++) {
                N = (z = $ * R + c) << 2;
                var m = 0, D = $ * te;
                if (J == 1)
                  m = U[D + (c >>> 3)] >>> 7 - (7 & c) & 1;
                else if (J == 2)
                  m = U[D + (c >>> 2)] >>> 6 - 2 * (3 & c) & 3;
                else if (J == 4)
                  m = U[D + (c >>> 1)] >>> 4 - 4 * (1 & c) & 15;
                else {
                  if (J != 8)
                    throw J;
                  m = U[D + c * le];
                }
                C[N] = K[m] >> 8, C[N + 1] = K[h + m] >> 8, C[N + 2] = K[h + h + m] >> 8, C[N + 3] = 255;
              }
          } else if (ae == 5) {
            var ee = (le = I.t258 ? I.t258.length : 4) > 4 ? 1 : 0;
            for (z = 0; z < O; z++) {
              N = z << 2;
              var E = z * le;
              if (UDOC) {
                var Q = U[E], se = U[E + 1], Y = U[E + 2], be = U[E + 3], Ee = UDOC.C.cmykToRgb([Q * (1 / 255), se * (1 / 255), Y * (1 / 255), be * (1 / 255)]);
                C[N] = ~~(0.5 + 255 * Ee[0]), C[N + 1] = ~~(0.5 + 255 * Ee[1]), C[N + 2] = ~~(0.5 + 255 * Ee[2]);
              } else
                Q = 255 - U[E], se = 255 - U[E + 1], Y = 255 - U[E + 2], be = (255 - U[E + 3]) * 0.00392156862745098, C[N] = ~~(Q * be + 0.5), C[N + 1] = ~~(se * be + 0.5), C[N + 2] = ~~(Y * be + 0.5);
              C[N + 3] = 255 * (1 - ee) + U[E + 4] * ee;
            }
          } else if (ae == 6 && I.t278) {
            var Me = I.t278[0];
            for ($ = 0; $ < W; $ += Me) {
              z = $ * R;
              for (var ke = Me * R, oe = 0; oe < ke; oe++) {
                N = 4 * (z + oe), Y = U[(E = 3 * z + 4 * (oe >>> 1)) + (1 & oe)];
                var ce = U[E + 2] - 128, xe = U[E + 3] - 128, Ce = Y + ((xe >> 2) + (xe >> 3) + (xe >> 5)), _e = Y - ((ce >> 2) + (ce >> 4) + (ce >> 5)) - ((xe >> 1) + (xe >> 3) + (xe >> 4) + (xe >> 5)), Be = Y + (ce + (ce >> 1) + (ce >> 2) + (ce >> 6));
                C[N] = Math.max(0, Math.min(255, Ce)), C[N + 1] = Math.max(0, Math.min(255, _e)), C[N + 2] = Math.max(0, Math.min(255, Be)), C[N + 3] = 255;
              }
            }
          } else if (ae == 32845) {
            let X = function(de) {
              return de < 31308e-7 ? 12.92 * de : 1.055 * Math.pow(de, 0.4166666666666667) - 0.055;
            };
            for ($ = 0; $ < W; $++)
              for (c = 0; c < R; c++) {
                N = 4 * ($ * R + c);
                var Pe = U[1 + (E = 6 * ($ * R + c))] << 8 | U[E], Fe = (Pe = Math.pow(2, (Pe + 0.5) / 256 - 64), (U[E + 3] + 0.5) / 410), We = (U[E + 5] + 0.5) / 410, Qe = 9 * Fe / (6 * Fe - 16 * We + 12), lt = 4 * We / (6 * Fe - 16 * We + 12), P = Qe * Pe / lt, we = (1 - Qe - lt) * Pe / lt;
                Ce = 2.69 * P - 1.276 * (Y = Pe) - 0.414 * we, _e = -1.022 * P + 1.978 * Y + 0.044 * we, Be = 0.061 * P - 0.224 * Y + 1.163 * we, C[N] = 255 * X(Math.min(Ce, 1)), C[N + 1] = 255 * X(Math.min(_e, 1)), C[N + 2] = 255 * X(Math.min(Be, 1)), C[N + 3] = 255;
              }
          } else
            i("Unknown Photometric interpretation: " + ae);
          return C;
        }, a.replaceIMG = function(I) {
          I == null && (I = document.getElementsByTagName("img"));
          for (var _ = ["tif", "tiff", "dng", "cr2", "nef"], R = 0; R < I.length; R++) {
            var W = I[R], O = W.getAttribute("src");
            if (O != null) {
              var j = O.split(".").pop().toLowerCase();
              if (_.indexOf(j) != -1) {
                var U = new XMLHttpRequest();
                a._xhrs.push(U), a._imgs.push(W), U.open("GET", O), U.responseType = "arraybuffer", U.onload = a._imgLoaded, U.send();
              }
            }
          }
        }, a._xhrs = [], a._imgs = [], a._imgLoaded = function(I) {
          var _ = a._xhrs.indexOf(I.target), R = a._imgs[_];
          a._xhrs.splice(_, 1), a._imgs.splice(_, 1), R.setAttribute("src", a.bufferToURI(I.target.response));
        }, a.bufferToURI = function(I) {
          var _ = a.decode(I), R = _, W = 0, O = R[0];
          _[0].subIFD && (R = R.concat(_[0].subIFD));
          for (var j = 0; j < R.length; j++) {
            var U = R[j];
            if (!(U.t258 == null || U.t258.length < 3)) {
              var C = U.t256 * U.t257;
              C > W && (W = C, O = U);
            }
          }
          a.decodeImage(I, O, _);
          var ae = a.toRGBA8(O), J = O.width, te = O.height, $ = document.createElement("canvas");
          $.width = J, $.height = te;
          var L = $.getContext("2d"), re = new ImageData(new Uint8ClampedArray(ae.buffer), J, te);
          return L.putImageData(re, 0, 0), $.toDataURL();
        }, a._binBE = { nextZero: function(I, _) {
          for (; I[_] != 0; )
            _++;
          return _;
        }, readUshort: function(I, _) {
          return I[_] << 8 | I[_ + 1];
        }, readShort: function(I, _) {
          var R = a._binBE.ui8;
          return R[0] = I[_ + 1], R[1] = I[_ + 0], a._binBE.i16[0];
        }, readInt: function(I, _) {
          var R = a._binBE.ui8;
          return R[0] = I[_ + 3], R[1] = I[_ + 2], R[2] = I[_ + 1], R[3] = I[_ + 0], a._binBE.i32[0];
        }, readUint: function(I, _) {
          var R = a._binBE.ui8;
          return R[0] = I[_ + 3], R[1] = I[_ + 2], R[2] = I[_ + 1], R[3] = I[_ + 0], a._binBE.ui32[0];
        }, readASCII: function(I, _, R) {
          for (var W = "", O = 0; O < R; O++)
            W += String.fromCharCode(I[_ + O]);
          return W;
        }, readFloat: function(I, _) {
          for (var R = a._binBE.ui8, W = 0; W < 4; W++)
            R[W] = I[_ + 3 - W];
          return a._binBE.fl32[0];
        }, readDouble: function(I, _) {
          for (var R = a._binBE.ui8, W = 0; W < 8; W++)
            R[W] = I[_ + 7 - W];
          return a._binBE.fl64[0];
        }, writeUshort: function(I, _, R) {
          I[_] = R >> 8 & 255, I[_ + 1] = 255 & R;
        }, writeInt: function(I, _, R) {
          var W = a._binBE.ui8;
          a._binBE.i32[0] = R, I[_ + 3] = W[0], I[_ + 2] = W[1], I[_ + 1] = W[2], I[_ + 0] = W[3];
        }, writeUint: function(I, _, R) {
          I[_] = R >> 24 & 255, I[_ + 1] = R >> 16 & 255, I[_ + 2] = R >> 8 & 255, I[_ + 3] = R >> 0 & 255;
        }, writeASCII: function(I, _, R) {
          for (var W = 0; W < R.length; W++)
            I[_ + W] = R.charCodeAt(W);
        }, writeDouble: function(I, _, R) {
          a._binBE.fl64[0] = R;
          for (var W = 0; W < 8; W++)
            I[_ + W] = a._binBE.ui8[7 - W];
        } }, a._binBE.ui8 = new Uint8Array(8), a._binBE.i16 = new Int16Array(a._binBE.ui8.buffer), a._binBE.i32 = new Int32Array(a._binBE.ui8.buffer), a._binBE.ui32 = new Uint32Array(a._binBE.ui8.buffer), a._binBE.fl32 = new Float32Array(a._binBE.ui8.buffer), a._binBE.fl64 = new Float64Array(a._binBE.ui8.buffer), a._binLE = { nextZero: a._binBE.nextZero, readUshort: function(I, _) {
          return I[_ + 1] << 8 | I[_];
        }, readShort: function(I, _) {
          var R = a._binBE.ui8;
          return R[0] = I[_ + 0], R[1] = I[_ + 1], a._binBE.i16[0];
        }, readInt: function(I, _) {
          var R = a._binBE.ui8;
          return R[0] = I[_ + 0], R[1] = I[_ + 1], R[2] = I[_ + 2], R[3] = I[_ + 3], a._binBE.i32[0];
        }, readUint: function(I, _) {
          var R = a._binBE.ui8;
          return R[0] = I[_ + 0], R[1] = I[_ + 1], R[2] = I[_ + 2], R[3] = I[_ + 3], a._binBE.ui32[0];
        }, readASCII: a._binBE.readASCII, readFloat: function(I, _) {
          for (var R = a._binBE.ui8, W = 0; W < 4; W++)
            R[W] = I[_ + W];
          return a._binBE.fl32[0];
        }, readDouble: function(I, _) {
          for (var R = a._binBE.ui8, W = 0; W < 8; W++)
            R[W] = I[_ + W];
          return a._binBE.fl64[0];
        }, writeUshort: function(I, _, R) {
          I[_] = 255 & R, I[_ + 1] = R >> 8 & 255;
        }, writeInt: function(I, _, R) {
          var W = a._binBE.ui8;
          a._binBE.i32[0] = R, I[_ + 0] = W[0], I[_ + 1] = W[1], I[_ + 2] = W[2], I[_ + 3] = W[3];
        }, writeUint: function(I, _, R) {
          I[_] = R >>> 0 & 255, I[_ + 1] = R >>> 8 & 255, I[_ + 2] = R >>> 16 & 255, I[_ + 3] = R >>> 24 & 255;
        }, writeASCII: a._binBE.writeASCII }, a._copyTile = function(I, _, R, W, O, j, U, C) {
          for (var ae = Math.min(_, O - U), J = Math.min(R, j - C), te = 0; te < J; te++)
            for (var $ = (C + te) * O + U, L = te * _, re = 0; re < ae; re++)
              W[$ + re] = I[L + re];
        }, a.LosslessJpegDecode = function() {
          var I, _;
          function R() {
            return I[_++];
          }
          function W() {
            return I[_++] << 8 | I[_++];
          }
          function O(z) {
            for (var N = R(), ne = [0, 0, 0, 255], le = [], he = 0; he < 16; he++)
              le[he] = R();
            for (he = 0; he < 16; he++)
              for (var k = 0; k < le[he]; k++)
                ne[j(ne, 0, he + 1, 1) + 3] = R();
            var T = new Uint8Array(256);
            for (z[N] = [new Uint8Array(ne), T], he = 0; he < 256; he++) {
              for (var B = 8, K = he, h = 0; ne[h + 3] == 255 && B != 0; )
                h = ne[h + (K >> --B & 1)];
              T[he] = h;
            }
          }
          function j(z, N, ne, le) {
            if (z[N + 3] != 255)
              return 0;
            if (ne == 0)
              return N;
            for (var he = 0; he < 2; he++) {
              z[N + he] == 0 && (z[N + he] = z.length, z.push(0, 0, le, 255));
              var k = j(z, z[N + he], ne - 1, le + 1);
              if (k != 0)
                return k;
            }
            return 0;
          }
          function U(z) {
            for (var N = z.b, ne = z.a; N < 25 && z.e < z.d; ) {
              var le = z.data[z.e++];
              z.c || (z.e += le + 1 >>> 8), ne = ne << 8 | le, N += 8;
            }
            if (N < 0)
              throw "e";
            z.b = N, z.a = ne;
          }
          function C(z, N) {
            return N.b < z && U(N), N.a >> (N.b -= z) & 65535 >> 16 - z;
          }
          function ae(z, N) {
            var ne = z[0], le = 0, he = 255;
            N.b < 16 && U(N);
            var k = N.a >> N.b - 8 & 255;
            for (he = ne[(le = z[1][k]) + 3], N.b -= ne[le + 2]; he == 255; )
              he = ne[(le = ne[le + (N.a >> --N.b & 1)]) + 3];
            return he;
          }
          function J(z, N) {
            return z < 32768 >> 16 - N && (z += 1 - (1 << N)), z;
          }
          function te(z, N) {
            var ne = ae(z, N);
            return ne == 0 ? 0 : ne == 16 ? -32768 : J(C(ne, N), ne);
          }
          function $(z, N, ne, le, he, k) {
            for (var T = 0; T < k; T++)
              for (var B = T * N, K = 0; K < N; K += he)
                for (var h = 0; h < he; h++)
                  z[B + K + h] = te(le[h], ne);
          }
          function L(z, N) {
            return J(C(z, N), z);
          }
          function re(z, N, ne, le, he, k, T, B) {
            for (var K = ne * T, h = he; h < k; h++)
              z[h] += 1 << B - 1;
            for (var c = T; c < K; c += T)
              for (h = he; h < k; h++)
                z[c + h] += z[c + h - T];
            for (var m = 1; m < le; m++) {
              var D = m * K;
              for (h = he; h < k; h++)
                z[D + h] += z[D + h - K];
              for (c = T; c < K; c += T)
                for (h = he; h < k; h++) {
                  var ee = D + c + h, E = ee - K, Q = z[ee - T], se = 0;
                  if (N == 0)
                    se = 0;
                  else if (N == 1)
                    se = Q;
                  else if (N == 2)
                    se = z[E];
                  else if (N == 3)
                    se = z[E - T];
                  else if (N == 4)
                    se = Q + (z[E] - z[E - T]);
                  else if (N == 5)
                    se = Q + (z[E] - z[E - T] >>> 1);
                  else if (N == 6)
                    se = z[E] + (Q - z[E - T] >>> 1);
                  else {
                    if (N != 7)
                      throw N;
                    se = Q + z[E] >>> 1;
                  }
                  z[ee] += se;
                }
            }
          }
          return function(z) {
            if (I = z, _ = 0, W() != 65496)
              throw "e";
            for (var N = [], ne = 0, le = 0, he = [], k = [], T = [], B = 0, K = 0, h = 0; ; ) {
              var c = W();
              if (c != 65535) {
                var m = W();
                if (c == 65475) {
                  le = R(), K = W(), h = W(), B = R();
                  for (var D = 0; D < B; D++) {
                    var ee = R(), E = R();
                    if (R() != 0)
                      throw "e";
                    N[ee] = [D, E >> 4, 15 & E];
                  }
                } else if (c == 65476)
                  for (var Q = _ + m - 2; _ < Q; )
                    O(k);
                else {
                  if (c == 65498) {
                    for (_++, D = 0; D < B; D++) {
                      var se = N[R()];
                      T[se[0]] = k[R() >>> 4], he[se[0]] = se.slice(1);
                    }
                    ne = R(), _ += 2;
                    break;
                  }
                  _ += m - 2;
                }
              } else
                _--;
            }
            var Y = new (le > 8 ? Uint16Array : Uint8Array)(K * h * B), be = { b: 0, a: 0, c: ne == 8, e: _, data: I, d: I.length };
            if (be.c)
              (function(de, Ze, Re, rt, De) {
                for (var Je = I.length - _, Ne = 0; Ne < Je; Ne += 4) {
                  var Ie = I[_ + Ne];
                  I[_ + Ne] = I[_ + Ne + 3], I[_ + Ne + 3] = Ie, Ie = I[_ + Ne + 1], I[_ + Ne + 1] = I[_ + Ne + 2], I[_ + Ne + 2] = Ie;
                }
                for (var at = 0; at < De; at++)
                  for (var st = 32768, tt = 32768, mt = 0; mt < Ze; mt += 2) {
                    var It = ae(rt, Re), wt = ae(rt, Re);
                    It != 0 && (st += L(It, Re)), wt != 0 && (tt += L(wt, Re)), de[at * Ze + mt] = 65535 & st, de[at * Ze + mt + 1] = 65535 & tt;
                  }
              })(Y, h * B, be, T[0], K);
            else {
              var Ee = [], Me = 0, ke = 0;
              for (D = 0; D < B; D++) {
                var oe = he[D];
                (We = oe[0]) > Me && (Me = We), (Fe = oe[1]) > ke && (ke = Fe), Ee.push(We * Fe);
              }
              if (Me != 1 || ke != 1) {
                var ce = [], xe = 0;
                for (D = 0; D < B; D++) {
                  for (var Ce = 0; Ce < Ee[D]; Ce++)
                    ce.push(T[D]);
                  xe += Ee[D];
                }
                var _e = h / Me, Be = K / ke;
                $(Y, _e * xe, be, ce, xe, Be), re(Y, ne, _e, Be, xe - 2, xe, xe, le);
                for (var Pe = Y.slice(0), Fe = 0; Fe < K; Fe++)
                  for (var We = 0; We < h; We++) {
                    var Qe = (Fe * h + We) * B, lt = ~~(Fe / ke) * _e + ~~(We / Me), P = 0;
                    for (D = 0; D < B; D++) {
                      var we = 1 & We, X = lt * xe + P + (D == 0 ? ke == 1 ? we : 2 * we + (1 & Fe) : 0);
                      Y[Qe + D] = Pe[X], P += Ee[D];
                    }
                  }
                re(Y, ne, h, K, 0, 1, B, le);
              } else
                $(Y, h * B, be, T, B, K), re(Y, ne, h, K, 0, B, B, le);
            }
            return Y;
          };
        }(), function() {
          var I = 2, _ = 3, R = 4, W = 5, O = 6, j = 7, U = 8, C = 9, ae = 10, J = 11, te = 12, $ = 13, L = 14, re = 15, z = 16, N = 17;
          function ne(c) {
            for (var m = [[], [], []], D = Math.max(2, c.w + 32 >>> 6), ee = 0; ee < 3; ee++)
              for (var E = 0; E < 41; E++)
                m[ee][E] = [D, 1];
            return m;
          }
          function le(c, m) {
            var D = 0, ee = 8 - c.a;
            if (c.j, c.a, m) {
              if (m >= ee)
                do
                  D <<= ee, m -= ee, D |= c[c.j] & (1 << ee) - 1, c.j++, ee = 8;
                while (m >= 8);
              m && (D <<= m, ee -= m, D |= c[c.j] >>> ee & (1 << m) - 1), c.a = 8 - ee;
            }
            return D;
          }
          function he(c, m, D, ee, E, Q, se, Y) {
            Y == null && (Y = 0);
            var be, Ee, Me, ke, oe, ce, xe = Q + 1, Ce = xe % 2, _e = 0, Be = ee[E], Pe = ee[E - 1], Fe = ee[E - 2][xe], We = Pe[xe - 1], Qe = Pe[xe], lt = Pe[xe + 1], P = Be[xe - 1], we = Be[xe + 1], X = Math.abs;
            if (Ce && (Me = X(lt - Qe), ke = X(Fe - Qe), oe = X(We - Qe)), Ce) {
              if (ce = (ce = Me > oe && ke < Me ? Fe + We : Me < oe && ke < oe ? Fe + lt : lt + We) + 2 * Qe >>> 2, Y)
                return void (Be[xe] = ce);
              be = m.t * m.c[c.g + Qe - Fe] + m.c[c.g + We - Qe];
            } else
              ce = Qe > We && Qe > lt || Qe < We && Qe < lt ? we + P + 2 * Qe >>> 2 : P + we >>> 1, be = m.t * m.c[c.g + Qe - We] + m.c[c.g + We - P];
            Ee = X(be);
            var de = function(Re) {
              for (var rt = -1, De = 0; !De; rt++)
                De = Re[Re.j] >>> 7 - Re.a & 1, Re.a++, Re.a &= 7, Re.a || Re.j++;
              return rt;
            }(D);
            if (de < c.n - m.v - 1) {
              var Ze = function(Re, rt) {
                var De = 0;
                if (rt < Re)
                  for (; De <= 14 && rt << ++De < Re; )
                    ;
                return De;
              }(se[Ee][0], se[Ee][1]);
              _e = le(D, Ze) + (de << Ze);
            } else
              _e = le(D, m.v) + 1;
            _e = 1 & _e ? -1 - (_e >>> 1) : _e >>> 1, se[Ee][0] += X(_e), se[Ee][1] == c.f && (se[Ee][0] >>>= 1, se[Ee][1] >>>= 1), se[Ee][1]++, ce = be < 0 ? ce - _e : ce + _e, c.i && (ce < 0 ? ce += m.w : ce > c.g && (ce -= m.w)), Be[xe] = ce >= 0 ? Math.min(ce, c.g) : 0;
          }
          function k(c, m, D) {
            for (var ee = c[0].length, E = m; E <= D; E++)
              c[E][0] = c[E - 1][1], c[E][ee - 1] = c[E - 1][ee - 2];
          }
          function T(c) {
            k(c, j, te), k(c, I, R), k(c, re, N);
          }
          function B(c, m, D, ee, E, Q, se, Y, be, Ee, Me, ke, oe) {
            for (var ce = 0, xe = 1, Ce = E < $ && E > R; xe < c.m; )
              ce < c.m && (he(c, m, D, ee, E, ce, se[be], c.h && (Ce && Ee || !Ce && (Me || (ce & ke) == oe))), he(c, m, D, ee, Q, ce, se[be], c.h && (!Ce && Ee || Ce && (Me || (ce & ke) == oe))), ce += 2), ce > 8 && (he(c, m, D, ee, E, xe, Y[be]), he(c, m, D, ee, Q, xe, Y[be]), xe += 2);
            T(ee);
          }
          function K(c, m, D, ee, E, Q) {
            B(c, m, D, ee, I, j, E, Q, 0, 0, 1, 0, 8), B(c, m, D, ee, U, re, E, Q, 1, 0, 1, 0, 8), B(c, m, D, ee, _, C, E, Q, 2, 1, 0, 3, 0), B(c, m, D, ee, ae, z, E, Q, 0, 0, 0, 3, 2), B(c, m, D, ee, R, J, E, Q, 1, 0, 0, 3, 2), B(c, m, D, ee, te, N, E, Q, 2, 1, 0, 3, 0);
          }
          function h(c, m, D, ee, E, Q) {
            var se = Q.length, Y = c.l;
            E + 1 == c.s && (Y = c.e - E * c.l);
            for (var be = 6 * c.e * ee + E * c.l, Ee = 0; Ee < 6; Ee++) {
              for (var Me = 0; Me < Y; Me++) {
                var ke, oe = Q[Ee % se][Me % se];
                ke = oe == 0 ? I + (Ee >>> 1) : oe == 2 ? re + (Ee >>> 1) : j + Ee;
                var ce = c.h ? (2 * Me / 3 & 2147483646 | Me % 3 & 1) + (Me % 3 >>> 1) : Me >>> 1;
                m[be + Me] = D[ke][ce + 1];
              }
              be += c.e;
            }
          }
          a._decompressRAF = function(c, m) {
            var D = function(xe) {
              var Ce = a._binBE.readUshort, _e = { b: Ce(xe, 0), i: xe[2], C: xe[3], u: xe[4], q: Ce(xe, 5), k: Ce(xe, 7), e: Ce(xe, 9), l: Ce(xe, 11), s: xe[13], d: Ce(xe, 14) };
              if (_e.b != 18771 || _e.i > 1 || _e.q < 6 || _e.q % 6 || _e.e < 768 || _e.e % 24 || _e.l != 768 || _e.k < _e.l || _e.k % _e.l || _e.k - _e.e >= _e.l || _e.s > 16 || _e.s != _e.k / _e.l || _e.s != Math.ceil(_e.e / _e.l) || _e.d != _e.q / 6 || _e.u != 12 && _e.u != 14 && _e.u != 16 || _e.C != 16 && _e.C != 0)
                throw "Invalid data";
              if (_e.i == 0)
                throw "Not implemented. We need this file!";
              return _e.h = _e.C == 16, _e.m = 0 | (_e.h ? 2 * _e.l / 3 : _e.l >>> 1), _e.A = _e.m + 2, _e.f = 64, _e.g = (1 << _e.u) - 1, _e.n = 4 * _e.u, _e;
            }(c), ee = function(xe, Ce) {
              var _e = new Array(Ce.s), Be = 4 * Ce.s, Pe = 16 + Be;
              12 & Be && (Pe += 16 - (12 & Be));
              for (var Fe = 0, We = 16; Fe < Ce.s; We += 4) {
                var Qe = a._binBE.readUint(xe, We);
                _e[Fe] = xe.slice(Pe, Pe + Qe), _e[Fe].j = 0, _e[Fe].a = 0, Pe += Qe, Fe++;
              }
              if (Pe != xe.length)
                throw "Invalid data";
              return _e;
            }(c, D), E = function(xe) {
              var Ce = { c: new Int8Array(2 << xe.u) };
              return function(_e, Be, Pe) {
                var Fe = [0, 18, 67, 276, Pe];
                _e.o = 0, _e.w = (Fe[4] + 0) / 1 + 1 | 0, _e.v = Math.ceil(Math.log2(_e.w)), _e.t = 9, function(We, Qe) {
                  for (var lt = -Qe[4], P = 0; lt <= Qe[4]; P++, lt++)
                    We[P] = lt <= -Qe[3] ? -4 : lt <= -Qe[2] ? -3 : lt <= -Qe[1] ? -2 : lt < -Qe[0] ? -1 : lt <= Qe[0] ? 0 : lt < Qe[1] ? 1 : lt < Qe[2] ? 2 : lt < Qe[3] ? 3 : 4;
                }(_e.c, Fe);
              }(Ce, 0, xe.g), Ce;
            }(D), Q = new Int16Array(D.e * D.q);
            m == null && (m = D.h ? [[1, 1, 0, 1, 1, 2], [1, 1, 2, 1, 1, 0], [2, 0, 1, 0, 2, 1], [1, 1, 2, 1, 1, 0], [1, 1, 0, 1, 1, 2], [0, 2, 1, 2, 0, 1]] : [[0, 1], [3, 2]]);
            for (var se = [[0, _], [1, R], [W, J], [O, te], [$, z], [L, N]], Y = [], be = 0; be < 18; be++)
              Y[be] = new Uint16Array(D.A);
            for (var Ee = 0; Ee < D.s; Ee++) {
              var Me = ne(E), ke = ne(E);
              for (be = 0; be < 18; be++)
                for (var oe = 0; oe < D.A; oe++)
                  Y[be][oe] = 0;
              for (var ce = 0; ce < D.d; ce++) {
                for (K(D, E, ee[Ee], Y, Me, ke), be = 0; be < 6; be++)
                  for (oe = 0; oe < D.A; oe++)
                    Y[se[be][0]][oe] = Y[se[be][1]][oe];
                for (h(D, Q, Y, ce, Ee, m), be = I; be < 18; be++)
                  if ([W, O, $, L].indexOf(be) == -1)
                    for (oe = 0; oe < D.A; oe++)
                      Y[be][oe] = 0;
                T(Y);
              }
            }
            return Q;
          };
        }();
      }(f, s(2845));
    })();
  }, 6168: (d, l, s) => {
    s.r(l), s.d(l, { DOMException: () => V, Headers: () => n, Request: () => w, Response: () => G, fetch: () => q });
    var e = typeof globalThis < "u" && globalThis || typeof self < "u" && self || e !== void 0 && e, f = { searchParams: "URLSearchParams" in e, iterable: "Symbol" in e && "iterator" in Symbol, blob: "FileReader" in e && "Blob" in e && function() {
      try {
        return new Blob(), !0;
      } catch {
        return !1;
      }
    }(), formData: "FormData" in e, arrayBuffer: "ArrayBuffer" in e };
    if (f.arrayBuffer)
      var i = ["[object Int8Array]", "[object Uint8Array]", "[object Uint8ClampedArray]", "[object Int16Array]", "[object Uint16Array]", "[object Int32Array]", "[object Uint32Array]", "[object Float32Array]", "[object Float64Array]"], a = ArrayBuffer.isView || function(I) {
        return I && i.indexOf(Object.prototype.toString.call(I)) > -1;
      };
    function t(I) {
      if (typeof I != "string" && (I = String(I)), /[^a-z0-9\-#$%&'*+.^_`|~!]/i.test(I) || I === "")
        throw new TypeError('Invalid character in header field name: "' + I + '"');
      return I.toLowerCase();
    }
    function r(I) {
      return typeof I != "string" && (I = String(I)), I;
    }
    function o(I) {
      var _ = { next: function() {
        var R = I.shift();
        return { done: R === void 0, value: R };
      } };
      return f.iterable && (_[Symbol.iterator] = function() {
        return _;
      }), _;
    }
    function n(I) {
      this.map = {}, I instanceof n ? I.forEach(function(_, R) {
        this.append(R, _);
      }, this) : Array.isArray(I) ? I.forEach(function(_) {
        this.append(_[0], _[1]);
      }, this) : I && Object.getOwnPropertyNames(I).forEach(function(_) {
        this.append(_, I[_]);
      }, this);
    }
    function u(I) {
      if (I.bodyUsed)
        return Promise.reject(new TypeError("Already read"));
      I.bodyUsed = !0;
    }
    function p(I) {
      return new Promise(function(_, R) {
        I.onload = function() {
          _(I.result);
        }, I.onerror = function() {
          R(I.error);
        };
      });
    }
    function g(I) {
      var _ = new FileReader(), R = p(_);
      return _.readAsArrayBuffer(I), R;
    }
    function v(I) {
      if (I.slice)
        return I.slice(0);
      var _ = new Uint8Array(I.byteLength);
      return _.set(new Uint8Array(I)), _.buffer;
    }
    function x() {
      return this.bodyUsed = !1, this._initBody = function(I) {
        var _;
        this.bodyUsed = this.bodyUsed, this._bodyInit = I, I ? typeof I == "string" ? this._bodyText = I : f.blob && Blob.prototype.isPrototypeOf(I) ? this._bodyBlob = I : f.formData && FormData.prototype.isPrototypeOf(I) ? this._bodyFormData = I : f.searchParams && URLSearchParams.prototype.isPrototypeOf(I) ? this._bodyText = I.toString() : f.arrayBuffer && f.blob && (_ = I) && DataView.prototype.isPrototypeOf(_) ? (this._bodyArrayBuffer = v(I.buffer), this._bodyInit = new Blob([this._bodyArrayBuffer])) : f.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(I) || a(I)) ? this._bodyArrayBuffer = v(I) : this._bodyText = I = Object.prototype.toString.call(I) : this._bodyText = "", this.headers.get("content-type") || (typeof I == "string" ? this.headers.set("content-type", "text/plain;charset=UTF-8") : this._bodyBlob && this._bodyBlob.type ? this.headers.set("content-type", this._bodyBlob.type) : f.searchParams && URLSearchParams.prototype.isPrototypeOf(I) && this.headers.set("content-type", "application/x-www-form-urlencoded;charset=UTF-8"));
      }, f.blob && (this.blob = function() {
        var I = u(this);
        if (I)
          return I;
        if (this._bodyBlob)
          return Promise.resolve(this._bodyBlob);
        if (this._bodyArrayBuffer)
          return Promise.resolve(new Blob([this._bodyArrayBuffer]));
        if (this._bodyFormData)
          throw new Error("could not read FormData body as blob");
        return Promise.resolve(new Blob([this._bodyText]));
      }, this.arrayBuffer = function() {
        return this._bodyArrayBuffer ? u(this) || (ArrayBuffer.isView(this._bodyArrayBuffer) ? Promise.resolve(this._bodyArrayBuffer.buffer.slice(this._bodyArrayBuffer.byteOffset, this._bodyArrayBuffer.byteOffset + this._bodyArrayBuffer.byteLength)) : Promise.resolve(this._bodyArrayBuffer)) : this.blob().then(g);
      }), this.text = function() {
        var I, _, R, W = u(this);
        if (W)
          return W;
        if (this._bodyBlob)
          return I = this._bodyBlob, R = p(_ = new FileReader()), _.readAsText(I), R;
        if (this._bodyArrayBuffer)
          return Promise.resolve(function(O) {
            for (var j = new Uint8Array(O), U = new Array(j.length), C = 0; C < j.length; C++)
              U[C] = String.fromCharCode(j[C]);
            return U.join("");
          }(this._bodyArrayBuffer));
        if (this._bodyFormData)
          throw new Error("could not read FormData body as text");
        return Promise.resolve(this._bodyText);
      }, f.formData && (this.formData = function() {
        return this.text().then(M);
      }), this.json = function() {
        return this.text().then(JSON.parse);
      }, this;
    }
    n.prototype.append = function(I, _) {
      I = t(I), _ = r(_);
      var R = this.map[I];
      this.map[I] = R ? R + ", " + _ : _;
    }, n.prototype.delete = function(I) {
      delete this.map[t(I)];
    }, n.prototype.get = function(I) {
      return I = t(I), this.has(I) ? this.map[I] : null;
    }, n.prototype.has = function(I) {
      return this.map.hasOwnProperty(t(I));
    }, n.prototype.set = function(I, _) {
      this.map[t(I)] = r(_);
    }, n.prototype.forEach = function(I, _) {
      for (var R in this.map)
        this.map.hasOwnProperty(R) && I.call(_, this.map[R], R, this);
    }, n.prototype.keys = function() {
      var I = [];
      return this.forEach(function(_, R) {
        I.push(R);
      }), o(I);
    }, n.prototype.values = function() {
      var I = [];
      return this.forEach(function(_) {
        I.push(_);
      }), o(I);
    }, n.prototype.entries = function() {
      var I = [];
      return this.forEach(function(_, R) {
        I.push([R, _]);
      }), o(I);
    }, f.iterable && (n.prototype[Symbol.iterator] = n.prototype.entries);
    var b = ["DELETE", "GET", "HEAD", "OPTIONS", "POST", "PUT"];
    function w(I, _) {
      if (!(this instanceof w))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
      var R, W, O = (_ = _ || {}).body;
      if (I instanceof w) {
        if (I.bodyUsed)
          throw new TypeError("Already read");
        this.url = I.url, this.credentials = I.credentials, _.headers || (this.headers = new n(I.headers)), this.method = I.method, this.mode = I.mode, this.signal = I.signal, O || I._bodyInit == null || (O = I._bodyInit, I.bodyUsed = !0);
      } else
        this.url = String(I);
      if (this.credentials = _.credentials || this.credentials || "same-origin", !_.headers && this.headers || (this.headers = new n(_.headers)), this.method = (W = (R = _.method || this.method || "GET").toUpperCase(), b.indexOf(W) > -1 ? W : R), this.mode = _.mode || this.mode || null, this.signal = _.signal || this.signal, this.referrer = null, (this.method === "GET" || this.method === "HEAD") && O)
        throw new TypeError("Body not allowed for GET or HEAD requests");
      if (this._initBody(O), !(this.method !== "GET" && this.method !== "HEAD" || _.cache !== "no-store" && _.cache !== "no-cache")) {
        var j = /([?&])_=[^&]*/;
        j.test(this.url) ? this.url = this.url.replace(j, "$1_=" + (/* @__PURE__ */ new Date()).getTime()) : this.url += (/\?/.test(this.url) ? "&" : "?") + "_=" + (/* @__PURE__ */ new Date()).getTime();
      }
    }
    function M(I) {
      var _ = new FormData();
      return I.trim().split("&").forEach(function(R) {
        if (R) {
          var W = R.split("="), O = W.shift().replace(/\+/g, " "), j = W.join("=").replace(/\+/g, " ");
          _.append(decodeURIComponent(O), decodeURIComponent(j));
        }
      }), _;
    }
    function G(I, _) {
      if (!(this instanceof G))
        throw new TypeError('Please use the "new" operator, this DOM object constructor cannot be called as a function.');
      _ || (_ = {}), this.type = "default", this.status = _.status === void 0 ? 200 : _.status, this.ok = this.status >= 200 && this.status < 300, this.statusText = _.statusText === void 0 ? "" : "" + _.statusText, this.headers = new n(_.headers), this.url = _.url || "", this._initBody(I);
    }
    w.prototype.clone = function() {
      return new w(this, { body: this._bodyInit });
    }, x.call(w.prototype), x.call(G.prototype), G.prototype.clone = function() {
      return new G(this._bodyInit, { status: this.status, statusText: this.statusText, headers: new n(this.headers), url: this.url });
    }, G.error = function() {
      var I = new G(null, { status: 0, statusText: "" });
      return I.type = "error", I;
    };
    var F = [301, 302, 303, 307, 308];
    G.redirect = function(I, _) {
      if (F.indexOf(_) === -1)
        throw new RangeError("Invalid status code");
      return new G(null, { status: _, headers: { location: I } });
    };
    var V = e.DOMException;
    try {
      new V();
    } catch {
      (V = function(_, R) {
        this.message = _, this.name = R;
        var W = Error(_);
        this.stack = W.stack;
      }).prototype = Object.create(Error.prototype), V.prototype.constructor = V;
    }
    function q(I, _) {
      return new Promise(function(R, W) {
        var O = new w(I, _);
        if (O.signal && O.signal.aborted)
          return W(new V("Aborted", "AbortError"));
        var j = new XMLHttpRequest();
        function U() {
          j.abort();
        }
        j.onload = function() {
          var C, ae, J = { status: j.status, statusText: j.statusText, headers: (C = j.getAllResponseHeaders() || "", ae = new n(), C.replace(/\r?\n[\t ]+/g, " ").split("\r").map(function($) {
            return $.indexOf(`
`) === 0 ? $.substr(1, $.length) : $;
          }).forEach(function($) {
            var L = $.split(":"), re = L.shift().trim();
            if (re) {
              var z = L.join(":").trim();
              ae.append(re, z);
            }
          }), ae) };
          J.url = "responseURL" in j ? j.responseURL : J.headers.get("X-Request-URL");
          var te = "response" in j ? j.response : j.responseText;
          setTimeout(function() {
            R(new G(te, J));
          }, 0);
        }, j.onerror = function() {
          setTimeout(function() {
            W(new TypeError("Network request failed"));
          }, 0);
        }, j.ontimeout = function() {
          setTimeout(function() {
            W(new TypeError("Network request failed"));
          }, 0);
        }, j.onabort = function() {
          setTimeout(function() {
            W(new V("Aborted", "AbortError"));
          }, 0);
        }, j.open(O.method, function(C) {
          try {
            return C === "" && e.location.href ? e.location.href : C;
          } catch {
            return C;
          }
        }(O.url), !0), O.credentials === "include" ? j.withCredentials = !0 : O.credentials === "omit" && (j.withCredentials = !1), "responseType" in j && (f.blob ? j.responseType = "blob" : f.arrayBuffer && O.headers.get("Content-Type") && O.headers.get("Content-Type").indexOf("application/octet-stream") !== -1 && (j.responseType = "arraybuffer")), !_ || typeof _.headers != "object" || _.headers instanceof n ? O.headers.forEach(function(C, ae) {
          j.setRequestHeader(ae, C);
        }) : Object.getOwnPropertyNames(_.headers).forEach(function(C) {
          j.setRequestHeader(C, r(_.headers[C]));
        }), O.signal && (O.signal.addEventListener("abort", U), j.onreadystatechange = function() {
          j.readyState === 4 && O.signal.removeEventListener("abort", U);
        }), j.send(O._bodyInit === void 0 ? null : O._bodyInit);
      });
    }
    q.polyfill = !0, e.fetch || (e.fetch = q, e.Headers = n, e.Request = w, e.Response = G);
  }, 6290: (d, l, s) => {
    var e = s(5048), f = s(9748), i = s(4655), a = s(1960);
    function t(n, u, p) {
      var g = n;
      return f(u) ? (p = u, typeof n == "string" && (g = { uri: n })) : g = a(u, { uri: n }), g.callback = p, g;
    }
    function r(n, u, p) {
      return o(u = t(n, u, p));
    }
    function o(n) {
      if (n.callback === void 0)
        throw new Error("callback argument missing");
      var u = !1, p = function(O, j, U) {
        u || (u = !0, n.callback(O, j, U));
      };
      function g() {
        var O = void 0;
        if (O = M.response ? M.response : M.responseText || function(j) {
          try {
            if (j.responseType === "document")
              return j.responseXML;
            var U = j.responseXML && j.responseXML.documentElement.nodeName === "parsererror";
            if (j.responseType === "" && !U)
              return j.responseXML;
          } catch {
          }
          return null;
        }(M), R)
          try {
            O = JSON.parse(O);
          } catch {
          }
        return O;
      }
      function v(O) {
        return clearTimeout(G), O instanceof Error || (O = new Error("" + (O || "Unknown XMLHttpRequest Error"))), O.statusCode = 0, p(O, W);
      }
      function x() {
        if (!w) {
          var O;
          clearTimeout(G), O = n.useXDR && M.status === void 0 ? 200 : M.status === 1223 ? 204 : M.status;
          var j = W, U = null;
          return O !== 0 ? (j = { body: g(), statusCode: O, method: V, headers: {}, url: F, rawRequest: M }, M.getAllResponseHeaders && (j.headers = i(M.getAllResponseHeaders()))) : U = new Error("Internal XMLHttpRequest Error"), p(U, j, j.body);
        }
      }
      var b, w, M = n.xhr || null;
      M || (M = n.cors || n.useXDR ? new r.XDomainRequest() : new r.XMLHttpRequest());
      var G, F = M.url = n.uri || n.url, V = M.method = n.method || "GET", q = n.body || n.data, I = M.headers = n.headers || {}, _ = !!n.sync, R = !1, W = { body: void 0, headers: {}, statusCode: 0, method: V, url: F, rawRequest: M };
      if ("json" in n && n.json !== !1 && (R = !0, I.accept || I.Accept || (I.Accept = "application/json"), V !== "GET" && V !== "HEAD" && (I["content-type"] || I["Content-Type"] || (I["Content-Type"] = "application/json"), q = JSON.stringify(n.json === !0 ? q : n.json))), M.onreadystatechange = function() {
        M.readyState === 4 && setTimeout(x, 0);
      }, M.onload = x, M.onerror = v, M.onprogress = function() {
      }, M.onabort = function() {
        w = !0;
      }, M.ontimeout = v, M.open(V, F, !_, n.username, n.password), _ || (M.withCredentials = !!n.withCredentials), !_ && n.timeout > 0 && (G = setTimeout(function() {
        if (!w) {
          w = !0, M.abort("timeout");
          var O = new Error("XMLHttpRequest timeout");
          O.code = "ETIMEDOUT", v(O);
        }
      }, n.timeout)), M.setRequestHeader)
        for (b in I)
          I.hasOwnProperty(b) && M.setRequestHeader(b, I[b]);
      else if (n.headers && !function(O) {
        for (var j in O)
          if (O.hasOwnProperty(j))
            return !1;
        return !0;
      }(n.headers))
        throw new Error("Headers cannot be set on an XDomainRequest object");
      return "responseType" in n && (M.responseType = n.responseType), "beforeSend" in n && typeof n.beforeSend == "function" && n.beforeSend(M), M.send(q || null), M;
    }
    d.exports = r, d.exports.default = r, r.XMLHttpRequest = e.XMLHttpRequest || function() {
    }, r.XDomainRequest = "withCredentials" in new r.XMLHttpRequest() ? r.XMLHttpRequest : e.XDomainRequest, function(n, u) {
      for (var p = 0; p < n.length; p++)
        u(n[p]);
    }(["get", "put", "post", "patch", "head", "delete"], function(n) {
      r[n === "delete" ? "del" : n] = function(u, p, g) {
        return (p = t(u, p, g)).method = n.toUpperCase(), o(p);
      };
    });
  }, 1596: (d) => {
    d.exports = self.DOMParser !== void 0 ? function(l) {
      return new self.DOMParser().parseFromString(l, "application/xml");
    } : self.ActiveXObject !== void 0 && new self.ActiveXObject("Microsoft.XMLDOM") ? function(l) {
      var s = new self.ActiveXObject("Microsoft.XMLDOM");
      return s.async = "false", s.loadXML(l), s;
    } : function(l) {
      var s = document.createElement("div");
      return s.innerHTML = l, s;
    };
  }, 1960: (d) => {
    d.exports = function() {
      for (var s = {}, e = 0; e < arguments.length; e++) {
        var f = arguments[e];
        for (var i in f)
          l.call(f, i) && (s[i] = f[i]);
      }
      return s;
    };
    var l = Object.prototype.hasOwnProperty;
  }, 8522: () => {
  }, 6777: () => {
  }, 5546: () => {
  }, 2460: (d, l, s) => {
    var e = s(4406), f = Object.defineProperty, i = Object.getOwnPropertyDescriptor, a = Object.getOwnPropertyNames, t = Object.prototype.hasOwnProperty, r = (y, ue) => {
      for (var pe in ue)
        f(y, pe, { get: ue[pe], enumerable: !0 });
    }, o = ((y) => (ue, pe) => y && y.get(ue) || (pe = ((ve, Te, Ue, Le) => {
      if (Te && typeof Te == "object" || typeof Te == "function")
        for (let qe of a(Te))
          t.call(ve, qe) || f(ve, qe, { get: () => Te[qe], enumerable: !(Le = i(Te, qe)) || Le.enumerable });
      return ve;
    })(f({}, "__esModule", { value: !0 }), ue), y && y.set(ue, pe), pe))(typeof WeakMap < "u" ? /* @__PURE__ */ new WeakMap() : 0), n = (y, ue, pe) => (((ve, Te, Ue) => {
      Te in ve ? f(ve, Te, { enumerable: !0, configurable: !0, writable: !0, value: Ue }) : ve[Te] = Ue;
    })(y, typeof ue != "symbol" ? ue + "" : ue, pe), pe), u = {};
    r(u, { applyPalette: () => or, applyPaletteSync: () => Xt, buildPalette: () => er, buildPaletteSync: () => Jt, constants: () => p, conversion: () => w, distance: () => T, image: () => Ft, palette: () => ce, quality: () => At, utils: () => Fe });
    var p = {};
    r(p, { bt709: () => g });
    var g = {};
    r(g, { Y: () => v, x: () => x, y: () => b });
    var v = ((y) => (y[y.RED = 0.2126] = "RED", y[y.GREEN = 0.7152] = "GREEN", y[y.BLUE = 0.0722] = "BLUE", y[y.WHITE = 1] = "WHITE", y))(v || {}), x = ((y) => (y[y.RED = 0.64] = "RED", y[y.GREEN = 0.3] = "GREEN", y[y.BLUE = 0.15] = "BLUE", y[y.WHITE = 0.3127] = "WHITE", y))(x || {}), b = ((y) => (y[y.RED = 0.33] = "RED", y[y.GREEN = 0.6] = "GREEN", y[y.BLUE = 0.06] = "BLUE", y[y.WHITE = 0.329] = "WHITE", y))(b || {}), w = {};
    function M(y) {
      return y > 0.04045 ? ((y + 0.055) / 1.055) ** 2.4 : y / 12.92;
    }
    function G(y, ue, pe) {
      return { x: 0.4124 * (y = M(y / 255)) + 0.3576 * (ue = M(ue / 255)) + 0.1805 * (pe = M(pe / 255)), y: 0.2126 * y + 0.7152 * ue + 0.0722 * pe, z: 0.0193 * y + 0.1192 * ue + 0.9505 * pe };
    }
    r(w, { lab2rgb: () => k, lab2xyz: () => ne, rgb2hsl: () => j, rgb2lab: () => $, rgb2xyz: () => G, xyz2lab: () => te, xyz2rgb: () => he });
    var F = {};
    function V(y) {
      return y * (Math.PI / 180);
    }
    function q(y, ue, pe) {
      let ve = y;
      return ve < ue && (ve = ue), ve < pe && (ve = pe), ve;
    }
    function I(y, ue, pe) {
      let ve = y;
      return ve > ue && (ve = ue), ve > pe && (ve = pe), ve;
    }
    function _(y, ue, pe) {
      return y > pe && (y = pe), y < ue && (y = ue), 0 | y;
    }
    function R(y) {
      return (y = Math.round(y)) > 255 ? y = 255 : y < 0 && (y = 0), y;
    }
    function W(y) {
      return y > 255 ? y = 255 : y < 0 && (y = 0), y;
    }
    function O(y, ue) {
      const pe = typeof y[0];
      let ve;
      if (pe === "number" || pe === "string") {
        const Te = /* @__PURE__ */ Object.create(null);
        for (let Ue = 0, Le = y.length; Ue < Le; Ue++) {
          const qe = y[Ue];
          Te[qe] || Te[qe] === 0 || (Te[qe] = Ue);
        }
        ve = y.sort((Ue, Le) => ue(Ue, Le) || Te[Ue] - Te[Le]);
      } else {
        const Te = y.slice(0);
        ve = y.sort((Ue, Le) => ue(Ue, Le) || Te.indexOf(Ue) - Te.indexOf(Le));
      }
      return ve;
    }
    function j(y, ue, pe) {
      const ve = I(y, ue, pe), Te = q(y, ue, pe), Ue = Te - ve, Le = (ve + Te) / 510;
      let qe = 0;
      Le > 0 && Le < 1 && (qe = Ue / (Le < 0.5 ? Te + ve : 510 - Te - ve));
      let je = 0;
      return Ue > 0 && (je = Te === y ? (ue - pe) / Ue : Te === ue ? 2 + (pe - y) / Ue : 4 + (y - ue) / Ue, je *= 60, je < 0 && (je += 360)), { h: je, s: qe, l: Le };
    }
    r(F, { degrees2radians: () => V, inRange0to255: () => W, inRange0to255Rounded: () => R, intInRange: () => _, max3: () => q, min3: () => I, stableSort: () => O });
    var U = 0.95047, C = 1, ae = 1.08883;
    function J(y) {
      return y > 8856e-6 ? y ** 0.3333333333333333 : 7.787 * y + 0.13793103448275862;
    }
    function te(y, ue, pe) {
      if (y = J(y / U), ue = J(ue / C), pe = J(pe / ae), 116 * ue - 16 < 0)
        throw new Error("xxx");
      return { L: Math.max(0, 116 * ue - 16), a: 500 * (y - ue), b: 200 * (ue - pe) };
    }
    function $(y, ue, pe) {
      const ve = G(y, ue, pe);
      return te(ve.x, ve.y, ve.z);
    }
    var L = 0.95047, re = 1, z = 1.08883;
    function N(y) {
      return y > 0.206893034 ? y ** 3 : (y - 0.13793103448275862) / 7.787;
    }
    function ne(y, ue, pe) {
      const ve = (y + 16) / 116, Te = ve - pe / 200;
      return { x: L * N(ue / 500 + ve), y: re * N(ve), z: z * N(Te) };
    }
    function le(y) {
      return y > 31308e-7 ? 1.055 * y ** 0.4166666666666667 - 0.055 : 12.92 * y;
    }
    function he(y, ue, pe) {
      const ve = le(3.2406 * y + -1.5372 * ue + -0.4986 * pe), Te = le(-0.9689 * y + 1.8758 * ue + 0.0415 * pe), Ue = le(0.0557 * y + -0.204 * ue + 1.057 * pe);
      return { r: R(255 * ve), g: R(255 * Te), b: R(255 * Ue) };
    }
    function k(y, ue, pe) {
      const ve = ne(y, ue, pe);
      return he(ve.x, ve.y, ve.z);
    }
    var T = {};
    r(T, { AbstractDistanceCalculator: () => B, AbstractEuclidean: () => E, AbstractManhattan: () => be, CIE94GraphicArts: () => c, CIE94Textiles: () => h, CIEDE2000: () => D, CMetric: () => ee, Euclidean: () => Q, EuclideanBT709: () => se, EuclideanBT709NoAlpha: () => Y, Manhattan: () => Ee, ManhattanBT709: () => ke, ManhattanNommyde: () => Me, PNGQuant: () => oe });
    var B = class {
      constructor() {
        n(this, "_maxDistance"), n(this, "_whitePoint"), this._setDefaults(), this.setWhitePoint(255, 255, 255, 255);
      }
      setWhitePoint(y, ue, pe, ve) {
        this._whitePoint = { r: y > 0 ? 255 / y : 0, g: ue > 0 ? 255 / ue : 0, b: pe > 0 ? 255 / pe : 0, a: ve > 0 ? 255 / ve : 0 }, this._maxDistance = this.calculateRaw(y, ue, pe, ve, 0, 0, 0, 0);
      }
      calculateNormalized(y, ue) {
        return this.calculateRaw(y.r, y.g, y.b, y.a, ue.r, ue.g, ue.b, ue.a) / this._maxDistance;
      }
    }, K = class extends B {
      calculateRaw(y, ue, pe, ve, Te, Ue, Le, qe) {
        const je = $(W(y * this._whitePoint.r), W(ue * this._whitePoint.g), W(pe * this._whitePoint.b)), et = $(W(Te * this._whitePoint.r), W(Ue * this._whitePoint.g), W(Le * this._whitePoint.b)), Ve = je.L - et.L, Xe = je.a - et.a, ft = je.b - et.b, xt = Math.sqrt(je.a * je.a + je.b * je.b), _t = xt - Math.sqrt(et.a * et.a + et.b * et.b);
        let ct = Xe * Xe + ft * ft - _t * _t;
        ct = ct < 0 ? 0 : Math.sqrt(ct);
        const dt = (qe - ve) * this._whitePoint.a * this._kA;
        return Math.sqrt((Ve / this._Kl) ** 2 + (_t / (1 + this._K1 * xt)) ** 2 + (ct / (1 + this._K2 * xt)) ** 2 + dt ** 2);
      }
    }, h = class extends K {
      _setDefaults() {
        this._Kl = 2, this._K1 = 0.048, this._K2 = 0.014, this._kA = 12.5 / 255;
      }
    }, c = class extends K {
      _setDefaults() {
        this._Kl = 1, this._K1 = 0.045, this._K2 = 0.015, this._kA = 25 / 255;
      }
    }, m = class extends B {
      _setDefaults() {
      }
      static _calculatehp(y, ue) {
        const pe = Math.atan2(y, ue);
        return pe >= 0 ? pe : pe + m._deg360InRad;
      }
      static _calculateRT(y, ue) {
        const pe = ue ** 7, ve = 2 * Math.sqrt(pe / (pe + m._pow25to7)), Te = m._deg30InRad * Math.exp(-(((y - m._deg275InRad) / m._deg25InRad) ** 2));
        return -Math.sin(2 * Te) * ve;
      }
      static _calculateT(y) {
        return 1 - 0.17 * Math.cos(y - m._deg30InRad) + 0.24 * Math.cos(2 * y) + 0.32 * Math.cos(3 * y + m._deg6InRad) - 0.2 * Math.cos(4 * y - m._deg63InRad);
      }
      static _calculate_ahp(y, ue, pe, ve) {
        const Te = pe + ve;
        return y === 0 ? Te : ue <= m._deg180InRad ? Te / 2 : Te < m._deg360InRad ? (Te + m._deg360InRad) / 2 : (Te - m._deg360InRad) / 2;
      }
      static _calculate_dHp(y, ue, pe, ve) {
        let Te;
        return Te = y === 0 ? 0 : ue <= m._deg180InRad ? pe - ve : pe <= ve ? pe - ve + m._deg360InRad : pe - ve - m._deg360InRad, 2 * Math.sqrt(y) * Math.sin(Te / 2);
      }
      calculateRaw(y, ue, pe, ve, Te, Ue, Le, qe) {
        const je = $(W(y * this._whitePoint.r), W(ue * this._whitePoint.g), W(pe * this._whitePoint.b)), et = $(W(Te * this._whitePoint.r), W(Ue * this._whitePoint.g), W(Le * this._whitePoint.b)), Ve = (qe - ve) * this._whitePoint.a * m._kA, Xe = this.calculateRawInLab(je, et);
        return Math.sqrt(Xe + Ve * Ve);
      }
      calculateRawInLab(y, ue) {
        const pe = y.L, ve = y.a, Te = y.b, Ue = ue.L, Le = ue.a, qe = ue.b, je = ((Math.sqrt(ve * ve + Te * Te) + Math.sqrt(Le * Le + qe * qe)) / 2) ** 7, et = 0.5 * (1 - Math.sqrt(je / (je + m._pow25to7))), Ve = (1 + et) * ve, Xe = (1 + et) * Le, ft = Math.sqrt(Ve * Ve + Te * Te), xt = Math.sqrt(Xe * Xe + qe * qe), _t = ft * xt, ct = m._calculatehp(Te, Ve), dt = m._calculatehp(qe, Xe), jt = Math.abs(ct - dt), Bt = Ue - pe, Ht = xt - ft, Wt = m._calculate_dHp(_t, jt, dt, ct), Zt = m._calculate_ahp(_t, jt, ct, dt), $t = (ft + xt) / 2, gt = ((pe + Ue) / 2 - 50) ** 2, Qt = Ht / (1 + 0.045 * $t), fr = Wt / (1 + 0.015 * m._calculateT(Zt) * $t);
        return (Bt / (1 + 0.015 * gt / Math.sqrt(20 + gt))) ** 2 + Qt ** 2 + fr ** 2 + m._calculateRT(Zt, $t) * Qt * fr;
      }
    }, D = m;
    n(D, "_kA", 0.09803921568627451), n(D, "_pow25to7", 6103515625), n(D, "_deg360InRad", V(360)), n(D, "_deg180InRad", V(180)), n(D, "_deg30InRad", V(30)), n(D, "_deg6InRad", V(6)), n(D, "_deg63InRad", V(63)), n(D, "_deg275InRad", V(275)), n(D, "_deg25InRad", V(25));
    var ee = class extends B {
      calculateRaw(y, ue, pe, ve, Te, Ue, Le, qe) {
        const je = (y + Te) / 2 * this._whitePoint.r, et = (y - Te) * this._whitePoint.r, Ve = (ue - Ue) * this._whitePoint.g, Xe = (pe - Le) * this._whitePoint.b, ft = ((512 + je) * et * et >> 8) + 4 * Ve * Ve + ((767 - je) * Xe * Xe >> 8), xt = (qe - ve) * this._whitePoint.a;
        return Math.sqrt(ft + xt * xt);
      }
      _setDefaults() {
      }
    }, E = class extends B {
      calculateRaw(y, ue, pe, ve, Te, Ue, Le, qe) {
        const je = Te - y, et = Ue - ue, Ve = Le - pe, Xe = qe - ve;
        return Math.sqrt(this._kR * je * je + this._kG * et * et + this._kB * Ve * Ve + this._kA * Xe * Xe);
      }
    }, Q = class extends E {
      _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
      }
    }, se = class extends E {
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
      }
    }, Y = class extends E {
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 0;
      }
    }, be = class extends B {
      calculateRaw(y, ue, pe, ve, Te, Ue, Le, qe) {
        let je = Te - y, et = Ue - ue, Ve = Le - pe, Xe = qe - ve;
        return je < 0 && (je = 0 - je), et < 0 && (et = 0 - et), Ve < 0 && (Ve = 0 - Ve), Xe < 0 && (Xe = 0 - Xe), this._kR * je + this._kG * et + this._kB * Ve + this._kA * Xe;
      }
    }, Ee = class extends be {
      _setDefaults() {
        this._kR = 1, this._kG = 1, this._kB = 1, this._kA = 1;
      }
    }, Me = class extends be {
      _setDefaults() {
        this._kR = 0.4984, this._kG = 0.8625, this._kB = 0.2979, this._kA = 1;
      }
    }, ke = class extends be {
      _setDefaults() {
        this._kR = 0.2126, this._kG = 0.7152, this._kB = 0.0722, this._kA = 1;
      }
    }, oe = class extends B {
      calculateRaw(y, ue, pe, ve, Te, Ue, Le, qe) {
        const je = (qe - ve) * this._whitePoint.a;
        return this._colordifferenceCh(y * this._whitePoint.r, Te * this._whitePoint.r, je) + this._colordifferenceCh(ue * this._whitePoint.g, Ue * this._whitePoint.g, je) + this._colordifferenceCh(pe * this._whitePoint.b, Le * this._whitePoint.b, je);
      }
      _colordifferenceCh(y, ue, pe) {
        const ve = y - ue, Te = ve + pe;
        return ve * ve + Te * Te;
      }
      _setDefaults() {
      }
    }, ce = {};
    r(ce, { AbstractPaletteQuantizer: () => xe, ColorHistogram: () => Je, NeuQuant: () => de, NeuQuantFloat: () => rt, RGBQuant: () => Ie, WuColorCube: () => wt, WuQuant: () => kt });
    var xe = class {
      quantizeSync() {
        for (const y of this.quantize())
          if (y.palette)
            return y.palette;
        throw new Error("unreachable");
      }
    }, Ce = class {
      constructor() {
        n(this, "r"), n(this, "g"), n(this, "b"), n(this, "a"), n(this, "uint32"), n(this, "rgba"), this.uint32 = -1 >>> 0, this.r = this.g = this.b = this.a = 0, this.rgba = new Array(4), this.rgba[0] = 0, this.rgba[1] = 0, this.rgba[2] = 0, this.rgba[3] = 0;
      }
      static createByQuadruplet(y) {
        const ue = new Ce();
        return ue.r = 0 | y[0], ue.g = 0 | y[1], ue.b = 0 | y[2], ue.a = 0 | y[3], ue._loadUINT32(), ue._loadQuadruplet(), ue;
      }
      static createByRGBA(y, ue, pe, ve) {
        const Te = new Ce();
        return Te.r = 0 | y, Te.g = 0 | ue, Te.b = 0 | pe, Te.a = 0 | ve, Te._loadUINT32(), Te._loadQuadruplet(), Te;
      }
      static createByUint32(y) {
        const ue = new Ce();
        return ue.uint32 = y >>> 0, ue._loadRGBA(), ue._loadQuadruplet(), ue;
      }
      from(y) {
        this.r = y.r, this.g = y.g, this.b = y.b, this.a = y.a, this.uint32 = y.uint32, this.rgba[0] = y.r, this.rgba[1] = y.g, this.rgba[2] = y.b, this.rgba[3] = y.a;
      }
      getLuminosity(y) {
        let ue = this.r, pe = this.g, ve = this.b;
        return y && (ue = Math.min(255, 255 - this.a + this.a * ue / 255), pe = Math.min(255, 255 - this.a + this.a * pe / 255), ve = Math.min(255, 255 - this.a + this.a * ve / 255)), 0.2126 * ue + 0.7152 * pe + 0.0722 * ve;
      }
      _loadUINT32() {
        this.uint32 = (this.a << 24 | this.b << 16 | this.g << 8 | this.r) >>> 0;
      }
      _loadRGBA() {
        this.r = 255 & this.uint32, this.g = this.uint32 >>> 8 & 255, this.b = this.uint32 >>> 16 & 255, this.a = this.uint32 >>> 24 & 255;
      }
      _loadQuadruplet() {
        this.rgba[0] = this.r, this.rgba[1] = this.g, this.rgba[2] = this.b, this.rgba[3] = this.a;
      }
    }, _e = class {
      constructor() {
        n(this, "_pointArray"), n(this, "_width"), n(this, "_height"), this._width = 0, this._height = 0, this._pointArray = [];
      }
      getWidth() {
        return this._width;
      }
      getHeight() {
        return this._height;
      }
      setWidth(y) {
        this._width = y;
      }
      setHeight(y) {
        this._height = y;
      }
      getPointArray() {
        return this._pointArray;
      }
      clone() {
        const y = new _e();
        y._width = this._width, y._height = this._height;
        for (let ue = 0, pe = this._pointArray.length; ue < pe; ue++)
          y._pointArray[ue] = Ce.createByUint32(0 | this._pointArray[ue].uint32);
        return y;
      }
      toUint32Array() {
        const y = this._pointArray.length, ue = new Uint32Array(y);
        for (let pe = 0; pe < y; pe++)
          ue[pe] = this._pointArray[pe].uint32;
        return ue;
      }
      toUint8Array() {
        return new Uint8Array(this.toUint32Array().buffer);
      }
      static fromHTMLImageElement(y) {
        const ue = y.naturalWidth, pe = y.naturalHeight, ve = document.createElement("canvas");
        return ve.width = ue, ve.height = pe, ve.getContext("2d").drawImage(y, 0, 0, ue, pe, 0, 0, ue, pe), _e.fromHTMLCanvasElement(ve);
      }
      static fromHTMLCanvasElement(y) {
        const ue = y.width, pe = y.height, ve = y.getContext("2d").getImageData(0, 0, ue, pe);
        return _e.fromImageData(ve);
      }
      static fromImageData(y) {
        const ue = y.width, pe = y.height;
        return _e.fromUint8Array(y.data, ue, pe);
      }
      static fromUint8Array(y, ue, pe) {
        switch (Object.prototype.toString.call(y)) {
          case "[object Uint8ClampedArray]":
          case "[object Uint8Array]":
            break;
          default:
            y = new Uint8Array(y);
        }
        const ve = new Uint32Array(y.buffer);
        return _e.fromUint32Array(ve, ue, pe);
      }
      static fromUint32Array(y, ue, pe) {
        const ve = new _e();
        ve._width = ue, ve._height = pe;
        for (let Te = 0, Ue = y.length; Te < Ue; Te++)
          ve._pointArray[Te] = Ce.createByUint32(0 | y[Te]);
        return ve;
      }
      static fromBuffer(y, ue, pe) {
        const ve = new Uint32Array(y.buffer, y.byteOffset, y.byteLength / Uint32Array.BYTES_PER_ELEMENT);
        return _e.fromUint32Array(ve, ue, pe);
      }
    };
    function Be(y, ue) {
      const pe = 360 / ue;
      for (let ve = 1, Te = pe - pe / 2; ve < ue; ve++, Te += pe)
        if (y >= Te && y < Te + pe)
          return ve;
      return 0;
    }
    var Pe = class {
      constructor() {
        n(this, "_pointContainer"), n(this, "_pointArray", []), n(this, "_i32idx", {}), this._pointContainer = new _e(), this._pointContainer.setHeight(1), this._pointArray = this._pointContainer.getPointArray();
      }
      add(y) {
        this._pointArray.push(y), this._pointContainer.setWidth(this._pointArray.length);
      }
      has(y) {
        for (let ue = this._pointArray.length - 1; ue >= 0; ue--)
          if (y.uint32 === this._pointArray[ue].uint32)
            return !0;
        return !1;
      }
      getNearestColor(y, ue) {
        return this._pointArray[0 | this._getNearestIndex(y, ue)];
      }
      getPointContainer() {
        return this._pointContainer;
      }
      _nearestPointFromCache(y) {
        return typeof this._i32idx[y] == "number" ? this._i32idx[y] : -1;
      }
      _getNearestIndex(y, ue) {
        let pe = this._nearestPointFromCache("" + ue.uint32);
        if (pe >= 0)
          return pe;
        let ve = Number.MAX_VALUE;
        pe = 0;
        for (let Te = 0, Ue = this._pointArray.length; Te < Ue; Te++) {
          const Le = this._pointArray[Te], qe = y.calculateRaw(ue.r, ue.g, ue.b, ue.a, Le.r, Le.g, Le.b, Le.a);
          qe < ve && (ve = qe, pe = Te);
        }
        return this._i32idx[ue.uint32] = pe, pe;
      }
      sort() {
        this._i32idx = {}, this._pointArray.sort((y, ue) => {
          const pe = j(y.r, y.g, y.b), ve = j(ue.r, ue.g, ue.b), Te = y.r === y.g && y.g === y.b ? 0 : 1 + Be(pe.h, 10), Ue = (ue.r === ue.g && ue.g === ue.b ? 0 : 1 + Be(ve.h, 10)) - Te;
          if (Ue)
            return -Ue;
          const Le = y.getLuminosity(!0), qe = ue.getLuminosity(!0);
          if (qe - Le != 0)
            return qe - Le;
          const je = (100 * ve.s | 0) - (100 * pe.s | 0);
          return je ? -je : 0;
        });
      }
    }, Fe = {};
    r(Fe, { HueStatistics: () => Qe, Palette: () => Pe, Point: () => Ce, PointContainer: () => _e, ProgressTracker: () => P, arithmetic: () => F });
    var We = class {
      constructor() {
        n(this, "num", 0), n(this, "cols", []);
      }
    }, Qe = class {
      constructor(y, ue) {
        n(this, "_numGroups"), n(this, "_minCols"), n(this, "_stats"), n(this, "_groupsFull"), this._numGroups = y, this._minCols = ue, this._stats = [];
        for (let pe = 0; pe <= y; pe++)
          this._stats[pe] = new We();
        this._groupsFull = 0;
      }
      check(y) {
        this._groupsFull === this._numGroups + 1 && (this.check = () => {
        });
        const ue = 255 & y, pe = y >>> 8 & 255, ve = y >>> 16 & 255, Te = ue === pe && pe === ve ? 0 : 1 + Be(j(ue, pe, ve).h, this._numGroups), Ue = this._stats[Te], Le = this._minCols;
        Ue.num++, Ue.num > Le || (Ue.num === Le && this._groupsFull++, Ue.num <= Le && this._stats[Te].cols.push(y));
      }
      injectIntoDictionary(y) {
        for (let ue = 0; ue <= this._numGroups; ue++)
          this._stats[ue].num <= this._minCols && this._stats[ue].cols.forEach((pe) => {
            y[pe] ? y[pe]++ : y[pe] = 1;
          });
      }
      injectIntoArray(y) {
        for (let ue = 0; ue <= this._numGroups; ue++)
          this._stats[ue].num <= this._minCols && this._stats[ue].cols.forEach((pe) => {
            y.indexOf(pe) === -1 && y.push(pe);
          });
      }
    }, lt = class {
      constructor(y, ue) {
        n(this, "progress"), n(this, "_step"), n(this, "_range"), n(this, "_last"), n(this, "_progressRange"), this._range = y, this._progressRange = ue, this._step = Math.max(1, this._range / (lt.steps + 1) | 0), this._last = -this._step, this.progress = 0;
      }
      shouldNotify(y) {
        return y - this._last >= this._step && (this._last = y, this.progress = Math.min(this._progressRange * this._last / this._range, this._progressRange), !0);
      }
    }, P = lt;
    n(P, "steps", 100);
    var we = class {
      constructor(y) {
        n(this, "r"), n(this, "g"), n(this, "b"), n(this, "a"), this.r = this.g = this.b = this.a = y;
      }
      toPoint() {
        return Ce.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
      }
      subtract(y, ue, pe, ve) {
        this.r -= 0 | y, this.g -= 0 | ue, this.b -= 0 | pe, this.a -= 0 | ve;
      }
    }, X = class extends xe {
      constructor(y, ue = 256) {
        super(), n(this, "_pointArray"), n(this, "_networkSize"), n(this, "_network"), n(this, "_sampleFactor"), n(this, "_radPower"), n(this, "_freq"), n(this, "_bias"), n(this, "_distance"), this._distance = y, this._pointArray = [], this._sampleFactor = 1, this._networkSize = ue, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
      }
      sample(y) {
        this._pointArray = this._pointArray.concat(y.getPointArray());
      }
      *quantize() {
        this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
      }
      _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let y = 0; y < this._networkSize; y++)
          this._network[y] = new we((y << 11) / this._networkSize | 0), this._freq[y] = X._initialBias / this._networkSize | 0, this._bias[y] = 0;
      }
      *_learn() {
        let y = this._sampleFactor;
        const ue = this._pointArray.length;
        ue < X._minpicturebytes && (y = 1);
        const pe = 30 + (y - 1) / 3 | 0, ve = ue / y | 0;
        let Te, Ue = ve / X._nCycles | 0, Le = X._initAlpha, qe = (this._networkSize >> 3) * X._radiusBias, je = qe >> X._radiusBiasShift;
        je <= 1 && (je = 0);
        for (let Ve = 0; Ve < je; Ve++)
          this._radPower[Ve] = Le * ((je * je - Ve * Ve) * X._radBias / (je * je)) >>> 0;
        Te = ue < X._minpicturebytes ? 1 : ue % X._prime1 != 0 ? X._prime1 : ue % X._prime2 != 0 ? X._prime2 : ue % X._prime3 != 0 ? X._prime3 : X._prime4;
        const et = new P(ve, 99);
        for (let Ve = 0, Xe = 0; Ve < ve; ) {
          et.shouldNotify(Ve) && (yield { progress: et.progress });
          const ft = this._pointArray[Xe], xt = ft.b << 3, _t = ft.g << 3, ct = ft.r << 3, dt = ft.a << 3, jt = this._contest(xt, _t, ct, dt);
          if (this._alterSingle(Le, jt, xt, _t, ct, dt), je !== 0 && this._alterNeighbour(je, jt, xt, _t, ct, dt), Xe += Te, Xe >= ue && (Xe -= ue), Ve++, Ue === 0 && (Ue = 1), Ve % Ue == 0) {
            Le -= Le / pe | 0, qe -= qe / X._radiusDecrease | 0, je = qe >> X._radiusBiasShift, je <= 1 && (je = 0);
            for (let Bt = 0; Bt < je; Bt++)
              this._radPower[Bt] = Le * ((je * je - Bt * Bt) * X._radBias / (je * je)) >>> 0;
          }
        }
      }
      _buildPalette() {
        const y = new Pe();
        return this._network.forEach((ue) => {
          y.add(ue.toPoint());
        }), y.sort(), y;
      }
      _alterNeighbour(y, ue, pe, ve, Te, Ue) {
        let Le = ue - y;
        Le < -1 && (Le = -1);
        let qe = ue + y;
        qe > this._networkSize && (qe = this._networkSize);
        let je = ue + 1, et = ue - 1, Ve = 1;
        for (; je < qe || et > Le; ) {
          const Xe = this._radPower[Ve++] / X._alphaRadBias;
          if (je < qe) {
            const ft = this._network[je++];
            ft.subtract(Xe * (ft.r - Te), Xe * (ft.g - ve), Xe * (ft.b - pe), Xe * (ft.a - Ue));
          }
          if (et > Le) {
            const ft = this._network[et--];
            ft.subtract(Xe * (ft.r - Te), Xe * (ft.g - ve), Xe * (ft.b - pe), Xe * (ft.a - Ue));
          }
        }
      }
      _alterSingle(y, ue, pe, ve, Te, Ue) {
        y /= X._initAlpha;
        const Le = this._network[ue];
        Le.subtract(y * (Le.r - Te), y * (Le.g - ve), y * (Le.b - pe), y * (Le.a - Ue));
      }
      _contest(y, ue, pe, ve) {
        let Te = 2147483647, Ue = Te, Le = -1, qe = Le;
        for (let je = 0; je < this._networkSize; je++) {
          const et = this._network[je], Ve = 8160 * this._distance.calculateNormalized(et, { r: pe, g: ue, b: y, a: ve }) | 0;
          Ve < Te && (Te = Ve, Le = je);
          const Xe = Ve - (this._bias[je] >> X._initialBiasShift - 3);
          Xe < Ue && (Ue = Xe, qe = je);
          const ft = this._freq[je] >> X._betaShift;
          this._freq[je] -= ft, this._bias[je] += ft << X._gammaShift;
        }
        return this._freq[Le] += X._beta, this._bias[Le] -= X._betaGamma, qe;
      }
    }, de = X;
    n(de, "_prime1", 499), n(de, "_prime2", 491), n(de, "_prime3", 487), n(de, "_prime4", 503), n(de, "_minpicturebytes", X._prime4), n(de, "_nCycles", 100), n(de, "_initialBiasShift", 16), n(de, "_initialBias", 1 << X._initialBiasShift), n(de, "_gammaShift", 10), n(de, "_betaShift", 10), n(de, "_beta", X._initialBias >> X._betaShift), n(de, "_betaGamma", X._initialBias << X._gammaShift - X._betaShift), n(de, "_radiusBiasShift", 6), n(de, "_radiusBias", 1 << X._radiusBiasShift), n(de, "_radiusDecrease", 30), n(de, "_alphaBiasShift", 10), n(de, "_initAlpha", 1 << X._alphaBiasShift), n(de, "_radBiasShift", 8), n(de, "_radBias", 1 << X._radBiasShift), n(de, "_alphaRadBiasShift", X._alphaBiasShift + X._radBiasShift), n(de, "_alphaRadBias", 1 << X._alphaRadBiasShift);
    var Ze = class {
      constructor(y) {
        n(this, "r"), n(this, "g"), n(this, "b"), n(this, "a"), this.r = this.g = this.b = this.a = y;
      }
      toPoint() {
        return Ce.createByRGBA(this.r >> 3, this.g >> 3, this.b >> 3, this.a >> 3);
      }
      subtract(y, ue, pe, ve) {
        this.r -= y, this.g -= ue, this.b -= pe, this.a -= ve;
      }
    }, Re = class extends xe {
      constructor(y, ue = 256) {
        super(), n(this, "_pointArray"), n(this, "_networkSize"), n(this, "_network"), n(this, "_sampleFactor"), n(this, "_radPower"), n(this, "_freq"), n(this, "_bias"), n(this, "_distance"), this._distance = y, this._pointArray = [], this._sampleFactor = 1, this._networkSize = ue, this._distance.setWhitePoint(2040, 2040, 2040, 2040);
      }
      sample(y) {
        this._pointArray = this._pointArray.concat(y.getPointArray());
      }
      *quantize() {
        this._init(), yield* this._learn(), yield { palette: this._buildPalette(), progress: 100 };
      }
      _init() {
        this._freq = [], this._bias = [], this._radPower = [], this._network = [];
        for (let y = 0; y < this._networkSize; y++)
          this._network[y] = new Ze((y << 11) / this._networkSize), this._freq[y] = Re._initialBias / this._networkSize, this._bias[y] = 0;
      }
      *_learn() {
        let y = this._sampleFactor;
        const ue = this._pointArray.length;
        ue < Re._minpicturebytes && (y = 1);
        const pe = 30 + (y - 1) / 3, ve = ue / y;
        let Te, Ue = ve / Re._nCycles | 0, Le = Re._initAlpha, qe = (this._networkSize >> 3) * Re._radiusBias, je = qe >> Re._radiusBiasShift;
        je <= 1 && (je = 0);
        for (let Ve = 0; Ve < je; Ve++)
          this._radPower[Ve] = Le * ((je * je - Ve * Ve) * Re._radBias / (je * je));
        Te = ue < Re._minpicturebytes ? 1 : ue % Re._prime1 != 0 ? Re._prime1 : ue % Re._prime2 != 0 ? Re._prime2 : ue % Re._prime3 != 0 ? Re._prime3 : Re._prime4;
        const et = new P(ve, 99);
        for (let Ve = 0, Xe = 0; Ve < ve; ) {
          et.shouldNotify(Ve) && (yield { progress: et.progress });
          const ft = this._pointArray[Xe], xt = ft.b << 3, _t = ft.g << 3, ct = ft.r << 3, dt = ft.a << 3, jt = this._contest(xt, _t, ct, dt);
          if (this._alterSingle(Le, jt, xt, _t, ct, dt), je !== 0 && this._alterNeighbour(je, jt, xt, _t, ct, dt), Xe += Te, Xe >= ue && (Xe -= ue), Ve++, Ue === 0 && (Ue = 1), Ve % Ue == 0) {
            Le -= Le / pe, qe -= qe / Re._radiusDecrease, je = qe >> Re._radiusBiasShift, je <= 1 && (je = 0);
            for (let Bt = 0; Bt < je; Bt++)
              this._radPower[Bt] = Le * ((je * je - Bt * Bt) * Re._radBias / (je * je));
          }
        }
      }
      _buildPalette() {
        const y = new Pe();
        return this._network.forEach((ue) => {
          y.add(ue.toPoint());
        }), y.sort(), y;
      }
      _alterNeighbour(y, ue, pe, ve, Te, Ue) {
        let Le = ue - y;
        Le < -1 && (Le = -1);
        let qe = ue + y;
        qe > this._networkSize && (qe = this._networkSize);
        let je = ue + 1, et = ue - 1, Ve = 1;
        for (; je < qe || et > Le; ) {
          const Xe = this._radPower[Ve++] / Re._alphaRadBias;
          if (je < qe) {
            const ft = this._network[je++];
            ft.subtract(Xe * (ft.r - Te), Xe * (ft.g - ve), Xe * (ft.b - pe), Xe * (ft.a - Ue));
          }
          if (et > Le) {
            const ft = this._network[et--];
            ft.subtract(Xe * (ft.r - Te), Xe * (ft.g - ve), Xe * (ft.b - pe), Xe * (ft.a - Ue));
          }
        }
      }
      _alterSingle(y, ue, pe, ve, Te, Ue) {
        y /= Re._initAlpha;
        const Le = this._network[ue];
        Le.subtract(y * (Le.r - Te), y * (Le.g - ve), y * (Le.b - pe), y * (Le.a - Ue));
      }
      _contest(y, ue, pe, ve) {
        let Te = 2147483647, Ue = Te, Le = -1, qe = Le;
        for (let je = 0; je < this._networkSize; je++) {
          const et = this._network[je], Ve = 8160 * this._distance.calculateNormalized(et, { r: pe, g: ue, b: y, a: ve });
          Ve < Te && (Te = Ve, Le = je);
          const Xe = Ve - (this._bias[je] >> Re._initialBiasShift - 3);
          Xe < Ue && (Ue = Xe, qe = je);
          const ft = this._freq[je] >> Re._betaShift;
          this._freq[je] -= ft, this._bias[je] += ft << Re._gammaShift;
        }
        return this._freq[Le] += Re._beta, this._bias[Le] -= Re._betaGamma, qe;
      }
    }, rt = Re;
    n(rt, "_prime1", 499), n(rt, "_prime2", 491), n(rt, "_prime3", 487), n(rt, "_prime4", 503), n(rt, "_minpicturebytes", Re._prime4), n(rt, "_nCycles", 100), n(rt, "_initialBiasShift", 16), n(rt, "_initialBias", 1 << Re._initialBiasShift), n(rt, "_gammaShift", 10), n(rt, "_betaShift", 10), n(rt, "_beta", Re._initialBias >> Re._betaShift), n(rt, "_betaGamma", Re._initialBias << Re._gammaShift - Re._betaShift), n(rt, "_radiusBiasShift", 6), n(rt, "_radiusBias", 1 << Re._radiusBiasShift), n(rt, "_radiusDecrease", 30), n(rt, "_alphaBiasShift", 10), n(rt, "_initAlpha", 1 << Re._alphaBiasShift), n(rt, "_radBiasShift", 8), n(rt, "_radBias", 1 << Re._radBiasShift), n(rt, "_alphaRadBiasShift", Re._alphaBiasShift + Re._radBiasShift), n(rt, "_alphaRadBias", 1 << Re._alphaRadBiasShift);
    var De = class {
      constructor(y, ue) {
        n(this, "_method"), n(this, "_hueStats"), n(this, "_histogram"), n(this, "_initColors"), n(this, "_minHueCols"), this._method = y, this._minHueCols = ue << 2, this._initColors = ue << 2, this._hueStats = new Qe(De._hueGroups, this._minHueCols), this._histogram = /* @__PURE__ */ Object.create(null);
      }
      sample(y) {
        switch (this._method) {
          case 1:
            this._colorStats1D(y);
            break;
          case 2:
            this._colorStats2D(y);
        }
      }
      getImportanceSortedColorsIDXI32() {
        const y = O(Object.keys(this._histogram), (pe, ve) => this._histogram[ve] - this._histogram[pe]);
        if (y.length === 0)
          return [];
        let ue;
        switch (this._method) {
          case 1:
            const pe = Math.min(y.length, this._initColors), ve = y[pe - 1], Te = this._histogram[ve];
            ue = y.slice(0, pe);
            let Ue = pe;
            const Le = y.length;
            for (; Ue < Le && this._histogram[y[Ue]] === Te; )
              ue.push(y[Ue++]);
            this._hueStats.injectIntoArray(ue);
            break;
          case 2:
            ue = y;
            break;
          default:
            throw new Error("Incorrect method");
        }
        return ue.map((pe) => +pe);
      }
      _colorStats1D(y) {
        const ue = this._histogram, pe = y.getPointArray(), ve = pe.length;
        for (let Te = 0; Te < ve; Te++) {
          const Ue = pe[Te].uint32;
          this._hueStats.check(Ue), Ue in ue ? ue[Ue]++ : ue[Ue] = 1;
        }
      }
      _colorStats2D(y) {
        const ue = y.getWidth(), pe = y.getHeight(), ve = y.getPointArray(), Te = De._boxSize[0], Ue = De._boxSize[1], Le = Te * Ue, qe = this._makeBoxes(ue, pe, Te, Ue), je = this._histogram;
        qe.forEach((et) => {
          let Ve = Math.round(et.w * et.h / Le) * De._boxPixels;
          Ve < 2 && (Ve = 2);
          const Xe = {};
          this._iterateBox(et, ue, (ft) => {
            const xt = ve[ft].uint32;
            this._hueStats.check(xt), xt in je ? je[xt]++ : xt in Xe ? ++Xe[xt] >= Ve && (je[xt] = Xe[xt]) : Xe[xt] = 1;
          });
        }), this._hueStats.injectIntoDictionary(je);
      }
      _iterateBox(y, ue, pe) {
        const ve = y, Te = ve.y * ue + ve.x, Ue = (ve.y + ve.h - 1) * ue + (ve.x + ve.w - 1), Le = ue - ve.w + 1;
        let qe = 0, je = Te;
        do
          pe.call(this, je), je += ++qe % ve.w == 0 ? Le : 1;
        while (je <= Ue);
      }
      _makeBoxes(y, ue, pe, ve) {
        const Te = y % pe, Ue = ue % ve, Le = y - Te, qe = ue - Ue, je = [];
        for (let et = 0; et < ue; et += ve)
          for (let Ve = 0; Ve < y; Ve += pe)
            je.push({ x: Ve, y: et, w: Ve === Le ? Te : pe, h: et === qe ? Ue : ve });
        return je;
      }
    }, Je = De;
    n(Je, "_boxSize", [64, 64]), n(Je, "_boxPixels", 2), n(Je, "_hueGroups", 10);
    var Ne = class {
      constructor(y, ue, pe) {
        n(this, "index"), n(this, "color"), n(this, "distance"), this.index = y, this.color = ue, this.distance = pe;
      }
    }, Ie = class extends xe {
      constructor(y, ue = 256, pe = 2) {
        super(), n(this, "_colors"), n(this, "_initialDistance"), n(this, "_distanceIncrement"), n(this, "_histogram"), n(this, "_distance"), this._distance = y, this._colors = ue, this._histogram = new Je(pe, ue), this._initialDistance = 0.01, this._distanceIncrement = 5e-3;
      }
      sample(y) {
        this._histogram.sample(y);
      }
      *quantize() {
        const y = this._histogram.getImportanceSortedColorsIDXI32();
        if (y.length === 0)
          throw new Error("No colors in image");
        yield* this._buildPalette(y);
      }
      *_buildPalette(y) {
        const ue = new Pe(), pe = ue.getPointContainer().getPointArray(), ve = new Array(y.length);
        for (let Ve = 0; Ve < y.length; Ve++)
          pe.push(Ce.createByUint32(y[Ve])), ve[Ve] = 1;
        const Te = pe.length, Ue = [];
        let Le = Te, qe = this._initialDistance;
        const je = new P(Le - this._colors, 99);
        for (; Le > this._colors; ) {
          Ue.length = 0;
          for (let Ve = 0; Ve < Te; Ve++) {
            if (je.shouldNotify(Te - Le) && (yield { progress: je.progress }), ve[Ve] === 0)
              continue;
            const Xe = pe[Ve];
            for (let ft = Ve + 1; ft < Te; ft++) {
              if (ve[ft] === 0)
                continue;
              const xt = pe[ft], _t = this._distance.calculateNormalized(Xe, xt);
              _t < qe && (Ue.push(new Ne(ft, xt, _t)), ve[ft] = 0, Le--);
            }
          }
          qe += Le > 3 * this._colors ? this._initialDistance : this._distanceIncrement;
        }
        if (Le < this._colors) {
          O(Ue, (Xe, ft) => ft.distance - Xe.distance);
          let Ve = 0;
          for (; Le < this._colors && Ve < Ue.length; )
            ve[Ue[Ve].index] = 1, Le++, Ve++;
        }
        let et = pe.length;
        for (let Ve = et - 1; Ve >= 0; Ve--)
          ve[Ve] === 0 && (Ve !== et - 1 && (pe[Ve] = pe[et - 1]), --et);
        pe.length = et, ue.sort(), yield { palette: ue, progress: 100 };
      }
    };
    function at(y) {
      const ue = [];
      for (let pe = 0; pe < y; pe++)
        ue[pe] = 0;
      return ue;
    }
    function st(y, ue, pe, ve) {
      const Te = new Array(y);
      for (let Ue = 0; Ue < y; Ue++) {
        Te[Ue] = new Array(ue);
        for (let Le = 0; Le < ue; Le++) {
          Te[Ue][Le] = new Array(pe);
          for (let qe = 0; qe < pe; qe++) {
            Te[Ue][Le][qe] = new Array(ve);
            for (let je = 0; je < ve; je++)
              Te[Ue][Le][qe][je] = 0;
          }
        }
      }
      return Te;
    }
    function tt(y, ue, pe) {
      const ve = new Array(y);
      for (let Te = 0; Te < y; Te++) {
        ve[Te] = new Array(ue);
        for (let Ue = 0; Ue < ue; Ue++) {
          ve[Te][Ue] = new Array(pe);
          for (let Le = 0; Le < pe; Le++)
            ve[Te][Ue][Le] = 0;
        }
      }
      return ve;
    }
    function mt(y, ue, pe, ve, Te) {
      for (let Ue = 0; Ue < ue; Ue++) {
        y[Ue] = [];
        for (let Le = 0; Le < pe; Le++) {
          y[Ue][Le] = [];
          for (let qe = 0; qe < ve; qe++)
            y[Ue][Le][qe] = Te;
        }
      }
    }
    function It(y, ue, pe) {
      for (let ve = 0; ve < ue; ve++)
        y[ve] = pe;
    }
    var wt = class {
      constructor() {
        n(this, "redMinimum"), n(this, "redMaximum"), n(this, "greenMinimum"), n(this, "greenMaximum"), n(this, "blueMinimum"), n(this, "blueMaximum"), n(this, "volume"), n(this, "alphaMinimum"), n(this, "alphaMaximum");
      }
    }, ot = class extends xe {
      constructor(y, ue = 256, pe = 5) {
        super(), n(this, "_reds"), n(this, "_greens"), n(this, "_blues"), n(this, "_alphas"), n(this, "_sums"), n(this, "_weights"), n(this, "_momentsRed"), n(this, "_momentsGreen"), n(this, "_momentsBlue"), n(this, "_momentsAlpha"), n(this, "_moments"), n(this, "_table"), n(this, "_pixels"), n(this, "_cubes"), n(this, "_colors"), n(this, "_significantBitsPerChannel"), n(this, "_maxSideIndex"), n(this, "_alphaMaxSideIndex"), n(this, "_sideSize"), n(this, "_alphaSideSize"), n(this, "_distance"), this._distance = y, this._setQuality(pe), this._initialize(ue);
      }
      sample(y) {
        const ue = y.getPointArray();
        for (let pe = 0, ve = ue.length; pe < ve; pe++)
          this._addColor(ue[pe]);
        this._pixels = this._pixels.concat(ue);
      }
      *quantize() {
        yield* this._preparePalette();
        const y = new Pe();
        for (let ue = 0; ue < this._colors; ue++)
          if (this._sums[ue] > 0) {
            const pe = this._sums[ue], ve = this._reds[ue] / pe, Te = this._greens[ue] / pe, Ue = this._blues[ue] / pe, Le = this._alphas[ue] / pe, qe = Ce.createByRGBA(0 | ve, 0 | Te, 0 | Ue, 0 | Le);
            y.add(qe);
          }
        y.sort(), yield { palette: y, progress: 100 };
      }
      *_preparePalette() {
        yield* this._calculateMoments();
        let y = 0;
        const ue = at(this._colors);
        for (let Le = 1; Le < this._colors; ++Le) {
          this._cut(this._cubes[y], this._cubes[Le]) ? (ue[y] = this._cubes[y].volume > 1 ? this._calculateVariance(this._cubes[y]) : 0, ue[Le] = this._cubes[Le].volume > 1 ? this._calculateVariance(this._cubes[Le]) : 0) : (ue[y] = 0, Le--), y = 0;
          let qe = ue[0];
          for (let je = 1; je <= Le; ++je)
            ue[je] > qe && (qe = ue[je], y = je);
          if (qe <= 0) {
            this._colors = Le + 1;
            break;
          }
        }
        const pe = [], ve = [], Te = [], Ue = [];
        for (let Le = 0; Le < this._colors; ++Le) {
          const qe = ot._volume(this._cubes[Le], this._weights);
          qe > 0 ? (pe[Le] = ot._volume(this._cubes[Le], this._momentsRed) / qe | 0, ve[Le] = ot._volume(this._cubes[Le], this._momentsGreen) / qe | 0, Te[Le] = ot._volume(this._cubes[Le], this._momentsBlue) / qe | 0, Ue[Le] = ot._volume(this._cubes[Le], this._momentsAlpha) / qe | 0) : (pe[Le] = 0, ve[Le] = 0, Te[Le] = 0, Ue[Le] = 0);
        }
        this._reds = at(this._colors + 1), this._greens = at(this._colors + 1), this._blues = at(this._colors + 1), this._alphas = at(this._colors + 1), this._sums = at(this._colors + 1);
        for (let Le = 0, qe = this._pixels.length; Le < qe; Le++) {
          const je = this._pixels[Le];
          let et = -1, Ve = Number.MAX_VALUE;
          for (let Xe = 0; Xe < this._colors; Xe++) {
            const ft = pe[Xe], xt = ve[Xe], _t = Te[Xe], ct = Ue[Xe], dt = this._distance.calculateRaw(ft, xt, _t, ct, je.r, je.g, je.b, je.a);
            dt < Ve && (Ve = dt, et = Xe);
          }
          this._reds[et] += je.r, this._greens[et] += je.g, this._blues[et] += je.b, this._alphas[et] += je.a, this._sums[et]++;
        }
      }
      _addColor(y) {
        const ue = 8 - this._significantBitsPerChannel, pe = 1 + (y.r >> ue), ve = 1 + (y.g >> ue), Te = 1 + (y.b >> ue), Ue = 1 + (y.a >> ue);
        this._weights[Ue][pe][ve][Te]++, this._momentsRed[Ue][pe][ve][Te] += y.r, this._momentsGreen[Ue][pe][ve][Te] += y.g, this._momentsBlue[Ue][pe][ve][Te] += y.b, this._momentsAlpha[Ue][pe][ve][Te] += y.a, this._moments[Ue][pe][ve][Te] += this._table[y.r] + this._table[y.g] + this._table[y.b] + this._table[y.a];
      }
      *_calculateMoments() {
        const y = [], ue = [], pe = [], ve = [], Te = [], Ue = [], Le = tt(this._sideSize, this._sideSize, this._sideSize), qe = tt(this._sideSize, this._sideSize, this._sideSize), je = tt(this._sideSize, this._sideSize, this._sideSize), et = tt(this._sideSize, this._sideSize, this._sideSize), Ve = tt(this._sideSize, this._sideSize, this._sideSize), Xe = tt(this._sideSize, this._sideSize, this._sideSize);
        let ft = 0;
        const xt = new P(this._alphaMaxSideIndex * this._maxSideIndex, 99);
        for (let _t = 1; _t <= this._alphaMaxSideIndex; ++_t) {
          mt(Le, this._sideSize, this._sideSize, this._sideSize, 0), mt(qe, this._sideSize, this._sideSize, this._sideSize, 0), mt(je, this._sideSize, this._sideSize, this._sideSize, 0), mt(et, this._sideSize, this._sideSize, this._sideSize, 0), mt(Ve, this._sideSize, this._sideSize, this._sideSize, 0), mt(Xe, this._sideSize, this._sideSize, this._sideSize, 0);
          for (let ct = 1; ct <= this._maxSideIndex; ++ct, ++ft) {
            xt.shouldNotify(ft) && (yield { progress: xt.progress }), It(y, this._sideSize, 0), It(ue, this._sideSize, 0), It(pe, this._sideSize, 0), It(ve, this._sideSize, 0), It(Te, this._sideSize, 0), It(Ue, this._sideSize, 0);
            for (let dt = 1; dt <= this._maxSideIndex; ++dt) {
              let jt = 0, Bt = 0, Ht = 0, Wt = 0, Zt = 0, $t = 0;
              for (let gt = 1; gt <= this._maxSideIndex; ++gt)
                jt += this._weights[_t][ct][dt][gt], Bt += this._momentsRed[_t][ct][dt][gt], Ht += this._momentsGreen[_t][ct][dt][gt], Wt += this._momentsBlue[_t][ct][dt][gt], Zt += this._momentsAlpha[_t][ct][dt][gt], $t += this._moments[_t][ct][dt][gt], y[gt] += jt, ue[gt] += Bt, pe[gt] += Ht, ve[gt] += Wt, Te[gt] += Zt, Ue[gt] += $t, Le[ct][dt][gt] = Le[ct - 1][dt][gt] + y[gt], qe[ct][dt][gt] = qe[ct - 1][dt][gt] + ue[gt], je[ct][dt][gt] = je[ct - 1][dt][gt] + pe[gt], et[ct][dt][gt] = et[ct - 1][dt][gt] + ve[gt], Ve[ct][dt][gt] = Ve[ct - 1][dt][gt] + Te[gt], Xe[ct][dt][gt] = Xe[ct - 1][dt][gt] + Ue[gt], this._weights[_t][ct][dt][gt] = this._weights[_t - 1][ct][dt][gt] + Le[ct][dt][gt], this._momentsRed[_t][ct][dt][gt] = this._momentsRed[_t - 1][ct][dt][gt] + qe[ct][dt][gt], this._momentsGreen[_t][ct][dt][gt] = this._momentsGreen[_t - 1][ct][dt][gt] + je[ct][dt][gt], this._momentsBlue[_t][ct][dt][gt] = this._momentsBlue[_t - 1][ct][dt][gt] + et[ct][dt][gt], this._momentsAlpha[_t][ct][dt][gt] = this._momentsAlpha[_t - 1][ct][dt][gt] + Ve[ct][dt][gt], this._moments[_t][ct][dt][gt] = this._moments[_t - 1][ct][dt][gt] + Xe[ct][dt][gt];
            }
          }
        }
      }
      static _volumeFloat(y, ue) {
        return ue[y.alphaMaximum][y.redMaximum][y.greenMaximum][y.blueMaximum] - ue[y.alphaMaximum][y.redMaximum][y.greenMinimum][y.blueMaximum] - ue[y.alphaMaximum][y.redMinimum][y.greenMaximum][y.blueMaximum] + ue[y.alphaMaximum][y.redMinimum][y.greenMinimum][y.blueMaximum] - ue[y.alphaMinimum][y.redMaximum][y.greenMaximum][y.blueMaximum] + ue[y.alphaMinimum][y.redMaximum][y.greenMinimum][y.blueMaximum] + ue[y.alphaMinimum][y.redMinimum][y.greenMaximum][y.blueMaximum] - ue[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMaximum] - (ue[y.alphaMaximum][y.redMaximum][y.greenMaximum][y.blueMinimum] - ue[y.alphaMinimum][y.redMaximum][y.greenMaximum][y.blueMinimum] - ue[y.alphaMaximum][y.redMaximum][y.greenMinimum][y.blueMinimum] + ue[y.alphaMinimum][y.redMaximum][y.greenMinimum][y.blueMinimum] - ue[y.alphaMaximum][y.redMinimum][y.greenMaximum][y.blueMinimum] + ue[y.alphaMinimum][y.redMinimum][y.greenMaximum][y.blueMinimum] + ue[y.alphaMaximum][y.redMinimum][y.greenMinimum][y.blueMinimum] - ue[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMinimum]);
      }
      static _volume(y, ue) {
        return 0 | ot._volumeFloat(y, ue);
      }
      static _top(y, ue, pe, ve) {
        let Te;
        switch (ue) {
          case ot._alpha:
            Te = ve[pe][y.redMaximum][y.greenMaximum][y.blueMaximum] - ve[pe][y.redMaximum][y.greenMinimum][y.blueMaximum] - ve[pe][y.redMinimum][y.greenMaximum][y.blueMaximum] + ve[pe][y.redMinimum][y.greenMinimum][y.blueMaximum] - (ve[pe][y.redMaximum][y.greenMaximum][y.blueMinimum] - ve[pe][y.redMaximum][y.greenMinimum][y.blueMinimum] - ve[pe][y.redMinimum][y.greenMaximum][y.blueMinimum] + ve[pe][y.redMinimum][y.greenMinimum][y.blueMinimum]);
            break;
          case ot._red:
            Te = ve[y.alphaMaximum][pe][y.greenMaximum][y.blueMaximum] - ve[y.alphaMaximum][pe][y.greenMinimum][y.blueMaximum] - ve[y.alphaMinimum][pe][y.greenMaximum][y.blueMaximum] + ve[y.alphaMinimum][pe][y.greenMinimum][y.blueMaximum] - (ve[y.alphaMaximum][pe][y.greenMaximum][y.blueMinimum] - ve[y.alphaMaximum][pe][y.greenMinimum][y.blueMinimum] - ve[y.alphaMinimum][pe][y.greenMaximum][y.blueMinimum] + ve[y.alphaMinimum][pe][y.greenMinimum][y.blueMinimum]);
            break;
          case ot._green:
            Te = ve[y.alphaMaximum][y.redMaximum][pe][y.blueMaximum] - ve[y.alphaMaximum][y.redMinimum][pe][y.blueMaximum] - ve[y.alphaMinimum][y.redMaximum][pe][y.blueMaximum] + ve[y.alphaMinimum][y.redMinimum][pe][y.blueMaximum] - (ve[y.alphaMaximum][y.redMaximum][pe][y.blueMinimum] - ve[y.alphaMaximum][y.redMinimum][pe][y.blueMinimum] - ve[y.alphaMinimum][y.redMaximum][pe][y.blueMinimum] + ve[y.alphaMinimum][y.redMinimum][pe][y.blueMinimum]);
            break;
          case ot._blue:
            Te = ve[y.alphaMaximum][y.redMaximum][y.greenMaximum][pe] - ve[y.alphaMaximum][y.redMaximum][y.greenMinimum][pe] - ve[y.alphaMaximum][y.redMinimum][y.greenMaximum][pe] + ve[y.alphaMaximum][y.redMinimum][y.greenMinimum][pe] - (ve[y.alphaMinimum][y.redMaximum][y.greenMaximum][pe] - ve[y.alphaMinimum][y.redMaximum][y.greenMinimum][pe] - ve[y.alphaMinimum][y.redMinimum][y.greenMaximum][pe] + ve[y.alphaMinimum][y.redMinimum][y.greenMinimum][pe]);
            break;
          default:
            throw new Error("impossible");
        }
        return 0 | Te;
      }
      static _bottom(y, ue, pe) {
        switch (ue) {
          case ot._alpha:
            return -pe[y.alphaMinimum][y.redMaximum][y.greenMaximum][y.blueMaximum] + pe[y.alphaMinimum][y.redMaximum][y.greenMinimum][y.blueMaximum] + pe[y.alphaMinimum][y.redMinimum][y.greenMaximum][y.blueMaximum] - pe[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMaximum] - (-pe[y.alphaMinimum][y.redMaximum][y.greenMaximum][y.blueMinimum] + pe[y.alphaMinimum][y.redMaximum][y.greenMinimum][y.blueMinimum] + pe[y.alphaMinimum][y.redMinimum][y.greenMaximum][y.blueMinimum] - pe[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMinimum]);
          case ot._red:
            return -pe[y.alphaMaximum][y.redMinimum][y.greenMaximum][y.blueMaximum] + pe[y.alphaMaximum][y.redMinimum][y.greenMinimum][y.blueMaximum] + pe[y.alphaMinimum][y.redMinimum][y.greenMaximum][y.blueMaximum] - pe[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMaximum] - (-pe[y.alphaMaximum][y.redMinimum][y.greenMaximum][y.blueMinimum] + pe[y.alphaMaximum][y.redMinimum][y.greenMinimum][y.blueMinimum] + pe[y.alphaMinimum][y.redMinimum][y.greenMaximum][y.blueMinimum] - pe[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMinimum]);
          case ot._green:
            return -pe[y.alphaMaximum][y.redMaximum][y.greenMinimum][y.blueMaximum] + pe[y.alphaMaximum][y.redMinimum][y.greenMinimum][y.blueMaximum] + pe[y.alphaMinimum][y.redMaximum][y.greenMinimum][y.blueMaximum] - pe[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMaximum] - (-pe[y.alphaMaximum][y.redMaximum][y.greenMinimum][y.blueMinimum] + pe[y.alphaMaximum][y.redMinimum][y.greenMinimum][y.blueMinimum] + pe[y.alphaMinimum][y.redMaximum][y.greenMinimum][y.blueMinimum] - pe[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMinimum]);
          case ot._blue:
            return -pe[y.alphaMaximum][y.redMaximum][y.greenMaximum][y.blueMinimum] + pe[y.alphaMaximum][y.redMaximum][y.greenMinimum][y.blueMinimum] + pe[y.alphaMaximum][y.redMinimum][y.greenMaximum][y.blueMinimum] - pe[y.alphaMaximum][y.redMinimum][y.greenMinimum][y.blueMinimum] - (-pe[y.alphaMinimum][y.redMaximum][y.greenMaximum][y.blueMinimum] + pe[y.alphaMinimum][y.redMaximum][y.greenMinimum][y.blueMinimum] + pe[y.alphaMinimum][y.redMinimum][y.greenMaximum][y.blueMinimum] - pe[y.alphaMinimum][y.redMinimum][y.greenMinimum][y.blueMinimum]);
          default:
            return 0;
        }
      }
      _calculateVariance(y) {
        const ue = ot._volume(y, this._momentsRed), pe = ot._volume(y, this._momentsGreen), ve = ot._volume(y, this._momentsBlue), Te = ot._volume(y, this._momentsAlpha);
        return ot._volumeFloat(y, this._moments) - (ue * ue + pe * pe + ve * ve + Te * Te) / ot._volume(y, this._weights);
      }
      _maximize(y, ue, pe, ve, Te, Ue, Le, qe, je) {
        const et = 0 | ot._bottom(y, ue, this._momentsRed), Ve = 0 | ot._bottom(y, ue, this._momentsGreen), Xe = 0 | ot._bottom(y, ue, this._momentsBlue), ft = 0 | ot._bottom(y, ue, this._momentsAlpha), xt = 0 | ot._bottom(y, ue, this._weights);
        let _t = 0, ct = -1;
        for (let dt = pe; dt < ve; ++dt) {
          let jt = et + ot._top(y, ue, dt, this._momentsRed), Bt = Ve + ot._top(y, ue, dt, this._momentsGreen), Ht = Xe + ot._top(y, ue, dt, this._momentsBlue), Wt = ft + ot._top(y, ue, dt, this._momentsAlpha), Zt = xt + ot._top(y, ue, dt, this._weights);
          if (Zt !== 0) {
            let $t = jt * jt + Bt * Bt + Ht * Ht + Wt * Wt, gt = $t / Zt;
            jt = Te - jt, Bt = Ue - Bt, Ht = Le - Ht, Wt = qe - Wt, Zt = je - Zt, Zt !== 0 && ($t = jt * jt + Bt * Bt + Ht * Ht + Wt * Wt, gt += $t / Zt, gt > _t && (_t = gt, ct = dt));
          }
        }
        return { max: _t, position: ct };
      }
      _cut(y, ue) {
        let pe;
        const ve = ot._volume(y, this._momentsRed), Te = ot._volume(y, this._momentsGreen), Ue = ot._volume(y, this._momentsBlue), Le = ot._volume(y, this._momentsAlpha), qe = ot._volume(y, this._weights), je = this._maximize(y, ot._red, y.redMinimum + 1, y.redMaximum, ve, Te, Ue, Le, qe), et = this._maximize(y, ot._green, y.greenMinimum + 1, y.greenMaximum, ve, Te, Ue, Le, qe), Ve = this._maximize(y, ot._blue, y.blueMinimum + 1, y.blueMaximum, ve, Te, Ue, Le, qe), Xe = this._maximize(y, ot._alpha, y.alphaMinimum + 1, y.alphaMaximum, ve, Te, Ue, Le, qe);
        if (Xe.max >= je.max && Xe.max >= et.max && Xe.max >= Ve.max) {
          if (pe = ot._alpha, Xe.position < 0)
            return !1;
        } else
          pe = je.max >= Xe.max && je.max >= et.max && je.max >= Ve.max ? ot._red : et.max >= Xe.max && et.max >= je.max && et.max >= Ve.max ? ot._green : ot._blue;
        switch (ue.redMaximum = y.redMaximum, ue.greenMaximum = y.greenMaximum, ue.blueMaximum = y.blueMaximum, ue.alphaMaximum = y.alphaMaximum, pe) {
          case ot._red:
            ue.redMinimum = y.redMaximum = je.position, ue.greenMinimum = y.greenMinimum, ue.blueMinimum = y.blueMinimum, ue.alphaMinimum = y.alphaMinimum;
            break;
          case ot._green:
            ue.greenMinimum = y.greenMaximum = et.position, ue.redMinimum = y.redMinimum, ue.blueMinimum = y.blueMinimum, ue.alphaMinimum = y.alphaMinimum;
            break;
          case ot._blue:
            ue.blueMinimum = y.blueMaximum = Ve.position, ue.redMinimum = y.redMinimum, ue.greenMinimum = y.greenMinimum, ue.alphaMinimum = y.alphaMinimum;
            break;
          case ot._alpha:
            ue.alphaMinimum = y.alphaMaximum = Xe.position, ue.blueMinimum = y.blueMinimum, ue.redMinimum = y.redMinimum, ue.greenMinimum = y.greenMinimum;
        }
        return y.volume = (y.redMaximum - y.redMinimum) * (y.greenMaximum - y.greenMinimum) * (y.blueMaximum - y.blueMinimum) * (y.alphaMaximum - y.alphaMinimum), ue.volume = (ue.redMaximum - ue.redMinimum) * (ue.greenMaximum - ue.greenMinimum) * (ue.blueMaximum - ue.blueMinimum) * (ue.alphaMaximum - ue.alphaMinimum), !0;
      }
      _initialize(y) {
        this._colors = y, this._cubes = [];
        for (let ue = 0; ue < y; ue++)
          this._cubes[ue] = new wt();
        this._cubes[0].redMinimum = 0, this._cubes[0].greenMinimum = 0, this._cubes[0].blueMinimum = 0, this._cubes[0].alphaMinimum = 0, this._cubes[0].redMaximum = this._maxSideIndex, this._cubes[0].greenMaximum = this._maxSideIndex, this._cubes[0].blueMaximum = this._maxSideIndex, this._cubes[0].alphaMaximum = this._alphaMaxSideIndex, this._weights = st(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsRed = st(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsGreen = st(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsBlue = st(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._momentsAlpha = st(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._moments = st(this._alphaSideSize, this._sideSize, this._sideSize, this._sideSize), this._table = [];
        for (let ue = 0; ue < 256; ++ue)
          this._table[ue] = ue * ue;
        this._pixels = [];
      }
      _setQuality(y = 5) {
        this._significantBitsPerChannel = y, this._maxSideIndex = 1 << this._significantBitsPerChannel, this._alphaMaxSideIndex = this._maxSideIndex, this._sideSize = this._maxSideIndex + 1, this._alphaSideSize = this._alphaMaxSideIndex + 1;
      }
    }, kt = ot;
    n(kt, "_alpha", 3), n(kt, "_red", 2), n(kt, "_green", 1), n(kt, "_blue", 0);
    var Ft = {};
    r(Ft, { AbstractImageQuantizer: () => Rt, ErrorDiffusionArray: () => Se, ErrorDiffusionArrayKernel: () => Lt, ErrorDiffusionRiemersma: () => bt, NearestColor: () => qt });
    var Rt = class {
      quantizeSync(y, ue) {
        for (const pe of this.quantize(y, ue))
          if (pe.pointContainer)
            return pe.pointContainer;
        throw new Error("unreachable");
      }
    }, qt = class extends Rt {
      constructor(y) {
        super(), n(this, "_distance"), this._distance = y;
      }
      *quantize(y, ue) {
        const pe = y.getPointArray(), ve = y.getWidth(), Te = y.getHeight(), Ue = new P(Te, 99);
        for (let Le = 0; Le < Te; Le++) {
          Ue.shouldNotify(Le) && (yield { progress: Ue.progress });
          for (let qe = 0, je = Le * ve; qe < ve; qe++, je++) {
            const et = pe[je];
            et.from(ue.getNearestColor(this._distance, et));
          }
        }
        yield { pointContainer: y, progress: 100 };
      }
    }, Lt = ((y) => (y[y.FloydSteinberg = 0] = "FloydSteinberg", y[y.FalseFloydSteinberg = 1] = "FalseFloydSteinberg", y[y.Stucki = 2] = "Stucki", y[y.Atkinson = 3] = "Atkinson", y[y.Jarvis = 4] = "Jarvis", y[y.Burkes = 5] = "Burkes", y[y.Sierra = 6] = "Sierra", y[y.TwoSierra = 7] = "TwoSierra", y[y.SierraLite = 8] = "SierraLite", y))(Lt || {}), Se = class extends Rt {
      constructor(y, ue, pe = !0, ve = 0, Te = !1) {
        super(), n(this, "_minColorDistance"), n(this, "_serpentine"), n(this, "_kernel"), n(this, "_calculateErrorLikeGIMP"), n(this, "_distance"), this._setKernel(ue), this._distance = y, this._minColorDistance = ve, this._serpentine = pe, this._calculateErrorLikeGIMP = Te;
      }
      *quantize(y, ue) {
        const pe = y.getPointArray(), ve = new Ce(), Te = y.getWidth(), Ue = y.getHeight(), Le = [];
        let qe = 1, je = 1;
        for (const Ve of this._kernel) {
          const Xe = Ve[2] + 1;
          je < Xe && (je = Xe);
        }
        for (let Ve = 0; Ve < je; Ve++)
          this._fillErrorLine(Le[Ve] = [], Te);
        const et = new P(Ue, 99);
        for (let Ve = 0; Ve < Ue; Ve++) {
          et.shouldNotify(Ve) && (yield { progress: et.progress }), this._serpentine && (qe *= -1);
          const Xe = Ve * Te, ft = qe === 1 ? 0 : Te - 1, xt = qe === 1 ? Te : -1;
          this._fillErrorLine(Le[0], Te), Le.push(Le.shift());
          const _t = Le[0];
          for (let ct = ft, dt = Xe + ft; ct !== xt; ct += qe, dt += qe) {
            const jt = pe[dt], Bt = _t[ct];
            ve.from(jt);
            const Ht = Ce.createByRGBA(R(jt.r + Bt[0]), R(jt.g + Bt[1]), R(jt.b + Bt[2]), R(jt.a + Bt[3])), Wt = ue.getNearestColor(this._distance, Ht);
            if (jt.from(Wt), this._minColorDistance && this._distance.calculateNormalized(ve, Wt) < this._minColorDistance)
              continue;
            let Zt, $t, gt, Qt;
            this._calculateErrorLikeGIMP ? (Zt = Ht.r - Wt.r, $t = Ht.g - Wt.g, gt = Ht.b - Wt.b, Qt = Ht.a - Wt.a) : (Zt = ve.r - Wt.r, $t = ve.g - Wt.g, gt = ve.b - Wt.b, Qt = ve.a - Wt.a);
            const fr = qe === 1 ? 0 : this._kernel.length - 1, mr = qe === 1 ? this._kernel.length : -1;
            for (let lr = fr; lr !== mr; lr += qe) {
              const hr = this._kernel[lr][1] * qe, Yt = this._kernel[lr][2];
              if (hr + ct >= 0 && hr + ct < Te && Yt + Ve >= 0 && Yt + Ve < Ue) {
                const ur = this._kernel[lr][0], ar = Le[Yt][hr + ct];
                ar[0] += Zt * ur, ar[1] += $t * ur, ar[2] += gt * ur, ar[3] += Qt * ur;
              }
            }
          }
        }
        yield { pointContainer: y, progress: 100 };
      }
      _fillErrorLine(y, ue) {
        y.length > ue && (y.length = ue);
        const pe = y.length;
        for (let ve = 0; ve < pe; ve++) {
          const Te = y[ve];
          Te[0] = Te[1] = Te[2] = Te[3] = 0;
        }
        for (let ve = pe; ve < ue; ve++)
          y[ve] = [0, 0, 0, 0];
      }
      _setKernel(y) {
        switch (y) {
          case 0:
            this._kernel = [[7 / 16, 1, 0], [3 / 16, -1, 1], [5 / 16, 0, 1], [1 / 16, 1, 1]];
            break;
          case 1:
            this._kernel = [[3 / 8, 1, 0], [3 / 8, 0, 1], [2 / 8, 1, 1]];
            break;
          case 2:
            this._kernel = [[8 / 42, 1, 0], [4 / 42, 2, 0], [2 / 42, -2, 1], [4 / 42, -1, 1], [8 / 42, 0, 1], [4 / 42, 1, 1], [2 / 42, 2, 1], [1 / 42, -2, 2], [2 / 42, -1, 2], [4 / 42, 0, 2], [2 / 42, 1, 2], [1 / 42, 2, 2]];
            break;
          case 3:
            this._kernel = [[1 / 8, 1, 0], [1 / 8, 2, 0], [1 / 8, -1, 1], [1 / 8, 0, 1], [1 / 8, 1, 1], [1 / 8, 0, 2]];
            break;
          case 4:
            this._kernel = [[7 / 48, 1, 0], [5 / 48, 2, 0], [3 / 48, -2, 1], [5 / 48, -1, 1], [7 / 48, 0, 1], [5 / 48, 1, 1], [3 / 48, 2, 1], [1 / 48, -2, 2], [3 / 48, -1, 2], [5 / 48, 0, 2], [3 / 48, 1, 2], [1 / 48, 2, 2]];
            break;
          case 5:
            this._kernel = [[0.25, 1, 0], [4 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [0.25, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1]];
            break;
          case 6:
            this._kernel = [[5 / 32, 1, 0], [3 / 32, 2, 0], [2 / 32, -2, 1], [4 / 32, -1, 1], [5 / 32, 0, 1], [4 / 32, 1, 1], [2 / 32, 2, 1], [2 / 32, -1, 2], [3 / 32, 0, 2], [2 / 32, 1, 2]];
            break;
          case 7:
            this._kernel = [[0.25, 1, 0], [3 / 16, 2, 0], [1 / 16, -2, 1], [2 / 16, -1, 1], [3 / 16, 0, 1], [2 / 16, 1, 1], [1 / 16, 2, 1]];
            break;
          case 8:
            this._kernel = [[0.5, 1, 0], [1 / 4, -1, 1], [1 / 4, 0, 1]];
            break;
          default:
            throw new Error(`ErrorDiffusionArray: unknown kernel = ${y}`);
        }
      }
    };
    function* Ye(y, ue, pe) {
      const ve = Math.max(y, ue), Te = { width: y, height: ue, level: Math.floor(Math.log(ve) / Math.log(2) + 1), callback: pe, tracker: new P(y * ue, 99), index: 0, x: 0, y: 0 };
      yield* Ke(Te, 1), ut(Te, 0);
    }
    function* Ke(y, ue) {
      if (!(y.level < 1)) {
        switch (y.tracker.shouldNotify(y.index) && (yield { progress: y.tracker.progress }), y.level--, ue) {
          case 2:
            yield* Ke(y, 1), ut(y, 3), yield* Ke(y, 2), ut(y, 4), yield* Ke(y, 2), ut(y, 2), yield* Ke(y, 4);
            break;
          case 3:
            yield* Ke(y, 4), ut(y, 2), yield* Ke(y, 3), ut(y, 1), yield* Ke(y, 3), ut(y, 3), yield* Ke(y, 1);
            break;
          case 1:
            yield* Ke(y, 2), ut(y, 4), yield* Ke(y, 1), ut(y, 3), yield* Ke(y, 1), ut(y, 1), yield* Ke(y, 3);
            break;
          case 4:
            yield* Ke(y, 3), ut(y, 1), yield* Ke(y, 4), ut(y, 2), yield* Ke(y, 4), ut(y, 4), yield* Ke(y, 2);
        }
        y.level++;
      }
    }
    function ut(y, ue) {
      switch (y.x >= 0 && y.x < y.width && y.y >= 0 && y.y < y.height && (y.callback(y.x, y.y), y.index++), ue) {
        case 2:
          y.x--;
          break;
        case 3:
          y.x++;
          break;
        case 1:
          y.y--;
          break;
        case 4:
          y.y++;
      }
    }
    var bt = class extends Rt {
      constructor(y, ue = 16, pe = 1) {
        super(), n(this, "_distance"), n(this, "_weights"), n(this, "_errorQueueSize"), this._distance = y, this._errorQueueSize = ue, this._weights = bt._createWeights(pe, ue);
      }
      *quantize(y, ue) {
        const pe = y.getPointArray(), ve = y.getWidth(), Te = y.getHeight(), Ue = [];
        let Le = 0;
        for (let qe = 0; qe < this._errorQueueSize; qe++)
          Ue[qe] = { r: 0, g: 0, b: 0, a: 0 };
        yield* Ye(ve, Te, (qe, je) => {
          const et = pe[qe + je * ve];
          let { r: Ve, g: Xe, b: ft, a: xt } = et;
          for (let jt = 0; jt < this._errorQueueSize; jt++) {
            const Bt = this._weights[jt], Ht = Ue[(jt + Le) % this._errorQueueSize];
            Ve += Ht.r * Bt, Xe += Ht.g * Bt, ft += Ht.b * Bt, xt += Ht.a * Bt;
          }
          const _t = Ce.createByRGBA(R(Ve), R(Xe), R(ft), R(xt)), ct = ue.getNearestColor(this._distance, _t);
          Le = (Le + 1) % this._errorQueueSize;
          const dt = (Le + this._errorQueueSize - 1) % this._errorQueueSize;
          Ue[dt].r = et.r - ct.r, Ue[dt].g = et.g - ct.g, Ue[dt].b = et.b - ct.b, Ue[dt].a = et.a - ct.a, et.from(ct);
        }), yield { pointContainer: y, progress: 100 };
      }
      static _createWeights(y, ue) {
        const pe = [], ve = Math.exp(Math.log(ue) / (ue - 1));
        for (let Te = 0, Ue = 1; Te < ue; Te++)
          pe[Te] = (Ue + 0.5 | 0) / ue * y, Ue *= ve;
        return pe;
      }
    }, At = {};
    r(At, { ssim: () => Dt });
    var Ct = 0.01, vt = 0.03;
    function Dt(y, ue) {
      if (y.getHeight() !== ue.getHeight() || y.getWidth() !== ue.getWidth())
        throw new Error("Images have different sizes!");
      const pe = (255 * Ct) ** 2, ve = (255 * vt) ** 2;
      let Te = 0, Ue = 0;
      return function(Le, qe, je) {
        const et = Le.getWidth(), Ve = Le.getHeight();
        for (let Xe = 0; Xe < Ve; Xe += 8)
          for (let ft = 0; ft < et; ft += 8) {
            const xt = Math.min(8, et - ft), _t = Math.min(8, Ve - Xe), ct = Nt(Le, ft, Xe, xt, _t), dt = Nt(qe, ft, Xe, xt, _t);
            je(ct, dt, Ut(ct), Ut(dt));
          }
      }(y, ue, (Le, qe, je, et) => {
        let Ve = 0, Xe = 0, ft = 0;
        for (let _t = 0; _t < Le.length; _t++)
          Xe += (Le[_t] - je) ** 2, ft += (qe[_t] - et) ** 2, Ve += (Le[_t] - je) * (qe[_t] - et);
        const xt = Le.length - 1;
        Xe /= xt, ft /= xt, Ve /= xt, Ue += (2 * je * et + pe) * (2 * Ve + ve) / ((je ** 2 + et ** 2 + pe) * (Xe + ft + ve)), Te++;
      }), Ue / Te;
    }
    function Nt(y, ue, pe, ve, Te) {
      const Ue = y.getPointArray(), Le = [];
      let qe = 0;
      for (let je = pe; je < pe + Te; je++) {
        const et = je * y.getWidth();
        for (let Ve = ue; Ve < ue + ve; Ve++) {
          const Xe = Ue[et + Ve];
          Le[qe] = 0.2126 * Xe.r + 0.7152 * Xe.g + 0.0722 * Xe.b, qe++;
        }
      }
      return Le;
    }
    function Ut(y) {
      let ue = 0;
      for (const pe of y)
        ue += pe;
      return ue / y.length;
    }
    var Gt = typeof setImmediate == "function" ? setImmediate : e !== void 0 && typeof (e == null ? void 0 : e.nextTick) == "function" ? (y) => e.nextTick(y) : (y) => setTimeout(y, 0);
    function Jt(y, { colorDistanceFormula: ue, paletteQuantization: pe, colors: ve } = {}) {
      const Te = dr(Tt(ue), pe, ve);
      return y.forEach((Ue) => Te.sample(Ue)), Te.quantizeSync();
    }
    async function er(y, { colorDistanceFormula: ue, paletteQuantization: pe, colors: ve, onProgress: Te } = {}) {
      return new Promise((Ue, Le) => {
        const qe = dr(Tt(ue), pe, ve);
        let je;
        y.forEach((Xe) => qe.sample(Xe));
        const et = qe.quantize(), Ve = () => {
          try {
            const Xe = et.next();
            Xe.done ? Ue(je) : (Xe.value.palette && (je = Xe.value.palette), Te && Te(Xe.value.progress), Gt(Ve));
          } catch (Xe) {
            Le(Xe);
          }
        };
        Gt(Ve);
      });
    }
    function Xt(y, ue, { colorDistanceFormula: pe, imageQuantization: ve } = {}) {
      return nr(Tt(pe), ve).quantizeSync(y, ue);
    }
    async function or(y, ue, { colorDistanceFormula: pe, imageQuantization: ve, onProgress: Te } = {}) {
      return new Promise((Ue, Le) => {
        let qe;
        const je = nr(Tt(pe), ve).quantize(y, ue), et = () => {
          try {
            const Ve = je.next();
            Ve.done ? Ue(qe) : (Ve.value.pointContainer && (qe = Ve.value.pointContainer), Te && Te(Ve.value.progress), Gt(et));
          } catch (Ve) {
            Le(Ve);
          }
        };
        Gt(et);
      });
    }
    function Tt(y = "euclidean-bt709") {
      switch (y) {
        case "cie94-graphic-arts":
          return new c();
        case "cie94-textiles":
          return new h();
        case "ciede2000":
          return new D();
        case "color-metric":
          return new ee();
        case "euclidean":
          return new Q();
        case "euclidean-bt709":
          return new se();
        case "euclidean-bt709-noalpha":
          return new Y();
        case "manhattan":
          return new Ee();
        case "manhattan-bt709":
          return new ke();
        case "manhattan-nommyde":
          return new Me();
        case "pngquant":
          return new oe();
        default:
          throw new Error(`Unknown colorDistanceFormula ${y}`);
      }
    }
    function nr(y, ue = "floyd-steinberg") {
      switch (ue) {
        case "nearest":
          return new qt(y);
        case "riemersma":
          return new bt(y);
        case "floyd-steinberg":
          return new Se(y, 0);
        case "false-floyd-steinberg":
          return new Se(y, 1);
        case "stucki":
          return new Se(y, 2);
        case "atkinson":
          return new Se(y, 3);
        case "jarvis":
          return new Se(y, 4);
        case "burkes":
          return new Se(y, 5);
        case "sierra":
          return new Se(y, 6);
        case "two-sierra":
          return new Se(y, 7);
        case "sierra-lite":
          return new Se(y, 8);
        default:
          throw new Error(`Unknown imageQuantization ${ue}`);
      }
    }
    function dr(y, ue = "wuquant", pe = 256) {
      switch (ue) {
        case "neuquant":
          return new de(y, pe);
        case "rgbquant":
          return new Ie(y, pe);
        case "wuquant":
          return new kt(y, pe);
        case "neuquant-float":
          return new rt(y, pe);
        default:
          throw new Error(`Unknown paletteQuantization ${ue}`);
      }
    }
    d.exports = o(u);
  } }, __webpack_module_cache__ = {};
  function __webpack_require__(d) {
    var l = __webpack_module_cache__[d];
    if (l !== void 0)
      return l.exports;
    var s = __webpack_module_cache__[d] = { exports: {} };
    return __webpack_modules__[d](s, s.exports, __webpack_require__), s.exports;
  }
  __webpack_require__.n = (d) => {
    var l = d && d.__esModule ? () => d.default : () => d;
    return __webpack_require__.d(l, { a: l }), l;
  }, __webpack_require__.d = (d, l) => {
    for (var s in l)
      __webpack_require__.o(l, s) && !__webpack_require__.o(d, s) && Object.defineProperty(d, s, { enumerable: !0, get: l[s] });
  }, __webpack_require__.g = function() {
    if (typeof globalThis == "object")
      return globalThis;
    try {
      return this || new Function("return this")();
    } catch {
      if (typeof window == "object")
        return window;
    }
  }(), __webpack_require__.o = (d, l) => Object.prototype.hasOwnProperty.call(d, l), __webpack_require__.r = (d) => {
    typeof Symbol < "u" && Symbol.toStringTag && Object.defineProperty(d, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(d, "__esModule", { value: !0 });
  }, (() => {
    var d = {};
    __webpack_require__.r(d), __webpack_require__.d(d, { AUTO: () => be, BLEND_ADD: () => Pe, BLEND_DARKEN: () => Qe, BLEND_DESTINATION_OVER: () => _e, BLEND_DIFFERENCE: () => we, BLEND_EXCLUSION: () => X, BLEND_HARDLIGHT: () => P, BLEND_LIGHTEN: () => lt, BLEND_MULTIPLY: () => Be, BLEND_OVERLAY: () => We, BLEND_SCREEN: () => Fe, BLEND_SOURCE_OVER: () => Ce, EDGE_CROP: () => Re, EDGE_EXTEND: () => de, EDGE_WRAP: () => Ze, HORIZONTAL_ALIGN_CENTER: () => Me, HORIZONTAL_ALIGN_LEFT: () => Ee, HORIZONTAL_ALIGN_RIGHT: () => ke, VERTICAL_ALIGN_BOTTOM: () => xe, VERTICAL_ALIGN_MIDDLE: () => ce, VERTICAL_ALIGN_TOP: () => oe });
    var l = {};
    __webpack_require__.r(l), __webpack_require__.d(l, { add: () => Ne, darken: () => st, difference: () => It, dstOver: () => De, exclusion: () => wt, hardLight: () => mt, lighten: () => tt, multiply: () => Je, overlay: () => at, screen: () => Ie, srcOver: () => rt });
    var s = __webpack_require__(5546), e = __webpack_require__.n(s), f = __webpack_require__(1023), i = __webpack_require__.n(f), a = __webpack_require__(2699), t = __webpack_require__.n(a);
    function r(S) {
      if (S === void 0)
        return !1;
      if (typeof S != "function")
        throw new TypeError("Callback must be a function");
      return !0;
    }
    function o(S, A) {
      if (typeof S == "string" && (S = new Error(S)), typeof A == "function")
        return A.call(this, S);
      throw S;
    }
    function n(S, A, H, Z, ie, fe) {
      A = Math.round(A), H = Math.round(H), Z = Math.round(Z), ie = Math.round(ie);
      for (let ge = H; ge < H + ie; ge++)
        for (let me = A; me < A + Z; me++) {
          const ye = S.bitmap.width * ge + me << 2;
          fe.call(S, me, ge, ye);
        }
      return S;
    }
    var u = __webpack_require__(236), p = __webpack_require__.n(u), g = __webpack_require__(1294), v = __webpack_require__.n(g);
    function x(S) {
      return x = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(A) {
        return typeof A;
      } : function(A) {
        return A && typeof Symbol == "function" && A.constructor === Symbol && A !== Symbol.prototype ? "symbol" : typeof A;
      }, x(S);
    }
    var b = /^\s+/, w = /\s+$/;
    function M(S, A) {
      if (A = A || {}, (S = S || "") instanceof M)
        return S;
      if (!(this instanceof M))
        return new M(S, A);
      var H = function(Z) {
        var ie, fe, ge, me = { r: 0, g: 0, b: 0 }, ye = 1, Ae = null, Oe = null, ze = null, it = !1, $e = !1;
        return typeof Z == "string" && (Z = function(Ge) {
          Ge = Ge.replace(b, "").replace(w, "").toLowerCase();
          var He, nt = !1;
          if (L[Ge])
            Ge = L[Ge], nt = !0;
          else if (Ge == "transparent")
            return { r: 0, g: 0, b: 0, a: 0, format: "name" };
          return (He = m.rgb.exec(Ge)) ? { r: He[1], g: He[2], b: He[3] } : (He = m.rgba.exec(Ge)) ? { r: He[1], g: He[2], b: He[3], a: He[4] } : (He = m.hsl.exec(Ge)) ? { h: He[1], s: He[2], l: He[3] } : (He = m.hsla.exec(Ge)) ? { h: He[1], s: He[2], l: He[3], a: He[4] } : (He = m.hsv.exec(Ge)) ? { h: He[1], s: He[2], v: He[3] } : (He = m.hsva.exec(Ge)) ? { h: He[1], s: He[2], v: He[3], a: He[4] } : (He = m.hex8.exec(Ge)) ? { r: le(He[1]), g: le(He[2]), b: le(He[3]), a: B(He[4]), format: nt ? "name" : "hex8" } : (He = m.hex6.exec(Ge)) ? { r: le(He[1]), g: le(He[2]), b: le(He[3]), format: nt ? "name" : "hex" } : (He = m.hex4.exec(Ge)) ? { r: le(He[1] + "" + He[1]), g: le(He[2] + "" + He[2]), b: le(He[3] + "" + He[3]), a: B(He[4] + "" + He[4]), format: nt ? "name" : "hex8" } : !!(He = m.hex3.exec(Ge)) && { r: le(He[1] + "" + He[1]), g: le(He[2] + "" + He[2]), b: le(He[3] + "" + He[3]), format: nt ? "name" : "hex" };
        }(Z)), x(Z) == "object" && (D(Z.r) && D(Z.g) && D(Z.b) ? (ie = Z.r, fe = Z.g, ge = Z.b, me = { r: 255 * N(ie, 255), g: 255 * N(fe, 255), b: 255 * N(ge, 255) }, it = !0, $e = String(Z.r).substr(-1) === "%" ? "prgb" : "rgb") : D(Z.h) && D(Z.s) && D(Z.v) ? (Ae = k(Z.s), Oe = k(Z.v), me = function(Ge, He, nt) {
          Ge = 6 * N(Ge, 360), He = N(He, 100), nt = N(nt, 100);
          var ht = Math.floor(Ge), pt = Ge - ht, Et = nt * (1 - He), Pt = nt * (1 - pt * He), yt = nt * (1 - (1 - pt) * He), Mt = ht % 6;
          return { r: 255 * [nt, Pt, Et, Et, yt, nt][Mt], g: 255 * [yt, nt, nt, Pt, Et, Et][Mt], b: 255 * [Et, Et, yt, nt, nt, Pt][Mt] };
        }(Z.h, Ae, Oe), it = !0, $e = "hsv") : D(Z.h) && D(Z.s) && D(Z.l) && (Ae = k(Z.s), ze = k(Z.l), me = function(Ge, He, nt) {
          var ht, pt, Et;
          function Pt(St, Ot, zt) {
            return zt < 0 && (zt += 1), zt > 1 && (zt -= 1), zt < 1 / 6 ? St + 6 * (Ot - St) * zt : zt < 0.5 ? Ot : zt < 2 / 3 ? St + (Ot - St) * (2 / 3 - zt) * 6 : St;
          }
          if (Ge = N(Ge, 360), He = N(He, 100), nt = N(nt, 100), He === 0)
            ht = pt = Et = nt;
          else {
            var yt = nt < 0.5 ? nt * (1 + He) : nt + He - nt * He, Mt = 2 * nt - yt;
            ht = Pt(Mt, yt, Ge + 1 / 3), pt = Pt(Mt, yt, Ge), Et = Pt(Mt, yt, Ge - 1 / 3);
          }
          return { r: 255 * ht, g: 255 * pt, b: 255 * Et };
        }(Z.h, Ae, ze), it = !0, $e = "hsl"), Z.hasOwnProperty("a") && (ye = Z.a)), ye = z(ye), { ok: it, format: Z.format || $e, r: Math.min(255, Math.max(me.r, 0)), g: Math.min(255, Math.max(me.g, 0)), b: Math.min(255, Math.max(me.b, 0)), a: ye };
      }(S);
      this._originalInput = S, this._r = H.r, this._g = H.g, this._b = H.b, this._a = H.a, this._roundA = Math.round(100 * this._a) / 100, this._format = A.format || H.format, this._gradientType = A.gradientType, this._r < 1 && (this._r = Math.round(this._r)), this._g < 1 && (this._g = Math.round(this._g)), this._b < 1 && (this._b = Math.round(this._b)), this._ok = H.ok;
    }
    function G(S, A, H) {
      S = N(S, 255), A = N(A, 255), H = N(H, 255);
      var Z, ie, fe = Math.max(S, A, H), ge = Math.min(S, A, H), me = (fe + ge) / 2;
      if (fe == ge)
        Z = ie = 0;
      else {
        var ye = fe - ge;
        switch (ie = me > 0.5 ? ye / (2 - fe - ge) : ye / (fe + ge), fe) {
          case S:
            Z = (A - H) / ye + (A < H ? 6 : 0);
            break;
          case A:
            Z = (H - S) / ye + 2;
            break;
          case H:
            Z = (S - A) / ye + 4;
        }
        Z /= 6;
      }
      return { h: Z, s: ie, l: me };
    }
    function F(S, A, H) {
      S = N(S, 255), A = N(A, 255), H = N(H, 255);
      var Z, ie, fe = Math.max(S, A, H), ge = Math.min(S, A, H), me = fe, ye = fe - ge;
      if (ie = fe === 0 ? 0 : ye / fe, fe == ge)
        Z = 0;
      else {
        switch (fe) {
          case S:
            Z = (A - H) / ye + (A < H ? 6 : 0);
            break;
          case A:
            Z = (H - S) / ye + 2;
            break;
          case H:
            Z = (S - A) / ye + 4;
        }
        Z /= 6;
      }
      return { h: Z, s: ie, v: me };
    }
    function V(S, A, H, Z) {
      var ie = [he(Math.round(S).toString(16)), he(Math.round(A).toString(16)), he(Math.round(H).toString(16))];
      return Z && ie[0].charAt(0) == ie[0].charAt(1) && ie[1].charAt(0) == ie[1].charAt(1) && ie[2].charAt(0) == ie[2].charAt(1) ? ie[0].charAt(0) + ie[1].charAt(0) + ie[2].charAt(0) : ie.join("");
    }
    function q(S, A, H, Z) {
      return [he(T(Z)), he(Math.round(S).toString(16)), he(Math.round(A).toString(16)), he(Math.round(H).toString(16))].join("");
    }
    function I(S, A) {
      A = A === 0 ? 0 : A || 10;
      var H = M(S).toHsl();
      return H.s -= A / 100, H.s = ne(H.s), M(H);
    }
    function _(S, A) {
      A = A === 0 ? 0 : A || 10;
      var H = M(S).toHsl();
      return H.s += A / 100, H.s = ne(H.s), M(H);
    }
    function R(S) {
      return M(S).desaturate(100);
    }
    function W(S, A) {
      A = A === 0 ? 0 : A || 10;
      var H = M(S).toHsl();
      return H.l += A / 100, H.l = ne(H.l), M(H);
    }
    function O(S, A) {
      A = A === 0 ? 0 : A || 10;
      var H = M(S).toRgb();
      return H.r = Math.max(0, Math.min(255, H.r - Math.round(-A / 100 * 255))), H.g = Math.max(0, Math.min(255, H.g - Math.round(-A / 100 * 255))), H.b = Math.max(0, Math.min(255, H.b - Math.round(-A / 100 * 255))), M(H);
    }
    function j(S, A) {
      A = A === 0 ? 0 : A || 10;
      var H = M(S).toHsl();
      return H.l -= A / 100, H.l = ne(H.l), M(H);
    }
    function U(S, A) {
      var H = M(S).toHsl(), Z = (H.h + A) % 360;
      return H.h = Z < 0 ? 360 + Z : Z, M(H);
    }
    function C(S) {
      var A = M(S).toHsl();
      return A.h = (A.h + 180) % 360, M(A);
    }
    function ae(S, A) {
      if (isNaN(A) || A <= 0)
        throw new Error("Argument to polyad must be a positive number");
      for (var H = M(S).toHsl(), Z = [M(S)], ie = 360 / A, fe = 1; fe < A; fe++)
        Z.push(M({ h: (H.h + fe * ie) % 360, s: H.s, l: H.l }));
      return Z;
    }
    function J(S) {
      var A = M(S).toHsl(), H = A.h;
      return [M(S), M({ h: (H + 72) % 360, s: A.s, l: A.l }), M({ h: (H + 216) % 360, s: A.s, l: A.l })];
    }
    function te(S, A, H) {
      A = A || 6, H = H || 30;
      var Z = M(S).toHsl(), ie = 360 / H, fe = [M(S)];
      for (Z.h = (Z.h - (ie * A >> 1) + 720) % 360; --A; )
        Z.h = (Z.h + ie) % 360, fe.push(M(Z));
      return fe;
    }
    function $(S, A) {
      A = A || 6;
      for (var H = M(S).toHsv(), Z = H.h, ie = H.s, fe = H.v, ge = [], me = 1 / A; A--; )
        ge.push(M({ h: Z, s: ie, v: fe })), fe = (fe + me) % 1;
      return ge;
    }
    M.prototype = { isDark: function() {
      return this.getBrightness() < 128;
    }, isLight: function() {
      return !this.isDark();
    }, isValid: function() {
      return this._ok;
    }, getOriginalInput: function() {
      return this._originalInput;
    }, getFormat: function() {
      return this._format;
    }, getAlpha: function() {
      return this._a;
    }, getBrightness: function() {
      var S = this.toRgb();
      return (299 * S.r + 587 * S.g + 114 * S.b) / 1e3;
    }, getLuminance: function() {
      var S, A, H, Z = this.toRgb();
      return S = Z.r / 255, A = Z.g / 255, H = Z.b / 255, 0.2126 * (S <= 0.03928 ? S / 12.92 : Math.pow((S + 0.055) / 1.055, 2.4)) + 0.7152 * (A <= 0.03928 ? A / 12.92 : Math.pow((A + 0.055) / 1.055, 2.4)) + 0.0722 * (H <= 0.03928 ? H / 12.92 : Math.pow((H + 0.055) / 1.055, 2.4));
    }, setAlpha: function(S) {
      return this._a = z(S), this._roundA = Math.round(100 * this._a) / 100, this;
    }, toHsv: function() {
      var S = F(this._r, this._g, this._b);
      return { h: 360 * S.h, s: S.s, v: S.v, a: this._a };
    }, toHsvString: function() {
      var S = F(this._r, this._g, this._b), A = Math.round(360 * S.h), H = Math.round(100 * S.s), Z = Math.round(100 * S.v);
      return this._a == 1 ? "hsv(" + A + ", " + H + "%, " + Z + "%)" : "hsva(" + A + ", " + H + "%, " + Z + "%, " + this._roundA + ")";
    }, toHsl: function() {
      var S = G(this._r, this._g, this._b);
      return { h: 360 * S.h, s: S.s, l: S.l, a: this._a };
    }, toHslString: function() {
      var S = G(this._r, this._g, this._b), A = Math.round(360 * S.h), H = Math.round(100 * S.s), Z = Math.round(100 * S.l);
      return this._a == 1 ? "hsl(" + A + ", " + H + "%, " + Z + "%)" : "hsla(" + A + ", " + H + "%, " + Z + "%, " + this._roundA + ")";
    }, toHex: function(S) {
      return V(this._r, this._g, this._b, S);
    }, toHexString: function(S) {
      return "#" + this.toHex(S);
    }, toHex8: function(S) {
      return function(A, H, Z, ie, fe) {
        var ge = [he(Math.round(A).toString(16)), he(Math.round(H).toString(16)), he(Math.round(Z).toString(16)), he(T(ie))];
        return fe && ge[0].charAt(0) == ge[0].charAt(1) && ge[1].charAt(0) == ge[1].charAt(1) && ge[2].charAt(0) == ge[2].charAt(1) && ge[3].charAt(0) == ge[3].charAt(1) ? ge[0].charAt(0) + ge[1].charAt(0) + ge[2].charAt(0) + ge[3].charAt(0) : ge.join("");
      }(this._r, this._g, this._b, this._a, S);
    }, toHex8String: function(S) {
      return "#" + this.toHex8(S);
    }, toRgb: function() {
      return { r: Math.round(this._r), g: Math.round(this._g), b: Math.round(this._b), a: this._a };
    }, toRgbString: function() {
      return this._a == 1 ? "rgb(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ")" : "rgba(" + Math.round(this._r) + ", " + Math.round(this._g) + ", " + Math.round(this._b) + ", " + this._roundA + ")";
    }, toPercentageRgb: function() {
      return { r: Math.round(100 * N(this._r, 255)) + "%", g: Math.round(100 * N(this._g, 255)) + "%", b: Math.round(100 * N(this._b, 255)) + "%", a: this._a };
    }, toPercentageRgbString: function() {
      return this._a == 1 ? "rgb(" + Math.round(100 * N(this._r, 255)) + "%, " + Math.round(100 * N(this._g, 255)) + "%, " + Math.round(100 * N(this._b, 255)) + "%)" : "rgba(" + Math.round(100 * N(this._r, 255)) + "%, " + Math.round(100 * N(this._g, 255)) + "%, " + Math.round(100 * N(this._b, 255)) + "%, " + this._roundA + ")";
    }, toName: function() {
      return this._a === 0 ? "transparent" : !(this._a < 1) && (re[V(this._r, this._g, this._b, !0)] || !1);
    }, toFilter: function(S) {
      var A = "#" + q(this._r, this._g, this._b, this._a), H = A, Z = this._gradientType ? "GradientType = 1, " : "";
      if (S) {
        var ie = M(S);
        H = "#" + q(ie._r, ie._g, ie._b, ie._a);
      }
      return "progid:DXImageTransform.Microsoft.gradient(" + Z + "startColorstr=" + A + ",endColorstr=" + H + ")";
    }, toString: function(S) {
      var A = !!S;
      S = S || this._format;
      var H = !1, Z = this._a < 1 && this._a >= 0;
      return A || !Z || S !== "hex" && S !== "hex6" && S !== "hex3" && S !== "hex4" && S !== "hex8" && S !== "name" ? (S === "rgb" && (H = this.toRgbString()), S === "prgb" && (H = this.toPercentageRgbString()), S !== "hex" && S !== "hex6" || (H = this.toHexString()), S === "hex3" && (H = this.toHexString(!0)), S === "hex4" && (H = this.toHex8String(!0)), S === "hex8" && (H = this.toHex8String()), S === "name" && (H = this.toName()), S === "hsl" && (H = this.toHslString()), S === "hsv" && (H = this.toHsvString()), H || this.toHexString()) : S === "name" && this._a === 0 ? this.toName() : this.toRgbString();
    }, clone: function() {
      return M(this.toString());
    }, _applyModification: function(S, A) {
      var H = S.apply(null, [this].concat([].slice.call(A)));
      return this._r = H._r, this._g = H._g, this._b = H._b, this.setAlpha(H._a), this;
    }, lighten: function() {
      return this._applyModification(W, arguments);
    }, brighten: function() {
      return this._applyModification(O, arguments);
    }, darken: function() {
      return this._applyModification(j, arguments);
    }, desaturate: function() {
      return this._applyModification(I, arguments);
    }, saturate: function() {
      return this._applyModification(_, arguments);
    }, greyscale: function() {
      return this._applyModification(R, arguments);
    }, spin: function() {
      return this._applyModification(U, arguments);
    }, _applyCombination: function(S, A) {
      return S.apply(null, [this].concat([].slice.call(A)));
    }, analogous: function() {
      return this._applyCombination(te, arguments);
    }, complement: function() {
      return this._applyCombination(C, arguments);
    }, monochromatic: function() {
      return this._applyCombination($, arguments);
    }, splitcomplement: function() {
      return this._applyCombination(J, arguments);
    }, triad: function() {
      return this._applyCombination(ae, [3]);
    }, tetrad: function() {
      return this._applyCombination(ae, [4]);
    } }, M.fromRatio = function(S, A) {
      if (x(S) == "object") {
        var H = {};
        for (var Z in S)
          S.hasOwnProperty(Z) && (H[Z] = Z === "a" ? S[Z] : k(S[Z]));
        S = H;
      }
      return M(S, A);
    }, M.equals = function(S, A) {
      return !(!S || !A) && M(S).toRgbString() == M(A).toRgbString();
    }, M.random = function() {
      return M.fromRatio({ r: Math.random(), g: Math.random(), b: Math.random() });
    }, M.mix = function(S, A, H) {
      H = H === 0 ? 0 : H || 50;
      var Z = M(S).toRgb(), ie = M(A).toRgb(), fe = H / 100;
      return M({ r: (ie.r - Z.r) * fe + Z.r, g: (ie.g - Z.g) * fe + Z.g, b: (ie.b - Z.b) * fe + Z.b, a: (ie.a - Z.a) * fe + Z.a });
    }, M.readability = function(S, A) {
      var H = M(S), Z = M(A);
      return (Math.max(H.getLuminance(), Z.getLuminance()) + 0.05) / (Math.min(H.getLuminance(), Z.getLuminance()) + 0.05);
    }, M.isReadable = function(S, A, H) {
      var Z, ie, fe, ge, me, ye = M.readability(S, A);
      switch (ie = !1, (fe = H, (ge = ((fe = fe || { level: "AA", size: "small" }).level || "AA").toUpperCase()) !== "AA" && ge !== "AAA" && (ge = "AA"), (me = (fe.size || "small").toLowerCase()) !== "small" && me !== "large" && (me = "small"), Z = { level: ge, size: me }).level + Z.size) {
        case "AAsmall":
        case "AAAlarge":
          ie = ye >= 4.5;
          break;
        case "AAlarge":
          ie = ye >= 3;
          break;
        case "AAAsmall":
          ie = ye >= 7;
      }
      return ie;
    }, M.mostReadable = function(S, A, H) {
      var Z, ie, fe, ge, me = null, ye = 0;
      ie = (H = H || {}).includeFallbackColors, fe = H.level, ge = H.size;
      for (var Ae = 0; Ae < A.length; Ae++)
        (Z = M.readability(S, A[Ae])) > ye && (ye = Z, me = M(A[Ae]));
      return M.isReadable(S, me, { level: fe, size: ge }) || !ie ? me : (H.includeFallbackColors = !1, M.mostReadable(S, ["#fff", "#000"], H));
    };
    var L = M.names = { aliceblue: "f0f8ff", antiquewhite: "faebd7", aqua: "0ff", aquamarine: "7fffd4", azure: "f0ffff", beige: "f5f5dc", bisque: "ffe4c4", black: "000", blanchedalmond: "ffebcd", blue: "00f", blueviolet: "8a2be2", brown: "a52a2a", burlywood: "deb887", burntsienna: "ea7e5d", cadetblue: "5f9ea0", chartreuse: "7fff00", chocolate: "d2691e", coral: "ff7f50", cornflowerblue: "6495ed", cornsilk: "fff8dc", crimson: "dc143c", cyan: "0ff", darkblue: "00008b", darkcyan: "008b8b", darkgoldenrod: "b8860b", darkgray: "a9a9a9", darkgreen: "006400", darkgrey: "a9a9a9", darkkhaki: "bdb76b", darkmagenta: "8b008b", darkolivegreen: "556b2f", darkorange: "ff8c00", darkorchid: "9932cc", darkred: "8b0000", darksalmon: "e9967a", darkseagreen: "8fbc8f", darkslateblue: "483d8b", darkslategray: "2f4f4f", darkslategrey: "2f4f4f", darkturquoise: "00ced1", darkviolet: "9400d3", deeppink: "ff1493", deepskyblue: "00bfff", dimgray: "696969", dimgrey: "696969", dodgerblue: "1e90ff", firebrick: "b22222", floralwhite: "fffaf0", forestgreen: "228b22", fuchsia: "f0f", gainsboro: "dcdcdc", ghostwhite: "f8f8ff", gold: "ffd700", goldenrod: "daa520", gray: "808080", green: "008000", greenyellow: "adff2f", grey: "808080", honeydew: "f0fff0", hotpink: "ff69b4", indianred: "cd5c5c", indigo: "4b0082", ivory: "fffff0", khaki: "f0e68c", lavender: "e6e6fa", lavenderblush: "fff0f5", lawngreen: "7cfc00", lemonchiffon: "fffacd", lightblue: "add8e6", lightcoral: "f08080", lightcyan: "e0ffff", lightgoldenrodyellow: "fafad2", lightgray: "d3d3d3", lightgreen: "90ee90", lightgrey: "d3d3d3", lightpink: "ffb6c1", lightsalmon: "ffa07a", lightseagreen: "20b2aa", lightskyblue: "87cefa", lightslategray: "789", lightslategrey: "789", lightsteelblue: "b0c4de", lightyellow: "ffffe0", lime: "0f0", limegreen: "32cd32", linen: "faf0e6", magenta: "f0f", maroon: "800000", mediumaquamarine: "66cdaa", mediumblue: "0000cd", mediumorchid: "ba55d3", mediumpurple: "9370db", mediumseagreen: "3cb371", mediumslateblue: "7b68ee", mediumspringgreen: "00fa9a", mediumturquoise: "48d1cc", mediumvioletred: "c71585", midnightblue: "191970", mintcream: "f5fffa", mistyrose: "ffe4e1", moccasin: "ffe4b5", navajowhite: "ffdead", navy: "000080", oldlace: "fdf5e6", olive: "808000", olivedrab: "6b8e23", orange: "ffa500", orangered: "ff4500", orchid: "da70d6", palegoldenrod: "eee8aa", palegreen: "98fb98", paleturquoise: "afeeee", palevioletred: "db7093", papayawhip: "ffefd5", peachpuff: "ffdab9", peru: "cd853f", pink: "ffc0cb", plum: "dda0dd", powderblue: "b0e0e6", purple: "800080", rebeccapurple: "663399", red: "f00", rosybrown: "bc8f8f", royalblue: "4169e1", saddlebrown: "8b4513", salmon: "fa8072", sandybrown: "f4a460", seagreen: "2e8b57", seashell: "fff5ee", sienna: "a0522d", silver: "c0c0c0", skyblue: "87ceeb", slateblue: "6a5acd", slategray: "708090", slategrey: "708090", snow: "fffafa", springgreen: "00ff7f", steelblue: "4682b4", tan: "d2b48c", teal: "008080", thistle: "d8bfd8", tomato: "ff6347", turquoise: "40e0d0", violet: "ee82ee", wheat: "f5deb3", white: "fff", whitesmoke: "f5f5f5", yellow: "ff0", yellowgreen: "9acd32" }, re = M.hexNames = function(S) {
      var A = {};
      for (var H in S)
        S.hasOwnProperty(H) && (A[S[H]] = H);
      return A;
    }(L);
    function z(S) {
      return S = parseFloat(S), (isNaN(S) || S < 0 || S > 1) && (S = 1), S;
    }
    function N(S, A) {
      (function(Z) {
        return typeof Z == "string" && Z.indexOf(".") != -1 && parseFloat(Z) === 1;
      })(S) && (S = "100%");
      var H = function(Z) {
        return typeof Z == "string" && Z.indexOf("%") != -1;
      }(S);
      return S = Math.min(A, Math.max(0, parseFloat(S))), H && (S = parseInt(S * A, 10) / 100), Math.abs(S - A) < 1e-6 ? 1 : S % A / parseFloat(A);
    }
    function ne(S) {
      return Math.min(1, Math.max(0, S));
    }
    function le(S) {
      return parseInt(S, 16);
    }
    function he(S) {
      return S.length == 1 ? "0" + S : "" + S;
    }
    function k(S) {
      return S <= 1 && (S = 100 * S + "%"), S;
    }
    function T(S) {
      return Math.round(255 * parseFloat(S)).toString(16);
    }
    function B(S) {
      return le(S) / 255;
    }
    var K, h, c, m = (h = "[\\s|\\(]+(" + (K = "(?:[-\\+]?\\d*\\.\\d+%?)|(?:[-\\+]?\\d+%?)") + ")[,|\\s]+(" + K + ")[,|\\s]+(" + K + ")\\s*\\)?", c = "[\\s|\\(]+(" + K + ")[,|\\s]+(" + K + ")[,|\\s]+(" + K + ")[,|\\s]+(" + K + ")\\s*\\)?", { CSS_UNIT: new RegExp(K), rgb: new RegExp("rgb" + h), rgba: new RegExp("rgba" + c), hsl: new RegExp("hsl" + h), hsla: new RegExp("hsla" + c), hsv: new RegExp("hsv" + h), hsva: new RegExp("hsva" + c), hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/, hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/, hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/ });
    function D(S) {
      return !!m.CSS_UNIT.exec(S);
    }
    function ee(S, A) {
      this.size = this.size || S, this.smallerSize = this.smallerSize || A, function(H) {
        for (let Z = 1; Z < H; Z++)
          Q[Z] = 1;
        Q[0] = 1 / Math.sqrt(2);
      }(this.size);
    }
    function E(S) {
      const A = {};
      return A.r = Math.floor(S / Math.pow(256, 3)), A.g = Math.floor((S - A.r * Math.pow(256, 3)) / Math.pow(256, 2)), A.b = Math.floor((S - A.r * Math.pow(256, 3) - A.g * Math.pow(256, 2)) / Math.pow(256, 1)), A.a = Math.floor((S - A.r * Math.pow(256, 3) - A.g * Math.pow(256, 2) - A.b * Math.pow(256, 1)) / Math.pow(256, 0)), A;
    }
    ee.prototype.size = 32, ee.prototype.smallerSize = 8, ee.prototype.distance = function(S, A) {
      let H = 0;
      for (let Z = 0; Z < S.length; Z++)
        S[Z] !== A[Z] && H++;
      return H / S.length;
    }, ee.prototype.getHash = function(S) {
      (S = S.clone().resize(this.size, this.size)).grayscale();
      const A = [];
      for (let ge = 0; ge < S.bitmap.width; ge++) {
        A[ge] = [];
        for (let me = 0; me < S.bitmap.height; me++)
          A[ge][me] = E(S.getPixelColor(ge, me)).b;
      }
      const H = function(ge, me) {
        const ye = me, Ae = [];
        for (let Oe = 0; Oe < ye; Oe++) {
          Ae[Oe] = [];
          for (let ze = 0; ze < ye; ze++) {
            let it = 0;
            for (let $e = 0; $e < ye; $e++)
              for (let Ge = 0; Ge < ye; Ge++)
                it += Math.cos((2 * $e + 1) / (2 * ye) * Oe * Math.PI) * Math.cos((2 * Ge + 1) / (2 * ye) * ze * Math.PI) * ge[$e][Ge];
            it *= Q[Oe] * Q[ze] / 4, Ae[Oe][ze] = it;
          }
        }
        return Ae;
      }(A, this.size);
      let Z = 0;
      for (let ge = 0; ge < this.smallerSize; ge++)
        for (let me = 0; me < this.smallerSize; me++)
          Z += H[ge][me];
      const ie = Z / (this.smallerSize * this.smallerSize);
      let fe = "";
      for (let ge = 0; ge < this.smallerSize; ge++)
        for (let me = 0; me < this.smallerSize; me++)
          fe += H[ge][me] > ie ? "1" : "0";
      return fe;
    };
    const Q = [], se = ee;
    __webpack_require__(9307);
    const Y = (S, A) => {
      let { url: H, ...Z } = S;
      fetch(H, Z).then((ie) => {
        if (ie.ok)
          return ie.arrayBuffer().catch((fe) => {
            throw new Error(`Response is not a buffer for url ${H}. Error: ${fe.message}`);
          });
        throw new Error(`HTTP Status ${ie.status} for url ${H}`);
      }).then((ie) => A(null, ie)).catch((ie) => A(ie));
    }, be = -1, Ee = 1, Me = 2, ke = 4, oe = 8, ce = 16, xe = 32, Ce = "srcOver", _e = "dstOver", Be = "multiply", Pe = "add", Fe = "screen", We = "overlay", Qe = "darken", lt = "lighten", P = "hardLight", we = "difference", X = "exclusion", de = 1, Ze = 2, Re = 3;
    function rt(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a;
      return { r: (S.r * S.a + A.r * A.a * (1 - S.a)) / Z, g: (S.g * S.a + A.g * A.a * (1 - S.a)) / Z, b: (S.b * S.a + A.b * A.a * (1 - S.a)) / Z, a: Z };
    }
    function De(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a;
      return { r: (A.r * A.a + S.r * S.a * (1 - A.a)) / Z, g: (A.g * A.a + S.g * S.a * (1 - A.a)) / Z, b: (A.b * A.a + S.b * S.a * (1 - A.a)) / Z, a: Z };
    }
    function Je(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (ie * me + ie * (1 - A.a) + me * (1 - S.a)) / Z, g: (fe * ye + fe * (1 - A.a) + ye * (1 - S.a)) / Z, b: (ge * Ae + ge * (1 - A.a) + Ae * (1 - S.a)) / Z, a: Z };
    }
    function Ne(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a;
      return { r: (ie + A.r * A.a) / Z, g: (fe + A.g * A.a) / Z, b: (ge + A.b * A.a) / Z, a: Z };
    }
    function Ie(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (ie * A.a + me * S.a - ie * me + ie * (1 - A.a) + me * (1 - S.a)) / Z, g: (fe * A.a + ye * S.a - fe * ye + fe * (1 - A.a) + ye * (1 - S.a)) / Z, b: (ge * A.a + Ae * S.a - ge * Ae + ge * (1 - A.a) + Ae * (1 - S.a)) / Z, a: Z };
    }
    function at(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (2 * me <= A.a ? 2 * ie * me + ie * (1 - A.a) + me * (1 - S.a) : ie * (1 + A.a) + me * (1 + S.a) - 2 * me * ie - A.a * S.a) / Z, g: (2 * ye <= A.a ? 2 * fe * ye + fe * (1 - A.a) + ye * (1 - S.a) : fe * (1 + A.a) + ye * (1 + S.a) - 2 * ye * fe - A.a * S.a) / Z, b: (2 * Ae <= A.a ? 2 * ge * Ae + ge * (1 - A.a) + Ae * (1 - S.a) : ge * (1 + A.a) + Ae * (1 + S.a) - 2 * Ae * ge - A.a * S.a) / Z, a: Z };
    }
    function st(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (Math.min(ie * A.a, me * S.a) + ie * (1 - A.a) + me * (1 - S.a)) / Z, g: (Math.min(fe * A.a, ye * S.a) + fe * (1 - A.a) + ye * (1 - S.a)) / Z, b: (Math.min(ge * A.a, Ae * S.a) + ge * (1 - A.a) + Ae * (1 - S.a)) / Z, a: Z };
    }
    function tt(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (Math.max(ie * A.a, me * S.a) + ie * (1 - A.a) + me * (1 - S.a)) / Z, g: (Math.max(fe * A.a, ye * S.a) + fe * (1 - A.a) + ye * (1 - S.a)) / Z, b: (Math.max(ge * A.a, Ae * S.a) + ge * (1 - A.a) + Ae * (1 - S.a)) / Z, a: Z };
    }
    function mt(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (2 * ie <= S.a ? 2 * ie * me + ie * (1 - A.a) + me * (1 - S.a) : ie * (1 + A.a) + me * (1 + S.a) - 2 * me * ie - A.a * S.a) / Z, g: (2 * fe <= S.a ? 2 * fe * ye + fe * (1 - A.a) + ye * (1 - S.a) : fe * (1 + A.a) + ye * (1 + S.a) - 2 * ye * fe - A.a * S.a) / Z, b: (2 * ge <= S.a ? 2 * ge * Ae + ge * (1 - A.a) + Ae * (1 - S.a) : ge * (1 + A.a) + Ae * (1 + S.a) - 2 * Ae * ge - A.a * S.a) / Z, a: Z };
    }
    function It(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (ie + me - 2 * Math.min(ie * A.a, me * S.a)) / Z, g: (fe + ye - 2 * Math.min(fe * A.a, ye * S.a)) / Z, b: (ge + Ae - 2 * Math.min(ge * A.a, Ae * S.a)) / Z, a: Z };
    }
    function wt(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
      S.a *= H;
      const Z = A.a + S.a - A.a * S.a, ie = S.r * S.a, fe = S.g * S.a, ge = S.b * S.a, me = A.r * A.a, ye = A.g * A.a, Ae = A.b * A.a;
      return { r: (ie * A.a + me * S.a - 2 * ie * me + ie * (1 - A.a) + me * (1 - S.a)) / Z, g: (fe * A.a + ye * S.a - 2 * fe * ye + fe * (1 - A.a) + ye * (1 - S.a)) / Z, b: (ge * A.a + Ae * S.a - 2 * ge * Ae + ge * (1 - A.a) + Ae * (1 - S.a)) / Z, a: Z };
    }
    const ot = function(S, A) {
      for (var H = arguments.length, Z = new Array(H > 2 ? H - 2 : 0), ie = 2; ie < H; ie++)
        Z[ie - 2] = arguments[ie];
      return new Promise((fe, ge) => {
        Z.push((me, ye) => {
          me && ge(me), fe(ye);
        }), S.bind(A)(...Z);
      });
    }, kt = {}, Ft = (S, A) => {
      kt[S] = A;
    }, Rt = (S) => {
      const A = S.split("/").slice(-1);
      var H;
      return (H = A[A.length - 1].split(".").pop(), Object.entries(kt).find((Z) => Z[1].includes(H)) || [])[0];
    };
    var qt = __webpack_require__(5025), Lt = __webpack_require__.n(qt), Se = __webpack_require__(6551), Ye = __webpack_require__.n(Se), Ke = __webpack_require__(8834).lW;
    function ut(S) {
      return S._exif && S._exif.tags && S._exif.tags.Orientation || 1;
    }
    async function bt(S, A, H) {
      const Z = await async function(ie, fe) {
        const ge = await Lt().fromBuffer(ie);
        return ge ? ge.mime : fe ? Rt(fe) : null;
      }(S, A);
      if (typeof Z != "string")
        return H(new Error("Could not find MIME for Buffer <" + A + ">"));
      this._originalMime = Z.toLowerCase();
      try {
        const ie = this.getMIME();
        if (!this.constructor.decoders[ie])
          return o.call(this, "Unsupported MIME type: " + ie, H);
        this.bitmap = this.constructor.decoders[ie](S);
      } catch (ie) {
        return H.call(this, ie, this);
      }
      try {
        this._exif = Ye().create(S).parse(), function(ie) {
          if (ut(ie) < 2)
            return;
          const fe = function(me) {
            const ye = me.getWidth(), Ae = me.getHeight();
            switch (ut(me)) {
              case 1:
              default:
                return null;
              case 2:
                return function(Oe, ze) {
                  return [ye - Oe - 1, ze];
                };
              case 3:
                return function(Oe, ze) {
                  return [ye - Oe - 1, Ae - ze - 1];
                };
              case 4:
                return function(Oe, ze) {
                  return [Oe, Ae - ze - 1];
                };
              case 5:
                return function(Oe, ze) {
                  return [ze, Oe];
                };
              case 6:
                return function(Oe, ze) {
                  return [ze, Ae - Oe - 1];
                };
              case 7:
                return function(Oe, ze) {
                  return [ye - ze - 1, Ae - Oe - 1];
                };
              case 8:
                return function(Oe, ze) {
                  return [ye - ze - 1, Oe];
                };
            }
          }(ie), ge = ut(ie) > 4;
          (function(me, ye, Ae, Oe) {
            const ze = me.bitmap.data, it = me.bitmap.width, $e = Ke.alloc(ze.length);
            for (let Ge = 0; Ge < ye; Ge++)
              for (let He = 0; He < Ae; He++) {
                const [nt, ht] = Oe(Ge, He), pt = ye * He + Ge << 2, Et = it * ht + nt << 2, Pt = ze.readUInt32BE(Et);
                $e.writeUInt32BE(Pt, pt);
              }
            me.bitmap.data = $e, me.bitmap.width = ye, me.bitmap.height = Ae;
          })(ie, ge ? ie.bitmap.height : ie.bitmap.width, ge ? ie.bitmap.width : ie.bitmap.height, fe);
        }(this);
      } catch {
      }
      return H.call(this, null, this), this;
    }
    function At(S, A) {
      if (S === be && (S = this.getMIME()), typeof S != "string")
        return o.call(this, "mime must be a string", A);
      if (typeof A != "function")
        return o.call(this, "cb must be a function", A);
      if (S = S.toLowerCase(), this._rgba && this.constructor.hasAlpha[S] ? this.bitmap.data = Ke.from(this.bitmap.data) : this.bitmap.data = function(H, Z) {
        return new H(Z.bitmap.width, Z.bitmap.height, Z._background).composite(Z, 0, 0).bitmap;
      }(this.constructor, this).data, !this.constructor.encoders[S])
        return o.call(this, "Unsupported MIME type: " + S, A);
      {
        const H = this.constructor.encoders[S](this);
        H instanceof Promise ? H.then((Z) => {
          A.call(this, null, Z);
        }) : A.call(this, null, H);
      }
      return this;
    }
    function Ct(S) {
      return ot(At, this, S);
    }
    var vt = __webpack_require__(8834).lW;
    function Dt(S, A, H) {
      return (A = function(Z) {
        var ie = function(fe, ge) {
          if (typeof fe != "object" || fe === null)
            return fe;
          var me = fe[Symbol.toPrimitive];
          if (me !== void 0) {
            var ye = me.call(fe, "string");
            if (typeof ye != "object")
              return ye;
            throw new TypeError("@@toPrimitive must return a primitive value.");
          }
          return String(fe);
        }(Z);
        return typeof ie == "symbol" ? ie : String(ie);
      }(A)) in S ? Object.defineProperty(S, A, { value: H, enumerable: !0, configurable: !0, writable: !0 }) : S[A] = H, S;
    }
    const Nt = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_", Ut = [NaN, NaN];
    for (let S = 2; S < 65; S++) {
      const A = p()(p().BIN, Nt.slice(0, S))(new Array(65).join("1"));
      Ut.push(A.length);
    }
    function Gt() {
    }
    function Jt(S) {
      return Object.prototype.toString.call(S).toLowerCase().indexOf("arraybuffer") > -1;
    }
    function er(S) {
      const A = vt.alloc(S.byteLength), H = new Uint8Array(S);
      for (let Z = 0; Z < A.length; ++Z)
        A[Z] = H[Z];
      return A;
    }
    function Xt(S, A) {
      Y(S, (H, Z) => H ? A(H) : typeof Z == "object" && vt.isBuffer(Z) ? A(null, Z) : typeof Z == "object" && Jt(Z) ? A(null, er(Z)) : new Error(`Could not load Buffer from <${S.url}>`));
    }
    const or = { data: null, width: null, height: null };
    class Tt extends t() {
      constructor() {
        for (var A = arguments.length, H = new Array(A), Z = 0; Z < A; Z++)
          H[Z] = arguments[Z];
        super(), Dt(this, "bitmap", or), Dt(this, "_background", 0), Dt(this, "_originalMime", Tt.MIME_PNG), Dt(this, "_exif", null), Dt(this, "_rgba", !0), Dt(this, "writeAsync", (ye) => ot(this.write, this, ye)), Dt(this, "getBase64Async", (ye) => ot(this.getBase64, this, ye)), Dt(this, "getBuffer", At), Dt(this, "getBufferAsync", Ct), Dt(this, "getPixelColour", this.getPixelColor), Dt(this, "setPixelColour", this.setPixelColor);
        const ie = this;
        let fe = Gt;
        function ge() {
          for (var ye = arguments.length, Ae = new Array(ye), Oe = 0; Oe < ye; Oe++)
            Ae[Oe] = arguments[Oe];
          const [ze] = Ae;
          (ze || {}).methodName = "constructor", setTimeout(() => {
            ze && fe === Gt ? ie.emitError("constructor", ze) : ze || ie.emitMulti("constructor", "initialized"), fe.call(ie, ...Ae);
          }, 1);
        }
        if (Jt(H[0]) && (H[0] = er(H[0])), typeof H[0] == "number" && typeof H[1] == "number" || parseInt(H[0], 10) && parseInt(H[1], 10)) {
          const ye = parseInt(H[0], 10), Ae = parseInt(H[1], 10);
          if (fe = H[2], typeof H[2] == "number" && (this._background = H[2], fe = H[3]), typeof H[2] == "string" && (this._background = Tt.cssColorToHex(H[2]), fe = H[3]), fe === void 0 && (fe = Gt), typeof fe != "function")
            return o.call(this, "cb must be a function", ge);
          this.bitmap = { data: vt.alloc(ye * Ae * 4), width: ye, height: Ae };
          for (let Oe = 0; Oe < this.bitmap.data.length; Oe += 4)
            this.bitmap.data.writeUInt32BE(this._background, Oe);
          ge(null, this);
        } else if (typeof H[0] == "object" && H[0].url) {
          if (fe = H[1] || Gt, typeof fe != "function")
            return o.call(this, "cb must be a function", ge);
          Xt(H[0], (ye, Ae) => {
            if (ye)
              return o.call(this, ye, ge);
            this.parseBitmap(Ae, H[0].url, ge);
          });
        } else if (H[0] instanceof Tt) {
          const [ye] = H;
          if (fe = H[1], fe === void 0 && (fe = Gt), typeof fe != "function")
            return o.call(this, "cb must be a function", ge);
          this.bitmap = { data: vt.from(ye.bitmap.data), width: ye.bitmap.width, height: ye.bitmap.height }, this._quality = ye._quality, this._deflateLevel = ye._deflateLevel, this._deflateStrategy = ye._deflateStrategy, this._filterType = ye._filterType, this._rgba = ye._rgba, this._background = ye._background, this._originalMime = ye._originalMime, ge(null, this);
        } else if ((me = H[0]) && typeof me == "object" && typeof me.width == "number" && typeof me.height == "number" && (vt.isBuffer(me.data) || me.data instanceof Uint8Array || typeof Uint8ClampedArray == "function" && me.data instanceof Uint8ClampedArray) && (me.data.length === me.width * me.height * 4 || me.data.length === me.width * me.height * 3)) {
          const [ye] = H;
          fe = H[1] || Gt;
          const Ae = ye.width * ye.height * 4 === ye.data.length ? vt.from(ye.data) : function(Oe) {
            if (Oe.length % 3 != 0)
              throw new Error("Buffer length is incorrect");
            const ze = vt.allocUnsafe(Oe.length / 3 * 4);
            let it = 0;
            for (let $e = 0; $e < Oe.length; $e++)
              ze[it] = Oe[$e], ($e + 1) % 3 == 0 && (ze[++it] = 255), it++;
            return ze;
          }(ye.data);
          this.bitmap = { data: Ae, width: ye.width, height: ye.height }, ge(null, this);
        } else if (typeof H[0] == "string") {
          const ye = H[0];
          if (fe = H[1], fe === void 0 && (fe = Gt), typeof fe != "function")
            return o.call(this, "cb must be a function", ge);
          (function(Ae, Oe) {
            e() && typeof e().readFile == "function" && !Ae.match(/^(http|ftp)s?:\/\/./) ? e().readFile(Ae, Oe) : Xt({ url: Ae }, Oe);
          })(ye, (Ae, Oe) => {
            if (Ae)
              return o.call(this, Ae, ge);
            this.parseBitmap(Oe, ye, ge);
          });
        } else if (typeof H[0] == "object" && vt.isBuffer(H[0])) {
          const ye = H[0];
          if (fe = H[1], typeof fe != "function")
            return o.call(this, "cb must be a function", ge);
          this.parseBitmap(ye, null, ge);
        } else {
          fe = H[H.length - 1], typeof fe != "function" && (fe = H[H.length - 2], typeof fe != "function" && (fe = Gt));
          const ye = Tt.__extraConstructors.find((Ae) => Ae.test(...H));
          if (!ye)
            return o.call(this, "No matching constructor overloading was found. Please see the docs for how to call the Jimp constructor.", ge);
          new Promise((Ae, Oe) => {
            ye.run.call(this, Ae, Oe, ...H);
          }).then(() => ge(null, this)).catch(ge);
        }
        var me;
      }
      parseBitmap(A, H, Z) {
        bt.call(this, A, null, Z);
      }
      rgba(A, H) {
        return typeof A != "boolean" ? o.call(this, "bool must be a boolean, true for RGBA or false for RGB", H) : (this._rgba = A, r(H) && H.call(this, null, this), this);
      }
      emitMulti(A, H) {
        let Z = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
        Z = Object.assign(Z, { methodName: A, eventName: H }), this.emit("any", Z), A && this.emit(A, Z), this.emit(H, Z);
      }
      emitError(A, H) {
        this.emitMulti(A, "error", H);
      }
      getHeight() {
        return this.bitmap.height;
      }
      getWidth() {
        return this.bitmap.width;
      }
      inspect() {
        return "<Jimp " + (this.bitmap === or ? "pending..." : this.bitmap.width + "x" + this.bitmap.height) + ">";
      }
      toString() {
        return "[object Jimp]";
      }
      getMIME() {
        return this._originalMime || Tt.MIME_PNG;
      }
      getExtension() {
        const A = this.getMIME();
        return (kt[A.toLowerCase()] || [])[0];
      }
      write(A, H) {
        if (!e() || !e().createWriteStream)
          throw new Error("Cant access the filesystem. You can use the getBase64 method.");
        if (typeof A != "string")
          return o.call(this, "path must be a string", H);
        if (H === void 0 && (H = Gt), typeof H != "function")
          return o.call(this, "cb must be a function", H);
        const Z = Rt(A) || this.getMIME(), ie = i().parse(A);
        return ie.dir && e().mkdirSync(ie.dir, { recursive: !0 }), this.getBuffer(Z, (fe, ge) => {
          if (fe)
            return o.call(this, fe, H);
          const me = e().createWriteStream(A);
          me.on("open", () => {
            me.write(ge), me.end();
          }).on("error", (ye) => o.call(this, ye, H)), me.on("finish", () => {
            H.call(this, null, this);
          });
        }), this;
      }
      getBase64(A, H) {
        return A === Tt.AUTO && (A = this.getMIME()), typeof A != "string" ? o.call(this, "mime must be a string", H) : typeof H != "function" ? o.call(this, "cb must be a function", H) : (this.getBuffer(A, function(Z, ie) {
          if (Z)
            return o.call(this, Z, H);
          const fe = "data:" + A + ";base64," + ie.toString("base64");
          H.call(this, null, fe);
        }), this);
      }
      hash(A, H) {
        if (typeof (A = A || 64) == "function" && (H = A, A = 64), typeof A != "number")
          return o.call(this, "base must be a number", H);
        if (A < 2 || A > 64)
          return o.call(this, "base must be a number between 2 and 64", H);
        let Z = this.pHash();
        for (Z = p()(p().BIN, Nt.slice(0, A))(Z); Z.length < Ut[A]; )
          Z = "0" + Z;
        return r(H) && H.call(this, null, Z), Z;
      }
      pHash() {
        return new se().getHash(this);
      }
      distanceFromHash(A) {
        const H = new se(), Z = H.getHash(this);
        return H.distance(Z, A);
      }
      getPixelIndex(A, H, Z, ie) {
        let fe, ge;
        if (typeof Z == "function" && ie === void 0 && (ie = Z, Z = null), Z || (Z = Tt.EDGE_EXTEND), typeof A != "number" || typeof H != "number")
          return o.call(this, "x and y must be numbers", ie);
        fe = A = Math.round(A), ge = H = Math.round(H), Z === Tt.EDGE_EXTEND && (A < 0 && (fe = 0), A >= this.bitmap.width && (fe = this.bitmap.width - 1), H < 0 && (ge = 0), H >= this.bitmap.height && (ge = this.bitmap.height - 1)), Z === Tt.EDGE_WRAP && (A < 0 && (fe = this.bitmap.width + A), A >= this.bitmap.width && (fe = A % this.bitmap.width), H < 0 && (ge = this.bitmap.height + H), H >= this.bitmap.height && (ge = H % this.bitmap.height));
        let me = this.bitmap.width * ge + fe << 2;
        return (fe < 0 || fe >= this.bitmap.width) && (me = -1), (ge < 0 || ge >= this.bitmap.height) && (me = -1), r(ie) && ie.call(this, null, me), me;
      }
      getPixelColor(A, H, Z) {
        if (typeof A != "number" || typeof H != "number")
          return o.call(this, "x and y must be numbers", Z);
        A = Math.round(A), H = Math.round(H);
        const ie = this.getPixelIndex(A, H), fe = this.bitmap.data.readUInt32BE(ie);
        return r(Z) && Z.call(this, null, fe), fe;
      }
      setPixelColor(A, H, Z, ie) {
        if (typeof A != "number" || typeof H != "number" || typeof Z != "number")
          return o.call(this, "hex, x and y must be numbers", ie);
        H = Math.round(H), Z = Math.round(Z);
        const fe = this.getPixelIndex(H, Z);
        return this.bitmap.data.writeUInt32BE(A, fe), r(ie) && ie.call(this, null, this), this;
      }
      hasAlpha() {
        for (let A = 0; A < this.bitmap.height; A++)
          for (let H = 0; H < this.bitmap.width; H++) {
            const Z = this.bitmap.width * A + H << 2;
            if (this.bitmap.data[Z + 3] !== 255)
              return !0;
          }
        return !1;
      }
      scanIterator(A, H, Z, ie) {
        return typeof A != "number" || typeof H != "number" ? o.call(this, "x and y must be numbers") : typeof Z != "number" || typeof ie != "number" ? o.call(this, "w and h must be numbers") : function* (fe, ge, me, ye, Ae) {
          ge = Math.round(ge), me = Math.round(me), ye = Math.round(ye), Ae = Math.round(Ae);
          for (let Oe = me; Oe < me + Ae; Oe++)
            for (let ze = ge; ze < ge + ye; ze++) {
              const it = fe.bitmap.width * Oe + ze << 2;
              yield { x: ze, y: Oe, idx: it, image: fe };
            }
        }(this, A, H, Z, ie);
      }
    }
    function nr(S) {
      let A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Tt;
      Object.entries(S).forEach((H) => {
        let [Z, ie] = H;
        A[Z] = ie;
      });
    }
    function dr(S) {
      let A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : Tt;
      Object.entries(S).forEach((H) => {
        let [Z, ie] = H;
        A.prototype[Z] = ie;
      });
    }
    function y(S, A, H) {
      const Z = "before-" + A, ie = A.replace(/e$/, "") + "ed";
      Tt.prototype[S] = function() {
        let fe;
        for (var ge = arguments.length, me = new Array(ge), ye = 0; ye < ge; ye++)
          me[ye] = arguments[ye];
        const Ae = me[H.length - 1], Oe = this;
        let ze;
        typeof Ae == "function" ? (fe = function() {
          for (var it = arguments.length, $e = new Array(it), Ge = 0; Ge < it; Ge++)
            $e[Ge] = arguments[Ge];
          const [He, nt] = $e;
          He ? Oe.emitError(S, He) : Oe.emitMulti(S, ie, { [S]: nt }), Ae.apply(this, $e);
        }, me[me.length - 1] = fe) : fe = !1, this.emitMulti(S, Z);
        try {
          ze = H.apply(this, me), fe || this.emitMulti(S, ie, { [S]: ze });
        } catch (it) {
          it.methodName = S, this.emitError(S, it);
        }
        return ze;
      }, Tt.prototype[S + "Quiet"] = H;
    }
    function ue(S, A) {
      y(S, "change", A);
    }
    nr(d), dr({ composite: function(S, A, H) {
      let Z = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {}, ie = arguments.length > 4 ? arguments[4] : void 0;
      if (typeof Z == "function" && (ie = Z, Z = {}), !(S instanceof this.constructor))
        return o.call(this, "The source must be a Jimp image", ie);
      if (typeof A != "number" || typeof H != "number")
        return o.call(this, "x and y must be numbers", ie);
      let { mode: fe, opacitySource: ge, opacityDest: me } = Z;
      fe || (fe = Ce), (typeof ge != "number" || ge < 0 || ge > 1) && (ge = 1), (typeof me != "number" || me < 0 || me > 1) && (me = 1);
      const ye = l[fe];
      A = Math.round(A), H = Math.round(H);
      const Ae = this;
      return me !== 1 && Ae.opacity(me), S.scanQuiet(0, 0, S.bitmap.width, S.bitmap.height, function(Oe, ze, it) {
        const $e = Ae.getPixelIndex(A + Oe, H + ze, Re);
        if ($e === -1)
          return;
        const Ge = ye({ r: this.bitmap.data[it + 0] / 255, g: this.bitmap.data[it + 1] / 255, b: this.bitmap.data[it + 2] / 255, a: this.bitmap.data[it + 3] / 255 }, { r: Ae.bitmap.data[$e + 0] / 255, g: Ae.bitmap.data[$e + 1] / 255, b: Ae.bitmap.data[$e + 2] / 255, a: Ae.bitmap.data[$e + 3] / 255 }, ge);
        Ae.bitmap.data[$e + 0] = this.constructor.limit255(255 * Ge.r), Ae.bitmap.data[$e + 1] = this.constructor.limit255(255 * Ge.g), Ae.bitmap.data[$e + 2] = this.constructor.limit255(255 * Ge.b), Ae.bitmap.data[$e + 3] = this.constructor.limit255(255 * Ge.a);
      }), r(ie) && ie.call(this, null, this), this;
    } }), Tt.__extraConstructors = [], Tt.appendConstructorOption = function(S, A, H) {
      Tt.__extraConstructors.push({ name: S, test: A, run: H });
    }, Tt.read = function() {
      for (var S = arguments.length, A = new Array(S), H = 0; H < S; H++)
        A[H] = arguments[H];
      return new Promise((Z, ie) => {
        new Tt(...A, (fe, ge) => {
          fe ? ie(fe) : Z(ge);
        });
      });
    }, Tt.create = Tt.read, Tt.rgbaToInt = function(S, A, H, Z, ie) {
      if (typeof S != "number" || typeof A != "number" || typeof H != "number" || typeof Z != "number")
        return o.call(this, "r, g, b and a must be numbers", ie);
      if (S < 0 || S > 255)
        return o.call(this, "r must be between 0 and 255", ie);
      if ((A < 0 || A > 255) && o.call(this, "g must be between 0 and 255", ie), H < 0 || H > 255)
        return o.call(this, "b must be between 0 and 255", ie);
      if (Z < 0 || Z > 255)
        return o.call(this, "a must be between 0 and 255", ie);
      S = Math.round(S), H = Math.round(H), A = Math.round(A), Z = Math.round(Z);
      const fe = S * Math.pow(256, 3) + A * Math.pow(256, 2) + H * Math.pow(256, 1) + Z * Math.pow(256, 0);
      return r(ie) && ie.call(this, null, fe), fe;
    }, Tt.intToRGBA = function(S, A) {
      if (typeof S != "number")
        return o.call(this, "i must be a number", A);
      const H = {};
      return H.r = Math.floor(S / Math.pow(256, 3)), H.g = Math.floor((S - H.r * Math.pow(256, 3)) / Math.pow(256, 2)), H.b = Math.floor((S - H.r * Math.pow(256, 3) - H.g * Math.pow(256, 2)) / Math.pow(256, 1)), H.a = Math.floor((S - H.r * Math.pow(256, 3) - H.g * Math.pow(256, 2) - H.b * Math.pow(256, 1)) / Math.pow(256, 0)), r(A) && A.call(this, null, H), H;
    }, Tt.cssColorToHex = function(S) {
      return typeof (S = S || 0) == "number" ? Number(S) : parseInt(M(S).toHex8(), 16);
    }, Tt.limit255 = function(S) {
      return S = Math.max(S, 0), Math.min(S, 255);
    }, Tt.diff = function(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0.1;
      if (!(S instanceof Tt && A instanceof Tt))
        return o.call(this, "img1 and img2 must be an Jimp images");
      const Z = S.bitmap, ie = A.bitmap;
      if (Z.width === ie.width && Z.height === ie.height || (Z.width * Z.height > ie.width * ie.height ? S = S.cloneQuiet().resize(ie.width, ie.height) : A = A.cloneQuiet().resize(Z.width, Z.height)), typeof H != "number" || H < 0 || H > 1)
        return o.call(this, "threshold must be a number between 0 and 1");
      const fe = new Tt(Z.width, Z.height, 4294967295);
      return { percent: v()(Z.data, ie.data, fe.bitmap.data, fe.bitmap.width, fe.bitmap.height, { threshold: H }) / (fe.bitmap.width * fe.bitmap.height), image: fe };
    }, Tt.distance = function(S, A) {
      const H = new se(), Z = H.getHash(S), ie = H.getHash(A);
      return H.distance(Z, ie);
    }, Tt.compareHashes = function(S, A) {
      return new se().distance(S, A);
    }, Tt.colorDiff = function(S, A) {
      const H = (ie) => Math.pow(ie, 2), { max: Z } = Math;
      return S.a === 0 || S.a || (S.a = 255), A.a === 0 || A.a || (A.a = 255), (Z(H(S.r - A.r), H(S.r - A.r - S.a + A.a)) + Z(H(S.g - A.g), H(S.g - A.g - S.a + A.a)) + Z(H(S.b - A.b), H(S.b - A.b - S.a + A.a))) / 195075;
    }, y("clone", "clone", function(S) {
      const A = new Tt(this);
      return r(S) && S.call(A, null, A), A;
    }), ue("background", function(S, A) {
      return typeof S != "number" ? o.call(this, "hex must be a hexadecimal rgba value", A) : (this._background = S, r(A) && A.call(this, null, this), this);
    }), ue("scan", function(S, A, H, Z, ie, fe) {
      if (typeof S != "number" || typeof A != "number")
        return o.call(this, "x and y must be numbers", fe);
      if (typeof H != "number" || typeof Z != "number")
        return o.call(this, "w and h must be numbers", fe);
      if (typeof ie != "function")
        return o.call(this, "f must be a function", fe);
      const ge = n(this, S, A, H, Z, ie);
      return r(fe) && fe.call(this, null, ge), ge;
    });
    {
      let S;
      typeof window < "u" && typeof window == "object" && (S = window), typeof self < "u" && typeof self == "object" && (S = self), S.Jimp = Tt, S.Buffer = vt;
    }
    const pe = Tt;
    var ve = __webpack_require__(643), Te = __webpack_require__(2691), Ue = __webpack_require__.n(Te);
    const Le = "image/jpeg", qe = () => ({ mime: { [Le]: ["jpeg", "jpg", "jpe"] }, constants: { MIME_JPEG: Le }, decoders: { [Le]: Ue().decode }, encoders: { [Le]: (S) => Ue().encode(S.bitmap, S._quality).data }, class: { _quality: 100, quality(S, A) {
      return typeof S != "number" ? o.call(this, "n must be a number", A) : S < 0 || S > 100 ? o.call(this, "n must be a number 0 - 100", A) : (this._quality = Math.round(S), r(A) && A.call(this, null, this), this);
    } } });
    var je = __webpack_require__(9902);
    const et = "image/png", Ve = () => ({ mime: { [et]: ["png"] }, constants: { MIME_PNG: et, PNG_FILTER_AUTO: -1, PNG_FILTER_NONE: 0, PNG_FILTER_SUB: 1, PNG_FILTER_UP: 2, PNG_FILTER_AVERAGE: 3, PNG_FILTER_PATH: 4 }, hasAlpha: { [et]: !0 }, decoders: { [et]: je.PNG.sync.read }, encoders: { [et](S) {
      const A = new je.PNG({ width: S.bitmap.width, height: S.bitmap.height });
      return A.data = S.bitmap.data, je.PNG.sync.write(A, { deflateLevel: S._deflateLevel, deflateStrategy: S._deflateStrategy, filterType: S._filterType, colorType: typeof S._colorType == "number" ? S._colorType : S._rgba ? 6 : 2, inputHasAlpha: S._rgba });
    } }, class: { _deflateLevel: 9, _deflateStrategy: 3, _filterType: -1, _colorType: null, deflateLevel(S, A) {
      return typeof S != "number" ? o.call(this, "l must be a number", A) : S < 0 || S > 9 ? o.call(this, "l must be a number 0 - 9", A) : (this._deflateLevel = Math.round(S), r(A) && A.call(this, null, this), this);
    }, deflateStrategy(S, A) {
      return typeof S != "number" ? o.call(this, "s must be a number", A) : S < 0 || S > 3 ? o.call(this, "s must be a number 0 - 3", A) : (this._deflateStrategy = Math.round(S), r(A) && A.call(this, null, this), this);
    }, filterType(S, A) {
      return typeof S != "number" ? o.call(this, "n must be a number", A) : S < -1 || S > 4 ? o.call(this, "n must be -1 (auto) or a number 0 - 4", A) : (this._filterType = Math.round(S), r(A) && A.call(this, null, this), this);
    }, colorType(S, A) {
      return typeof S != "number" ? o.call(this, "s must be a number", A) : S !== 0 && S !== 2 && S !== 4 && S !== 6 ? o.call(this, "s must be a number 0, 2, 4, 6.", A) : (this._colorType = Math.round(S), r(A) && A.call(this, null, this), this);
    } } });
    var Xe = __webpack_require__(486), ft = __webpack_require__.n(Xe);
    const xt = "image/bmp", _t = "image/x-ms-bmp", ct = (S) => {
      return n({ bitmap: A = ft().decode(S) }, 0, 0, A.width, A.height, function(H, Z, ie) {
        const fe = this.bitmap.data[ie + 0], ge = this.bitmap.data[ie + 1], me = this.bitmap.data[ie + 2], ye = this.bitmap.data[ie + 3];
        this.bitmap.data[ie + 0] = ye, this.bitmap.data[ie + 1] = me, this.bitmap.data[ie + 2] = ge, this.bitmap.data[ie + 3] = A.is_with_alpha ? fe : 255;
      }).bitmap;
      var A;
    }, dt = (S) => ft().encode(function(A) {
      return n(A, 0, 0, A.bitmap.width, A.bitmap.height, function(H, Z, ie) {
        const fe = this.bitmap.data[ie + 0], ge = this.bitmap.data[ie + 1], me = this.bitmap.data[ie + 2], ye = this.bitmap.data[ie + 3];
        this.bitmap.data[ie + 0] = ye, this.bitmap.data[ie + 1] = me, this.bitmap.data[ie + 2] = ge, this.bitmap.data[ie + 3] = fe;
      }).bitmap;
    }(S)).data;
    var jt = __webpack_require__(9299), Bt = __webpack_require__.n(jt), Ht = __webpack_require__(8834).lW;
    const Wt = "image/tiff";
    var Zt = __webpack_require__(63), $t = __webpack_require__(9455), gt = __webpack_require__(8834).lW;
    const Qt = "image/gif", fr = [1, 57, 41, 21, 203, 34, 97, 73, 227, 91, 149, 62, 105, 45, 39, 137, 241, 107, 3, 173, 39, 71, 65, 238, 219, 101, 187, 87, 81, 151, 141, 133, 249, 117, 221, 209, 197, 187, 177, 169, 5, 153, 73, 139, 133, 127, 243, 233, 223, 107, 103, 99, 191, 23, 177, 171, 165, 159, 77, 149, 9, 139, 135, 131, 253, 245, 119, 231, 224, 109, 211, 103, 25, 195, 189, 23, 45, 175, 171, 83, 81, 79, 155, 151, 147, 9, 141, 137, 67, 131, 129, 251, 123, 30, 235, 115, 113, 221, 217, 53, 13, 51, 50, 49, 193, 189, 185, 91, 179, 175, 43, 169, 83, 163, 5, 79, 155, 19, 75, 147, 145, 143, 35, 69, 17, 67, 33, 65, 255, 251, 247, 243, 239, 59, 29, 229, 113, 111, 219, 27, 213, 105, 207, 51, 201, 199, 49, 193, 191, 47, 93, 183, 181, 179, 11, 87, 43, 85, 167, 165, 163, 161, 159, 157, 155, 77, 19, 75, 37, 73, 145, 143, 141, 35, 138, 137, 135, 67, 33, 131, 129, 255, 63, 250, 247, 61, 121, 239, 237, 117, 29, 229, 227, 225, 111, 55, 109, 216, 213, 211, 209, 207, 205, 203, 201, 199, 197, 195, 193, 48, 190, 47, 93, 185, 183, 181, 179, 178, 176, 175, 173, 171, 85, 21, 167, 165, 41, 163, 161, 5, 79, 157, 78, 154, 153, 19, 75, 149, 74, 147, 73, 144, 143, 71, 141, 140, 139, 137, 17, 135, 134, 133, 66, 131, 65, 129, 1], mr = [0, 9, 10, 10, 14, 12, 14, 14, 16, 15, 16, 15, 16, 15, 15, 17, 18, 17, 12, 18, 16, 17, 17, 19, 19, 18, 19, 18, 18, 19, 19, 19, 20, 19, 20, 20, 20, 20, 20, 20, 15, 20, 19, 20, 20, 20, 21, 21, 21, 20, 20, 20, 21, 18, 21, 21, 21, 21, 20, 21, 17, 21, 21, 21, 22, 22, 21, 22, 22, 21, 22, 21, 19, 22, 22, 19, 20, 22, 22, 21, 21, 21, 22, 22, 22, 18, 22, 22, 21, 22, 22, 23, 22, 20, 23, 22, 22, 23, 23, 21, 19, 21, 21, 21, 23, 23, 23, 22, 23, 23, 21, 23, 22, 23, 18, 22, 23, 20, 22, 23, 23, 23, 21, 22, 20, 22, 21, 22, 24, 24, 24, 24, 24, 22, 21, 24, 23, 23, 24, 21, 24, 23, 24, 22, 24, 24, 22, 24, 24, 22, 23, 24, 24, 24, 20, 23, 22, 23, 24, 24, 24, 24, 24, 24, 24, 23, 21, 23, 22, 23, 24, 24, 24, 22, 24, 24, 24, 23, 22, 24, 24, 25, 23, 25, 25, 23, 24, 25, 25, 24, 22, 25, 25, 25, 24, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 23, 25, 23, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 24, 22, 25, 25, 23, 25, 25, 20, 24, 25, 24, 25, 25, 22, 24, 25, 24, 25, 24, 25, 25, 24, 25, 25, 25, 25, 22, 25, 25, 25, 24, 25, 24, 25, 18];
    var lr = __webpack_require__(8834).lW;
    function hr(S, A, H, Z) {
      const ie = [0, 0, 0], fe = (A.length - 1) / 2;
      for (let ge = 0; ge < A.length; ge += 1)
        for (let me = 0; me < A[ge].length; me += 1) {
          const ye = S.getPixelIndex(H + ge - fe, Z + me - fe);
          ie[0] += S.bitmap.data[ye] * A[ge][me], ie[1] += S.bitmap.data[ye + 1] * A[ge][me], ie[2] += S.bitmap.data[ye + 2] * A[ge][me];
        }
      return ie;
    }
    const Yt = (S) => S != null;
    function ur(S) {
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, H, Z) {
        const ie = parseInt(0.2126 * this.bitmap.data[Z] + 0.7152 * this.bitmap.data[Z + 1] + 0.0722 * this.bitmap.data[Z + 2], 10);
        this.bitmap.data[Z] = ie, this.bitmap.data[Z + 1] = ie, this.bitmap.data[Z + 2] = ie;
      }), r(S) && S.call(this, null, this), this;
    }
    function ar(S, A) {
      let H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 50;
      return { r: (A.r - S.r) * (H / 100) + S.r, g: (A.g - S.g) * (H / 100) + S.g, b: (A.b - S.b) * (H / 100) + S.b };
    }
    function yr(S, A) {
      return S && Array.isArray(S) ? (S = S.map((H) => (H.apply !== "xor" && H.apply !== "mix" || (H.params[0] = M(H.params[0]).toRgb()), H)), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (H, Z, ie) => {
        let fe = { r: this.bitmap.data[ie], g: this.bitmap.data[ie + 1], b: this.bitmap.data[ie + 2] };
        const ge = (me, ye) => this.constructor.limit255(fe[me] + ye);
        S.forEach((me) => {
          if (me.apply === "mix")
            fe = ar(fe, me.params[0], me.params[1]);
          else if (me.apply === "tint")
            fe = ar(fe, { r: 255, g: 255, b: 255 }, me.params[0]);
          else if (me.apply === "shade")
            fe = ar(fe, { r: 0, g: 0, b: 0 }, me.params[0]);
          else if (me.apply === "xor")
            fe = { r: fe.r ^ me.params[0].r, g: fe.g ^ me.params[0].g, b: fe.b ^ me.params[0].b };
          else if (me.apply === "red")
            fe.r = ge("r", me.params[0]);
          else if (me.apply === "green")
            fe.g = ge("g", me.params[0]);
          else if (me.apply === "blue")
            fe.b = ge("b", me.params[0]);
          else {
            if (me.apply === "hue" && (me.apply = "spin"), fe = M(fe), !fe[me.apply])
              return o.call(this, "action " + me.apply + " not supported", A);
            fe = fe[me.apply](...me.params).toRgb();
          }
        }), this.bitmap.data[ie] = fe.r, this.bitmap.data[ie + 1] = fe.g, this.bitmap.data[ie + 2] = fe.b;
      }), r(A) && A.call(this, null, this), this) : o.call(this, "actions must be an array", A);
    }
    var Ir = __webpack_require__(8834).lW;
    function wr(S) {
      const A = [1, 9, 3, 11, 13, 5, 15, 7, 4, 12, 2, 10, 16, 8, 14, 6];
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(H, Z, ie) {
        const fe = A[((3 & Z) << 2) + H % 4];
        this.bitmap.data[ie] = Math.min(this.bitmap.data[ie] + fe, 255), this.bitmap.data[ie + 1] = Math.min(this.bitmap.data[ie + 1] + fe, 255), this.bitmap.data[ie + 2] = Math.min(this.bitmap.data[ie + 2] + fe, 255);
      }), r(S) && S.call(this, null, this), this;
    }
    var vr = __webpack_require__(8834).lW;
    function xr(S, A, H) {
      if (typeof S != "boolean" || typeof A != "boolean")
        return o.call(this, "horizontal and vertical must be Booleans", H);
      const Z = vr.alloc(this.bitmap.data.length);
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(ie, fe, ge) {
        const me = S ? this.bitmap.width - 1 - ie : ie, ye = A ? this.bitmap.height - 1 - fe : fe, Ae = this.bitmap.width * ye + me << 2, Oe = this.bitmap.data.readUInt32BE(ge);
        Z.writeUInt32BE(Oe, Ae);
      }), this.bitmap.data = vr.from(Z), r(H) && H.call(this, null, this), this;
    }
    function Ar() {
      const S = { r: new Array(256).fill(0), g: new Array(256).fill(0), b: new Array(256).fill(0) };
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, H, Z) {
        S.r[this.bitmap.data[Z + 0]]++, S.g[this.bitmap.data[Z + 1]]++, S.b[this.bitmap.data[Z + 2]]++;
      }), S;
    }
    const gr = function(S, A, H) {
      return 255 * (S - A) / (H - A);
    }, br = function(S) {
      return [S.findIndex((A) => A > 0), 255 - S.slice().reverse().findIndex((A) => A > 0)];
    };
    var Cr = __webpack_require__(8058), Pr = __webpack_require__.n(Cr);
    function pr(S, A) {
      let H = 0;
      for (let Z = 0; Z < A.length; Z++)
        if (S.chars[A[Z]]) {
          const ie = S.kernings[A[Z]] && S.kernings[A[Z]][A[Z + 1]] ? S.kernings[A[Z]][A[Z + 1]] : 0;
          H += (S.chars[A[Z]].xadvance || 0) + ie;
        }
      return H;
    }
    function Er(S, A, H) {
      const Z = A.split(" "), ie = [];
      let fe = [], ge = 0;
      return Z.forEach((me) => {
        const ye = [...fe, me].join(" "), Ae = pr(S, ye);
        Ae <= H ? (Ae > ge && (ge = Ae), fe.push(me)) : (ie.push(fe), fe = [me]);
      }), ie.push(fe), { lines: ie, longestLine: ge };
    }
    function _r(S, A, H) {
      const { lines: Z } = Er(S, A, H);
      return Z.length * S.common.lineHeight;
    }
    function Rr(S, A, H, Z, ie) {
      if (ie.width > 0 && ie.height > 0) {
        const fe = A.pages[ie.page];
        S.blit(fe, H + ie.xoffset, Z + ie.yoffset, ie.x, ie.y, ie.width, ie.height);
      }
      return S;
    }
    function Lr(S, A, H, Z, ie) {
      for (let fe = 0; fe < Z.length; fe++) {
        let ge;
        ge = S.chars[Z[fe]] ? Z[fe] : /\s/.test(Z[fe]) ? "" : "?";
        const me = S.chars[ge] || {}, ye = S.kernings[ge];
        Rr(this, S, A, H, me || {}), A += (ye && ye[Z[fe + 1]] ? ye[Z[fe + 1]] : 0) + (me.xadvance || ie);
      }
    }
    const Kt = "//../";
    function Vt(S, A, H, Z, ie, fe, ge) {
      this.widthOriginal = Math.abs(Math.floor(S) || 0), this.heightOriginal = Math.abs(Math.floor(A) || 0), this.targetWidth = Math.abs(Math.floor(H) || 0), this.targetHeight = Math.abs(Math.floor(Z) || 0), this.colorChannels = ie ? 4 : 3, this.interpolationPass = !!fe, this.resizeCallback = typeof ge == "function" ? ge : function() {
      }, this.targetWidthMultipliedByChannels = this.targetWidth * this.colorChannels, this.originalWidthMultipliedByChannels = this.widthOriginal * this.colorChannels, this.originalHeightMultipliedByChannels = this.heightOriginal * this.colorChannels, this.widthPassResultSize = this.targetWidthMultipliedByChannels * this.heightOriginal, this.finalResultSize = this.targetWidthMultipliedByChannels * this.targetHeight, this.initialize();
    }
    Vt.prototype.initialize = function() {
      if (!(this.widthOriginal > 0 && this.heightOriginal > 0 && this.targetWidth > 0 && this.targetHeight > 0))
        throw new Error("Invalid settings specified for the resizer.");
      this.configurePasses();
    }, Vt.prototype.configurePasses = function() {
      this.widthOriginal === this.targetWidth ? this.resizeWidth = this.bypassResizer : (this.ratioWeightWidthPass = this.widthOriginal / this.targetWidth, this.ratioWeightWidthPass < 1 && this.interpolationPass ? (this.initializeFirstPassBuffers(!0), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthInterpolatedRGBA : this.resizeWidthInterpolatedRGB) : (this.initializeFirstPassBuffers(!1), this.resizeWidth = this.colorChannels === 4 ? this.resizeWidthRGBA : this.resizeWidthRGB)), this.heightOriginal === this.targetHeight ? this.resizeHeight = this.bypassResizer : (this.ratioWeightHeightPass = this.heightOriginal / this.targetHeight, this.ratioWeightHeightPass < 1 && this.interpolationPass ? (this.initializeSecondPassBuffers(!0), this.resizeHeight = this.resizeHeightInterpolated) : (this.initializeSecondPassBuffers(!1), this.resizeHeight = this.colorChannels === 4 ? this.resizeHeightRGBA : this.resizeHeightRGB));
    }, Vt.prototype._resizeWidthInterpolatedRGBChannels = function(S, A) {
      const H = A ? 4 : 3, Z = this.ratioWeightWidthPass, ie = this.widthBuffer;
      let fe, ge, me = 0, ye = 0, Ae = 0, Oe = 0, ze = 0;
      for (fe = 0; me < 1 / 3; fe += H, me += Z)
        for (ye = fe, Ae = 0; ye < this.widthPassResultSize; Ae += this.originalWidthMultipliedByChannels, ye += this.targetWidthMultipliedByChannels)
          ie[ye] = S[Ae], ie[ye + 1] = S[Ae + 1], ie[ye + 2] = S[Ae + 2], A && (ie[ye + 3] = S[Ae + 3]);
      for (me -= 1 / 3, ge = this.widthOriginal - 1; me < ge; fe += H, me += Z)
        for (ze = me % 1, Oe = 1 - ze, ye = fe, Ae = Math.floor(me) * H; ye < this.widthPassResultSize; Ae += this.originalWidthMultipliedByChannels, ye += this.targetWidthMultipliedByChannels)
          ie[ye + 0] = S[Ae + 0] * Oe + S[Ae + H + 0] * ze, ie[ye + 1] = S[Ae + 1] * Oe + S[Ae + H + 1] * ze, ie[ye + 2] = S[Ae + 2] * Oe + S[Ae + H + 2] * ze, A && (ie[ye + 3] = S[Ae + 3] * Oe + S[Ae + H + 3] * ze);
      for (ge = this.originalWidthMultipliedByChannels - H; fe < this.targetWidthMultipliedByChannels; fe += H)
        for (ye = fe, Ae = ge; ye < this.widthPassResultSize; Ae += this.originalWidthMultipliedByChannels, ye += this.targetWidthMultipliedByChannels)
          ie[ye] = S[Ae], ie[ye + 1] = S[Ae + 1], ie[ye + 2] = S[Ae + 2], A && (ie[ye + 3] = S[Ae + 3]);
      return ie;
    }, Vt.prototype._resizeWidthRGBChannels = function(S, A) {
      const H = A ? 4 : 3, Z = this.ratioWeightWidthPass, ie = 1 / Z, fe = this.originalWidthMultipliedByChannels - H + 1, ge = this.targetWidthMultipliedByChannels - H + 1, me = this.outputWidthWorkBench, ye = this.widthBuffer, Ae = this.outputWidthWorkBenchOpaquePixelsCount;
      let Oe = 0, ze = 0, it = 0, $e = 0, Ge = 0, He = 0, nt = 0, ht = 1, pt = 0, Et = 0, Pt = 0, yt = 0;
      do {
        for (Ge = 0; Ge < this.originalHeightMultipliedByChannels; )
          me[Ge++] = 0, me[Ge++] = 0, me[Ge++] = 0, A && (me[Ge++] = 0, Ae[Ge / H - 1] = 0);
        Oe = Z;
        do {
          for (ze = 1 + it - $e, ht = Math.min(Oe, ze), Ge = 0, He = it; Ge < this.originalHeightMultipliedByChannels; He += fe)
            pt = S[He], Et = S[++He], Pt = S[++He], yt = A ? S[++He] : 255, me[Ge++] += (yt ? pt : 0) * ht, me[Ge++] += (yt ? Et : 0) * ht, me[Ge++] += (yt ? Pt : 0) * ht, A && (me[Ge++] += yt * ht, Ae[Ge / H - 1] += yt ? ht : 0);
          if (!(Oe >= ze)) {
            $e += Oe;
            break;
          }
          it += H, $e = it, Oe -= ze;
        } while (Oe > 0 && it < this.originalWidthMultipliedByChannels);
        for (Ge = 0, He = nt; Ge < this.originalHeightMultipliedByChannels; He += ge)
          Oe = A ? Ae[Ge / H] : 1, ht = A ? Oe ? 1 / Oe : 0 : ie, ye[He] = me[Ge++] * ht, ye[++He] = me[Ge++] * ht, ye[++He] = me[Ge++] * ht, A && (ye[++He] = me[Ge++] * ie);
        nt += H;
      } while (nt < this.targetWidthMultipliedByChannels);
      return ye;
    }, Vt.prototype._resizeHeightRGBChannels = function(S, A) {
      const H = this.ratioWeightHeightPass, Z = 1 / H, ie = this.outputHeightWorkBench, fe = this.heightBuffer, ge = this.outputHeightWorkBenchOpaquePixelsCount;
      let me = 0, ye = 0, Ae = 0, Oe = 0, ze = 0, it = 0, $e = 0, Ge = 1, He = 0, nt = 0, ht = 0, pt = 0;
      do {
        for (ze = 0; ze < this.targetWidthMultipliedByChannels; )
          ie[ze++] = 0, ie[ze++] = 0, ie[ze++] = 0, A && (ie[ze++] = 0, ge[ze / 4 - 1] = 0);
        me = H;
        do {
          for (ye = 1 + Ae - Oe, Ge = Math.min(me, ye), $e = Ae, ze = 0; ze < this.targetWidthMultipliedByChannels; )
            He = S[$e++], nt = S[$e++], ht = S[$e++], pt = A ? S[$e++] : 255, ie[ze++] += (pt ? He : 0) * Ge, ie[ze++] += (pt ? nt : 0) * Ge, ie[ze++] += (pt ? ht : 0) * Ge, A && (ie[ze++] += pt * Ge, ge[ze / 4 - 1] += pt ? Ge : 0);
          if (!(me >= ye)) {
            Oe += me;
            break;
          }
          Ae = $e, Oe = Ae, me -= ye;
        } while (me > 0 && Ae < this.widthPassResultSize);
        for (ze = 0; ze < this.targetWidthMultipliedByChannels; )
          me = A ? ge[ze / 4] : 1, Ge = A ? me ? 1 / me : 0 : Z, fe[it++] = Math.round(ie[ze++] * Ge), fe[it++] = Math.round(ie[ze++] * Ge), fe[it++] = Math.round(ie[ze++] * Ge), A && (fe[it++] = Math.round(ie[ze++] * Z));
      } while (it < this.finalResultSize);
      return fe;
    }, Vt.prototype.resizeWidthInterpolatedRGB = function(S) {
      return this._resizeWidthInterpolatedRGBChannels(S, !1);
    }, Vt.prototype.resizeWidthInterpolatedRGBA = function(S) {
      return this._resizeWidthInterpolatedRGBChannels(S, !0);
    }, Vt.prototype.resizeWidthRGB = function(S) {
      return this._resizeWidthRGBChannels(S, !1);
    }, Vt.prototype.resizeWidthRGBA = function(S) {
      return this._resizeWidthRGBChannels(S, !0);
    }, Vt.prototype.resizeHeightInterpolated = function(S) {
      const A = this.ratioWeightHeightPass, H = this.heightBuffer;
      let Z, ie = 0, fe = 0, ge = 0, me = 0, ye = 0, Ae = 0, Oe = 0;
      for (; ie < 1 / 3; ie += A)
        for (ge = 0; ge < this.targetWidthMultipliedByChannels; )
          H[fe++] = Math.round(S[ge++]);
      for (ie -= 1 / 3, Z = this.heightOriginal - 1; ie < Z; ie += A)
        for (Oe = ie % 1, Ae = 1 - Oe, me = Math.floor(ie) * this.targetWidthMultipliedByChannels, ye = me + this.targetWidthMultipliedByChannels, ge = 0; ge < this.targetWidthMultipliedByChannels; ++ge)
          H[fe++] = Math.round(S[me++] * Ae + S[ye++] * Oe);
      for (; fe < this.finalResultSize; )
        for (ge = 0, me = Z * this.targetWidthMultipliedByChannels; ge < this.targetWidthMultipliedByChannels; ++ge)
          H[fe++] = Math.round(S[me++]);
      return H;
    }, Vt.prototype.resizeHeightRGB = function(S) {
      return this._resizeHeightRGBChannels(S, !1);
    }, Vt.prototype.resizeHeightRGBA = function(S) {
      return this._resizeHeightRGBChannels(S, !0);
    }, Vt.prototype.resize = function(S) {
      this.resizeCallback(this.resizeHeight(this.resizeWidth(S)));
    }, Vt.prototype.bypassResizer = function(S) {
      return S;
    }, Vt.prototype.initializeFirstPassBuffers = function(S) {
      this.widthBuffer = this.generateFloatBuffer(this.widthPassResultSize), S || (this.outputWidthWorkBench = this.generateFloatBuffer(this.originalHeightMultipliedByChannels), this.colorChannels > 3 && (this.outputWidthWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.heightOriginal)));
    }, Vt.prototype.initializeSecondPassBuffers = function(S) {
      this.heightBuffer = this.generateUint8Buffer(this.finalResultSize), S || (this.outputHeightWorkBench = this.generateFloatBuffer(this.targetWidthMultipliedByChannels), this.colorChannels > 3 && (this.outputHeightWorkBenchOpaquePixelsCount = this.generateFloat64Buffer(this.targetWidth)));
    }, Vt.prototype.generateFloatBuffer = function(S) {
      try {
        return new Float32Array(S);
      } catch {
        return [];
      }
    }, Vt.prototype.generateFloat64Buffer = function(S) {
      try {
        return new Float64Array(S);
      } catch {
        return [];
      }
    }, Vt.prototype.generateUint8Buffer = function(S) {
      try {
        return new Uint8Array(S);
      } catch {
        return [];
      }
    };
    const Br = Vt;
    var Sr = __webpack_require__(8834).lW;
    const Or = { nearestNeighbor(S, A) {
      const H = S.width, Z = S.height, ie = A.width, fe = A.height, ge = S.data, me = A.data;
      for (let ye = 0; ye < fe; ye++)
        for (let Ae = 0; Ae < ie; Ae++) {
          let Oe = 4 * (ye * ie + Ae), ze = 4 * (Math.floor(ye * Z / fe) * H + Math.floor(Ae * H / ie));
          me[Oe++] = ge[ze++], me[Oe++] = ge[ze++], me[Oe++] = ge[ze++], me[Oe++] = ge[ze++];
        }
    }, bilinearInterpolation(S, A) {
      const H = S.width, Z = S.height, ie = A.width, fe = A.height, ge = S.data, me = A.data, ye = function(Oe, ze, it, $e, Ge) {
        return ze === $e ? it : Math.round((Oe - ze) * Ge + ($e - Oe) * it);
      }, Ae = function(Oe, ze, it, $e, Ge, He, nt, ht) {
        let pt = 4 * (nt * H + $e) + ze, Et = 4 * (nt * H + Ge) + ze;
        const Pt = ye(it, $e, ge[pt], Ge, ge[Et]);
        if (ht === nt)
          me[Oe + ze] = Pt;
        else {
          pt = 4 * (ht * H + $e) + ze, Et = 4 * (ht * H + Ge) + ze;
          const yt = ye(it, $e, ge[pt], Ge, ge[Et]);
          me[Oe + ze] = ye(He, nt, Pt, ht, yt);
        }
      };
      for (let Oe = 0; Oe < fe; Oe++)
        for (let ze = 0; ze < ie; ze++) {
          const it = 4 * (Oe * ie + ze), $e = ze * H / ie, Ge = Math.floor($e), He = Math.min(Math.ceil($e), H - 1), nt = Oe * Z / fe, ht = Math.floor(nt), pt = Math.min(Math.ceil(nt), Z - 1);
          Ae(it, 0, $e, Ge, He, nt, ht, pt), Ae(it, 1, $e, Ge, He, nt, ht, pt), Ae(it, 2, $e, Ge, He, nt, ht, pt), Ae(it, 3, $e, Ge, He, nt, ht, pt);
        }
    }, _interpolate2D(S, A, H, Z) {
      const ie = S.data, fe = A.data, ge = S.width, me = S.height, ye = A.width, Ae = A.height, Oe = Math.max(1, Math.floor(ge / ye)), ze = ye * Oe, it = Math.max(1, Math.floor(me / Ae)), $e = Ae * it, Ge = Sr.alloc(ze * me * 4);
      for (let ht = 0; ht < me; ht++)
        for (let pt = 0; pt < ze; pt++) {
          const Et = pt * (ge - 1) / ze, Pt = Math.floor(Et), yt = Et - Pt, Mt = 4 * (ht * ge + Pt), St = 4 * (ht * ze + pt);
          for (let Ot = 0; Ot < 4; Ot++) {
            const zt = Mt + Ot, tr = Pt > 0 ? ie[zt - 4] : 2 * ie[zt] - ie[zt + 4], rr = ie[zt], sr = ie[zt + 4], cr = Pt < ge - 2 ? ie[zt + 8] : 2 * ie[zt + 4] - ie[zt];
            Ge[St + Ot] = Z(tr, rr, sr, cr, yt);
          }
        }
      const He = Sr.alloc(ze * $e * 4);
      for (let ht = 0; ht < $e; ht++)
        for (let pt = 0; pt < ze; pt++) {
          const Et = ht * (me - 1) / $e, Pt = Math.floor(Et), yt = Et - Pt, Mt = 4 * (Pt * ze + pt), St = 4 * (ht * ze + pt);
          for (let Ot = 0; Ot < 4; Ot++) {
            const zt = Mt + Ot, tr = Pt > 0 ? Ge[zt - 4 * ze] : 2 * Ge[zt] - Ge[zt + 4 * ze], rr = Ge[zt], sr = Ge[zt + 4 * ze], cr = Pt < me - 2 ? Ge[zt + 8 * ze] : 2 * Ge[zt + 4 * ze] - Ge[zt];
            He[St + Ot] = Z(tr, rr, sr, cr, yt);
          }
        }
      const nt = Oe * it;
      if (nt > 1)
        for (let ht = 0; ht < Ae; ht++)
          for (let pt = 0; pt < ye; pt++) {
            let Et = 0, Pt = 0, yt = 0, Mt = 0, St = 0;
            for (let zt = 0; zt < it; zt++) {
              const tr = ht * it + zt;
              for (let rr = 0; rr < Oe; rr++) {
                const sr = 4 * (tr * ze + (pt * Oe + rr)), cr = He[sr + 3];
                cr && (Et += He[sr], Pt += He[sr + 1], yt += He[sr + 2], St++), Mt += cr;
              }
            }
            const Ot = 4 * (ht * ye + pt);
            fe[Ot] = St ? Math.round(Et / St) : 0, fe[Ot + 1] = St ? Math.round(Pt / St) : 0, fe[Ot + 2] = St ? Math.round(yt / St) : 0, fe[Ot + 3] = Math.round(Mt / nt);
          }
      else
        A.data = He;
    }, bicubicInterpolation(S, A, H) {
      return this._interpolate2D(S, A, H, function(Z, ie, fe, ge, me) {
        const ye = ge - fe - Z + ie, Ae = Z - ie - ye, Oe = fe - Z, ze = ie;
        return Math.max(0, Math.min(255, ye * (me * me * me) + Ae * (me * me) + Oe * me + ze));
      });
    }, hermiteInterpolation(S, A, H) {
      return this._interpolate2D(S, A, H, function(Z, ie, fe, ge, me) {
        const ye = ie, Ae = 0.5 * (fe - Z), Oe = Z - 2.5 * ie + 2 * fe - 0.5 * ge, ze = 0.5 * (ge - Z) + 1.5 * (ie - fe);
        return Math.max(0, Math.min(255, Math.round(((ze * me + Oe) * me + Ae) * me + ye)));
      });
    }, bezierInterpolation(S, A, H) {
      return this._interpolate2D(S, A, H, function(Z, ie, fe, ge, me) {
        const ye = 1 - me, Ae = ie * ye * ye * ye, Oe = 3 * (ie + (fe - Z) / 4) * ye * ye * me, ze = 3 * (fe - (ge - ie) / 4) * ye * me * me, it = fe * me * me * me;
        return Math.max(0, Math.min(255, Math.round(Ae + Oe + ze + it)));
      });
    } }, kr = Or;
    var Mr = __webpack_require__(8834).lW, Tr = __webpack_require__(8834).lW;
    function zr(S) {
      if (Math.abs(S) % 90 != 0)
        throw new Error("Unsupported matrix rotation degree");
      if (S %= 360, Math.abs(S) === 0)
        return;
      const A = this.bitmap.width, H = this.bitmap.height;
      let Z;
      switch (S) {
        case 90:
        case -270:
          Z = 90;
          break;
        case 180:
        case -180:
          Z = 180;
          break;
        case 270:
        case -90:
          Z = -90;
          break;
        default:
          throw new Error("Unsupported matrix rotation degree");
      }
      const ie = Z === 180 ? A : H, fe = Z === 180 ? H : A, ge = Tr.alloc(this.bitmap.data.length);
      function me(Oe, ze) {
        return function(it, $e) {
          return $e * Oe + it << 2;
        };
      }
      const ye = me(A), Ae = me(ie);
      for (let Oe = 0; Oe < A; Oe++)
        for (let ze = 0; ze < H; ze++) {
          const it = ye(Oe, ze), $e = this.bitmap.data.readUInt32BE(it);
          let Ge;
          switch (Z) {
            case 90:
              Ge = Ae(ze, A - Oe - 1);
              break;
            case -90:
              Ge = Ae(H - ze - 1, Oe);
              break;
            case 180:
              Ge = Ae(A - Oe - 1, H - ze - 1);
              break;
            default:
              throw new Error("Unsupported matrix rotation angle");
          }
          ge.writeUInt32BE($e, Ge);
        }
      this.bitmap.data = ge, this.bitmap.width = ie, this.bitmap.height = fe;
    }
    function Dr(S, A) {
      const H = (S %= 360) * Math.PI / 180, Z = Math.cos(H), ie = Math.sin(H);
      let fe = this.bitmap.width, ge = this.bitmap.height;
      if (A === !0 || typeof A == "string") {
        fe = Math.ceil(Math.abs(this.bitmap.width * Z) + Math.abs(this.bitmap.height * ie)) + 1, ge = Math.ceil(Math.abs(this.bitmap.width * ie) + Math.abs(this.bitmap.height * Z)) + 1, fe % 2 != 0 && fe++, ge % 2 != 0 && ge++;
        const $e = this.cloneQuiet();
        this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(He, nt, ht) {
          this.bitmap.data.writeUInt32BE(this._background, ht);
        });
        const Ge = Math.max(fe, ge, this.bitmap.width, this.bitmap.height);
        this.resize(Ge, Ge, A), this.blit($e, this.bitmap.width / 2 - $e.bitmap.width / 2, this.bitmap.height / 2 - $e.bitmap.height / 2);
      }
      const me = this.bitmap.width, ye = this.bitmap.height, Ae = Tr.alloc(this.bitmap.data.length);
      function Oe($e, Ge) {
        return function(He, nt) {
          return { x: He + $e, y: nt + Ge };
        };
      }
      const ze = Oe(-me / 2, -ye / 2), it = Oe(me / 2 + 0.5, ye / 2 + 0.5);
      for (let $e = 1; $e <= ye; $e++)
        for (let Ge = 1; Ge <= me; Ge++) {
          const He = ze(Ge, $e), nt = it(Z * He.x - ie * He.y, Z * He.y + ie * He.x), ht = me * ($e - 1) + Ge - 1 << 2;
          if (nt.x >= 0 && nt.x < me && nt.y >= 0 && nt.y < ye) {
            const pt = (me * (0 | nt.y) + nt.x | 0) << 2, Et = this.bitmap.data.readUInt32BE(pt);
            Ae.writeUInt32BE(Et, ht);
          } else
            Ae.writeUInt32BE(this._background, ht);
        }
      if (this.bitmap.data = Ae, A === !0 || typeof A == "string") {
        const $e = me / 2 - fe / 2, Ge = ye / 2 - ge / 2;
        this.crop($e, Ge, fe, ge);
      }
    }
    const Nr = [() => ({ blit(S, A, H, Z, ie, fe, ge, me) {
      if (!(S instanceof this.constructor))
        return o.call(this, "The source must be a Jimp image", me);
      if (typeof A != "number" || typeof H != "number")
        return o.call(this, "x and y must be numbers", me);
      if (typeof Z == "function")
        me = Z, Z = 0, ie = 0, fe = S.bitmap.width, ge = S.bitmap.height;
      else {
        if (typeof Z != typeof ie || typeof ie != typeof fe || typeof fe != typeof ge)
          return o.call(this, "srcx, srcy, srcw, srch must be numbers", me);
        Z = Z || 0, ie = ie || 0, fe = fe || S.bitmap.width, ge = ge || S.bitmap.height;
      }
      A = Math.round(A), H = Math.round(H), Z = Math.round(Z), ie = Math.round(ie), fe = Math.round(fe), ge = Math.round(ge);
      const ye = this.bitmap.width, Ae = this.bitmap.height, Oe = this;
      return S.scanQuiet(Z, ie, fe, ge, function(ze, it, $e) {
        const Ge = A + ze - Z, He = H + it - ie;
        if (Ge >= 0 && He >= 0 && ye - Ge > 0 && Ae - He > 0) {
          const nt = Oe.getPixelIndex(Ge, He), ht = { r: this.bitmap.data[$e], g: this.bitmap.data[$e + 1], b: this.bitmap.data[$e + 2], a: this.bitmap.data[$e + 3] }, pt = { r: Oe.bitmap.data[nt], g: Oe.bitmap.data[nt + 1], b: Oe.bitmap.data[nt + 2], a: Oe.bitmap.data[nt + 3] };
          Oe.bitmap.data[nt] = (ht.a * (ht.r - pt.r) - pt.r + 255 >> 8) + pt.r, Oe.bitmap.data[nt + 1] = (ht.a * (ht.g - pt.g) - pt.g + 255 >> 8) + pt.g, Oe.bitmap.data[nt + 2] = (ht.a * (ht.b - pt.b) - pt.b + 255 >> 8) + pt.b, Oe.bitmap.data[nt + 3] = this.constructor.limit255(pt.a + ht.a);
        }
      }), r(me) && me.call(this, null, this), this;
    } }), () => ({ blur(S, A) {
      if (typeof S != "number")
        return o.call(this, "r must be a number", A);
      if (S < 1)
        return o.call(this, "r must be greater than 0", A);
      let H, Z, ie, fe, ge, me, ye, Ae, Oe, ze, it, $e, Ge, He;
      const nt = this.bitmap.width - 1, ht = this.bitmap.height - 1, pt = S + 1, Et = fr[S], Pt = mr[S], yt = [], Mt = [], St = [], Ot = [], zt = [], tr = [];
      let rr = 2;
      for (; rr-- > 0; ) {
        for ($e = 0, Ge = 0, me = 0; me < this.bitmap.height; me++) {
          for (H = this.bitmap.data[Ge] * pt, Z = this.bitmap.data[Ge + 1] * pt, ie = this.bitmap.data[Ge + 2] * pt, fe = this.bitmap.data[Ge + 3] * pt, ye = 1; ye <= S; ye++)
            Ae = Ge + ((ye > nt ? nt : ye) << 2), H += this.bitmap.data[Ae++], Z += this.bitmap.data[Ae++], ie += this.bitmap.data[Ae++], fe += this.bitmap.data[Ae];
          for (ge = 0; ge < this.bitmap.width; ge++)
            yt[$e] = H, Mt[$e] = Z, St[$e] = ie, Ot[$e] = fe, me === 0 && (zt[ge] = ((Ae = ge + pt) < nt ? Ae : nt) << 2, tr[ge] = (Ae = ge - S) > 0 ? Ae << 2 : 0), Oe = Ge + zt[ge], ze = Ge + tr[ge], H += this.bitmap.data[Oe++] - this.bitmap.data[ze++], Z += this.bitmap.data[Oe++] - this.bitmap.data[ze++], ie += this.bitmap.data[Oe++] - this.bitmap.data[ze++], fe += this.bitmap.data[Oe] - this.bitmap.data[ze], $e++;
          Ge += this.bitmap.width << 2;
        }
        for (ge = 0; ge < this.bitmap.width; ge++) {
          for (it = ge, H = yt[it] * pt, Z = Mt[it] * pt, ie = St[it] * pt, fe = Ot[it] * pt, ye = 1; ye <= S; ye++)
            it += ye > ht ? 0 : this.bitmap.width, H += yt[it], Z += Mt[it], ie += St[it], fe += Ot[it];
          for ($e = ge << 2, me = 0; me < this.bitmap.height; me++)
            He = fe * Et >>> Pt, this.bitmap.data[$e + 3] = He, He > 255 && (this.bitmap.data[$e + 3] = 255), He > 0 ? (He = 255 / He, this.bitmap.data[$e] = (H * Et >>> Pt) * He, this.bitmap.data[$e + 1] = (Z * Et >>> Pt) * He, this.bitmap.data[$e + 2] = (ie * Et >>> Pt) * He) : (this.bitmap.data[$e + 2] = 0, this.bitmap.data[$e + 1] = 0, this.bitmap.data[$e] = 0), ge === 0 && (zt[me] = ((Ae = me + pt) < ht ? Ae : ht) * this.bitmap.width, tr[me] = (Ae = me - S) > 0 ? Ae * this.bitmap.width : 0), Oe = ge + zt[me], ze = ge + tr[me], H += yt[Oe] - yt[ze], Z += Mt[Oe] - Mt[ze], ie += St[Oe] - St[ze], fe += Ot[Oe] - Ot[ze], $e += this.bitmap.width << 2;
        }
      }
      return r(A) && A.call(this, null, this), this;
    } }), () => ({ circle() {
      let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, A = arguments.length > 1 ? arguments[1] : void 0;
      typeof S == "function" && (A = S, S = {});
      const H = S.radius || (this.bitmap.width > this.bitmap.height ? this.bitmap.height : this.bitmap.width) / 2, Z = typeof S.x == "number" ? S.x : this.bitmap.width / 2, ie = typeof S.y == "number" ? S.y : this.bitmap.height / 2;
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(fe, ge, me) {
        const ye = Math.sqrt(Math.pow(fe - Z, 2) + Math.pow(ge - ie, 2));
        H - ye <= 0 ? this.bitmap.data[me + 3] = 0 : H - ye < 1 && (this.bitmap.data[me + 3] = 255 * (H - ye));
      }), r(A) && A.call(this, null, this), this;
    } }), () => ({ brightness(S, A) {
      return typeof S != "number" ? o.call(this, "val must be numbers", A) : S < -1 || S > 1 ? o.call(this, "val must be a number between -1 and +1", A) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(H, Z, ie) {
        S < 0 ? (this.bitmap.data[ie] *= 1 + S, this.bitmap.data[ie + 1] *= 1 + S, this.bitmap.data[ie + 2] *= 1 + S) : (this.bitmap.data[ie] += (255 - this.bitmap.data[ie]) * S, this.bitmap.data[ie + 1] += (255 - this.bitmap.data[ie + 1]) * S, this.bitmap.data[ie + 2] += (255 - this.bitmap.data[ie + 2]) * S);
      }), r(A) && A.call(this, null, this), this);
    }, contrast(S, A) {
      if (typeof S != "number")
        return o.call(this, "val must be numbers", A);
      if (S < -1 || S > 1)
        return o.call(this, "val must be a number between -1 and +1", A);
      const H = (S + 1) / (1 - S);
      function Z(ie) {
        return (ie = Math.floor(H * (ie - 127) + 127)) < 0 ? 0 : ie > 255 ? 255 : ie;
      }
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(ie, fe, ge) {
        this.bitmap.data[ge] = Z(this.bitmap.data[ge]), this.bitmap.data[ge + 1] = Z(this.bitmap.data[ge + 1]), this.bitmap.data[ge + 2] = Z(this.bitmap.data[ge + 2]);
      }), r(A) && A.call(this, null, this), this;
    }, posterize(S, A) {
      return typeof S != "number" ? o.call(this, "n must be numbers", A) : (S < 2 && (S = 2), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(H, Z, ie) {
        this.bitmap.data[ie] = Math.floor(this.bitmap.data[ie] / 255 * (S - 1)) / (S - 1) * 255, this.bitmap.data[ie + 1] = Math.floor(this.bitmap.data[ie + 1] / 255 * (S - 1)) / (S - 1) * 255, this.bitmap.data[ie + 2] = Math.floor(this.bitmap.data[ie + 2] / 255 * (S - 1)) / (S - 1) * 255;
      }), r(A) && A.call(this, null, this), this);
    }, greyscale: ur, grayscale: ur, opacity(S, A) {
      return typeof S != "number" ? o.call(this, "f must be a number", A) : S < 0 || S > 1 ? o.call(this, "f must be a number from 0 to 1", A) : (this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(H, Z, ie) {
        const fe = this.bitmap.data[ie + 3] * S;
        this.bitmap.data[ie + 3] = fe;
      }), r(A) && A.call(this, null, this), this);
    }, sepia(S) {
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, H, Z) {
        let ie = this.bitmap.data[Z], fe = this.bitmap.data[Z + 1], ge = this.bitmap.data[Z + 2];
        ie = 0.393 * ie + 0.769 * fe + 0.189 * ge, fe = 0.349 * ie + 0.686 * fe + 0.168 * ge, ge = 0.272 * ie + 0.534 * fe + 0.131 * ge, this.bitmap.data[Z] = ie < 255 ? ie : 255, this.bitmap.data[Z + 1] = fe < 255 ? fe : 255, this.bitmap.data[Z + 2] = ge < 255 ? ge : 255;
      }), r(S) && S.call(this, null, this), this;
    }, fade(S, A) {
      return typeof S != "number" ? o.call(this, "f must be a number", A) : S < 0 || S > 1 ? o.call(this, "f must be a number from 0 to 1", A) : (this.opacity(1 - S), r(A) && A.call(this, null, this), this);
    }, convolution(S, A, H) {
      typeof A == "function" && H === void 0 && (H = A, A = null), A || (A = this.constructor.EDGE_EXTEND);
      const Z = lr.from(this.bitmap.data), ie = S.length, fe = S[0].length, ge = Math.floor(ie / 2), me = Math.floor(fe / 2), ye = -ge, Ae = -me;
      let Oe, ze, it, $e, Ge, He, nt, ht, pt, Et;
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(Pt, yt, Mt) {
        $e = 0, it = 0, ze = 0;
        for (let St = ye; St <= ge; St++)
          for (let Ot = Ae; Ot <= me; Ot++)
            ht = Pt + Ot, pt = yt + St, Oe = S[St + ge][Ot + me], Et = this.getPixelIndex(ht, pt, A), Et === -1 ? (nt = 0, He = 0, Ge = 0) : (Ge = this.bitmap.data[Et + 0], He = this.bitmap.data[Et + 1], nt = this.bitmap.data[Et + 2]), ze += Oe * Ge, it += Oe * He, $e += Oe * nt;
        ze < 0 && (ze = 0), it < 0 && (it = 0), $e < 0 && ($e = 0), ze > 255 && (ze = 255), it > 255 && (it = 255), $e > 255 && ($e = 255), Z[Mt + 0] = ze, Z[Mt + 1] = it, Z[Mt + 2] = $e;
      }), this.bitmap.data = Z, r(H) && H.call(this, null, this), this;
    }, opaque(S) {
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, H, Z) {
        this.bitmap.data[Z + 3] = 255;
      }), r(S) && S.call(this, null, this), this;
    }, pixelate(S, A, H, Z, ie, fe) {
      if (typeof A == "function")
        fe = A, ie = null, Z = null, H = null, A = null;
      else {
        if (typeof S != "number")
          return o.call(this, "size must be a number", fe);
        if (Yt(A) && typeof A != "number")
          return o.call(this, "x must be a number", fe);
        if (Yt(H) && typeof H != "number")
          return o.call(this, "y must be a number", fe);
        if (Yt(Z) && typeof Z != "number")
          return o.call(this, "w must be a number", fe);
        if (Yt(ie) && typeof ie != "number")
          return o.call(this, "h must be a number", fe);
      }
      const ge = [[1 / 16, 2 / 16, 1 / 16], [2 / 16, 0.25, 2 / 16], [1 / 16, 2 / 16, 1 / 16]];
      A = A || 0, H = H || 0, Z = Yt(Z) ? Z : this.bitmap.width - A, ie = Yt(ie) ? ie : this.bitmap.height - H;
      const me = this.cloneQuiet();
      return this.scanQuiet(A, H, Z, ie, function(ye, Ae, Oe) {
        ye = S * Math.floor(ye / S), Ae = S * Math.floor(Ae / S);
        const ze = hr(me, ge, ye, Ae);
        this.bitmap.data[Oe] = ze[0], this.bitmap.data[Oe + 1] = ze[1], this.bitmap.data[Oe + 2] = ze[2];
      }), r(fe) && fe.call(this, null, this), this;
    }, convolute(S, A, H, Z, ie, fe) {
      if (!Array.isArray(S))
        return o.call(this, "the kernel must be an array", fe);
      if (typeof A == "function")
        fe = A, A = null, H = null, Z = null, ie = null;
      else {
        if (Yt(A) && typeof A != "number")
          return o.call(this, "x must be a number", fe);
        if (Yt(H) && typeof H != "number")
          return o.call(this, "y must be a number", fe);
        if (Yt(Z) && typeof Z != "number")
          return o.call(this, "w must be a number", fe);
        if (Yt(ie) && typeof ie != "number")
          return o.call(this, "h must be a number", fe);
      }
      A = Yt(A) ? A : 0, H = Yt(H) ? H : 0, Z = Yt(Z) ? Z : this.bitmap.width - A, ie = Yt(ie) ? ie : this.bitmap.height - H;
      const ge = this.cloneQuiet();
      return this.scanQuiet(A, H, Z, ie, function(me, ye, Ae) {
        const Oe = hr(ge, S, me, ye);
        this.bitmap.data[Ae] = this.constructor.limit255(Oe[0]), this.bitmap.data[Ae + 1] = this.constructor.limit255(Oe[1]), this.bitmap.data[Ae + 2] = this.constructor.limit255(Oe[2]);
      }), r(fe) && fe.call(this, null, this), this;
    }, color: yr, colour: yr }), () => ({ contain(S, A, H, Z, ie) {
      if (typeof S != "number" || typeof A != "number")
        return o.call(this, "w and h must be numbers", ie);
      typeof H == "string" && (typeof Z == "function" && ie === void 0 && (ie = Z), Z = H, H = null), typeof H == "function" && (ie === void 0 && (ie = H), Z = null, H = null), typeof Z == "function" && ie === void 0 && (ie = Z, Z = null);
      const fe = 7 & (H = H || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), ge = H >> 3;
      if ((fe === 0 || fe & fe - 1) && (ge === 0 || ge & ge - 1))
        return o.call(this, "only use one flag per alignment direction", ie);
      const me = fe >> 1, ye = ge >> 1, Ae = S / A > this.bitmap.width / this.bitmap.height ? A / this.bitmap.height : S / this.bitmap.width, Oe = this.cloneQuiet().scale(Ae, Z);
      return this.resize(S, A, Z), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(ze, it, $e) {
        this.bitmap.data.writeUInt32BE(this._background, $e);
      }), this.blit(Oe, (this.bitmap.width - Oe.bitmap.width) / 2 * me, (this.bitmap.height - Oe.bitmap.height) / 2 * ye), r(ie) && ie.call(this, null, this), this;
    } }), () => ({ cover(S, A, H, Z, ie) {
      if (typeof S != "number" || typeof A != "number")
        return o.call(this, "w and h must be numbers", ie);
      H && typeof H == "function" && ie === void 0 ? (ie = H, H = null, Z = null) : typeof Z == "function" && ie === void 0 && (ie = Z, Z = null);
      const fe = 7 & (H = H || this.constructor.HORIZONTAL_ALIGN_CENTER | this.constructor.VERTICAL_ALIGN_MIDDLE), ge = H >> 3;
      if ((fe === 0 || fe & fe - 1) && (ge === 0 || ge & ge - 1))
        return o.call(this, "only use one flag per alignment direction", ie);
      const me = fe >> 1, ye = ge >> 1, Ae = S / A > this.bitmap.width / this.bitmap.height ? S / this.bitmap.width : A / this.bitmap.height;
      return this.scale(Ae, Z), this.crop((this.bitmap.width - S) / 2 * me, (this.bitmap.height - A) / 2 * ye, S, A), r(ie) && ie.call(this, null, this), this;
    } }), function(S) {
      return S("crop", function(A, H, Z, ie, fe) {
        if (typeof A != "number" || typeof H != "number")
          return o.call(this, "x and y must be numbers", fe);
        if (typeof Z != "number" || typeof ie != "number")
          return o.call(this, "w and h must be numbers", fe);
        if (A = Math.round(A), H = Math.round(H), Z = Math.round(Z), ie = Math.round(ie), A === 0 && Z === this.bitmap.width) {
          const ge = Z * H + A << 2, me = ge + (ie * Z << 2);
          this.bitmap.data = this.bitmap.data.slice(ge, me);
        } else {
          const ge = Ir.allocUnsafe(Z * ie * 4);
          let me = 0;
          this.scanQuiet(A, H, Z, ie, function(ye, Ae, Oe) {
            const ze = this.bitmap.data.readUInt32BE(Oe, !0);
            ge.writeUInt32BE(ze, me, !0), me += 4;
          }), this.bitmap.data = ge;
        }
        return this.bitmap.width = Z, this.bitmap.height = ie, r(fe) && fe.call(this, null, this), this;
      }), { class: { autocrop() {
        const A = this.bitmap.width, H = this.bitmap.height;
        let Z, ie = 0, fe = 2e-4, ge = !0, me = !1, ye = { north: !1, south: !1, east: !1, west: !1 };
        for (var Ae = arguments.length, Oe = new Array(Ae), ze = 0; ze < Ae; ze++)
          Oe[ze] = arguments[ze];
        for (let yt = 0, Mt = Oe.length; yt < Mt; yt++)
          if (typeof Oe[yt] == "number" && (fe = Oe[yt]), typeof Oe[yt] == "boolean" && (ge = Oe[yt]), typeof Oe[yt] == "function" && (Z = Oe[yt]), typeof Oe[yt] == "object") {
            const St = Oe[yt];
            St.tolerance !== void 0 && ({ tolerance: fe } = St), St.cropOnlyFrames !== void 0 && ({ cropOnlyFrames: ge } = St), St.cropSymmetric !== void 0 && ({ cropSymmetric: me } = St), St.leaveBorder !== void 0 && ({ leaveBorder: ie } = St), St.ignoreSides !== void 0 && ({ ignoreSides: ye } = St);
          }
        let it = this.getPixelColor(0, 0);
        const $e = this.constructor.intToRGBA(it);
        let Ge = 0, He = 0, nt = 0, ht = 0;
        if (it = this.getPixelColor(0, 0), !ye.north)
          e:
            for (let yt = 0; yt < H - 1; yt++) {
              for (let Mt = 0; Mt < A; Mt++) {
                const St = this.getPixelColor(Mt, yt), Ot = this.constructor.intToRGBA(St);
                if (this.constructor.colorDiff($e, Ot) > fe)
                  break e;
              }
              Ge++;
            }
        if (it = this.getPixelColor(A, 0), !ye.west)
          e:
            for (let yt = 0; yt < A - 1; yt++) {
              for (let Mt = 0 + Ge; Mt < H; Mt++) {
                const St = this.getPixelColor(yt, Mt), Ot = this.constructor.intToRGBA(St);
                if (this.constructor.colorDiff($e, Ot) > fe)
                  break e;
              }
              ht++;
            }
        if (it = this.getPixelColor(0, H), !ye.south)
          e:
            for (let yt = H - 1; yt >= Ge + 1; yt--) {
              for (let Mt = A - He - 1; Mt >= 0; Mt--) {
                const St = this.getPixelColor(Mt, yt), Ot = this.constructor.intToRGBA(St);
                if (this.constructor.colorDiff($e, Ot) > fe)
                  break e;
              }
              nt++;
            }
        if (it = this.getPixelColor(A, H), !ye.east)
          e:
            for (let yt = A - 1; yt >= 0 + ht + 1; yt--) {
              for (let Mt = H - 1; Mt >= 0 + Ge; Mt--) {
                const St = this.getPixelColor(yt, Mt), Ot = this.constructor.intToRGBA(St);
                if (this.constructor.colorDiff($e, Ot) > fe)
                  break e;
              }
              He++;
            }
        let pt = !1;
        if (ht -= ie, He -= ie, Ge -= ie, nt -= ie, me) {
          const yt = Math.min(He, ht), Mt = Math.min(Ge, nt);
          ht = yt, He = yt, Ge = Mt, nt = Mt;
        }
        ht = ht >= 0 ? ht : 0, He = He >= 0 ? He : 0, Ge = Ge >= 0 ? Ge : 0, nt = nt >= 0 ? nt : 0;
        const Et = A - (ht + He), Pt = H - (nt + Ge);
        return pt = ge ? He !== 0 && Ge !== 0 && ht !== 0 && nt !== 0 : He !== 0 || Ge !== 0 || ht !== 0 || nt !== 0, pt && this.crop(ht, Ge, Et, Pt), r(Z) && Z.call(this, null, this), this;
      } } };
    }, () => ({ displace(S, A, H) {
      if (typeof S != "object" || S.constructor !== this.constructor)
        return o.call(this, "The source must be a Jimp image", H);
      if (typeof A != "number")
        return o.call(this, "factor must be a number", H);
      const Z = this.cloneQuiet();
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(ie, fe, ge) {
        let me = S.bitmap.data[ge] / 256 * A;
        me = Math.round(me);
        const ye = this.getPixelIndex(ie + me, fe);
        this.bitmap.data[ye] = Z.bitmap.data[ge], this.bitmap.data[ye + 1] = Z.bitmap.data[ge + 1], this.bitmap.data[ye + 2] = Z.bitmap.data[ge + 2];
      }), r(H) && H.call(this, null, this), this;
    } }), () => ({ dither565: wr, dither16: wr }), () => ({ fisheye() {
      let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : { r: 2.5 }, A = arguments.length > 1 ? arguments[1] : void 0;
      typeof S == "function" && (A = S, S = { r: 2.5 });
      const H = this.cloneQuiet(), { width: Z, height: ie } = H.bitmap;
      return H.scanQuiet(0, 0, Z, ie, (fe, ge) => {
        const me = fe / Z, ye = ge / ie, Ae = Math.sqrt(Math.pow(me - 0.5, 2) + Math.pow(ye - 0.5, 2)), Oe = 2 * Math.pow(Ae, S.r), ze = (me - 0.5) / Ae, it = (ye - 0.5) / Ae, $e = Math.round((Oe * ze + 0.5) * Z), Ge = Math.round((Oe * it + 0.5) * ie), He = H.getPixelColor($e, Ge);
        this.setPixelColor(He, fe, ge);
      }), this.setPixelColor(H.getPixelColor(Z / 2, ie / 2), Z / 2, ie / 2), r(A) && A.call(this, null, this), this;
    } }), () => ({ flip: xr, mirror: xr }), () => ({ gaussian(S, A) {
      if (typeof S != "number")
        return o.call(this, "r must be a number", A);
      if (S < 1)
        return o.call(this, "r must be greater than 0", A);
      const H = Math.ceil(2.57 * S), Z = 2 * H + 1, ie = S * S * 2, fe = ie * Math.PI, ge = [];
      for (let me = 0; me < Z; me++) {
        ge[me] = [];
        for (let ye = 0; ye < Z; ye++) {
          const Ae = (ye - H) ** 2 + (me - H) ** 2;
          ge[me][ye] = Math.exp(-Ae / ie) / fe;
        }
      }
      for (let me = 0; me < this.bitmap.height; me++)
        for (let ye = 0; ye < this.bitmap.width; ye++) {
          let Ae = 0, Oe = 0, ze = 0, it = 0, $e = 0;
          for (let Ge = 0; Ge < Z; Ge++) {
            for (let nt = 0; nt < Z; nt++) {
              const ht = Math.min(this.bitmap.width - 1, Math.max(0, nt + ye - H)), pt = Math.min(this.bitmap.height - 1, Math.max(0, Ge + me - H)), Et = ge[Ge][nt], Pt = pt * this.bitmap.width + ht << 2;
              Ae += this.bitmap.data[Pt] * Et, Oe += this.bitmap.data[Pt + 1] * Et, ze += this.bitmap.data[Pt + 2] * Et, it += this.bitmap.data[Pt + 3] * Et, $e += Et;
            }
            const He = me * this.bitmap.width + ye << 2;
            this.bitmap.data[He] = Math.round(Ae / $e), this.bitmap.data[He + 1] = Math.round(Oe / $e), this.bitmap.data[He + 2] = Math.round(ze / $e), this.bitmap.data[He + 3] = Math.round(it / $e);
          }
        }
      return r(A) && A.call(this, null, this), this;
    } }), () => ({ invert(S) {
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(A, H, Z) {
        this.bitmap.data[Z] = 255 - this.bitmap.data[Z], this.bitmap.data[Z + 1] = 255 - this.bitmap.data[Z + 1], this.bitmap.data[Z + 2] = 255 - this.bitmap.data[Z + 2];
      }), r(S) && S.call(this, null, this), this;
    } }), () => ({ mask(S) {
      let A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0, H = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 0, Z = arguments.length > 3 ? arguments[3] : void 0;
      if (!(S instanceof this.constructor))
        return o.call(this, "The source must be a Jimp image", Z);
      if (typeof A != "number" || typeof H != "number")
        return o.call(this, "x and y must be numbers", Z);
      A = Math.round(A), H = Math.round(H);
      const ie = this.bitmap.width, fe = this.bitmap.height, ge = this;
      return S.scanQuiet(0, 0, S.bitmap.width, S.bitmap.height, function(me, ye, Ae) {
        const Oe = A + me, ze = H + ye;
        if (Oe >= 0 && ze >= 0 && Oe < ie && ze < fe) {
          const it = ge.getPixelIndex(Oe, ze), { data: $e } = this.bitmap, Ge = ($e[Ae + 0] + $e[Ae + 1] + $e[Ae + 2]) / 3;
          ge.bitmap.data[it + 3] *= Ge / 255;
        }
      }), r(Z) && Z.call(this, null, this), this;
    } }), () => ({ normalize(S) {
      const A = Ar.call(this), H = { r: br(A.r), g: br(A.g), b: br(A.b) };
      return this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, function(Z, ie, fe) {
        const ge = this.bitmap.data[fe + 0], me = this.bitmap.data[fe + 1], ye = this.bitmap.data[fe + 2];
        this.bitmap.data[fe + 0] = gr(ge, H.r[0], H.r[1]), this.bitmap.data[fe + 1] = gr(me, H.g[0], H.g[1]), this.bitmap.data[fe + 2] = gr(ye, H.b[0], H.b[1]);
      }), r(S) && S.call(this, null, this), this;
    } }), () => ({ constants: { measureText: pr, measureTextHeight: _r, FONT_SANS_8_BLACK: i().join(Kt, "fonts/open-sans/open-sans-8-black/open-sans-8-black.fnt"), FONT_SANS_10_BLACK: i().join(Kt, "fonts/open-sans/open-sans-10-black/open-sans-10-black.fnt"), FONT_SANS_12_BLACK: i().join(Kt, "fonts/open-sans/open-sans-12-black/open-sans-12-black.fnt"), FONT_SANS_14_BLACK: i().join(Kt, "fonts/open-sans/open-sans-14-black/open-sans-14-black.fnt"), FONT_SANS_16_BLACK: i().join(Kt, "fonts/open-sans/open-sans-16-black/open-sans-16-black.fnt"), FONT_SANS_32_BLACK: i().join(Kt, "fonts/open-sans/open-sans-32-black/open-sans-32-black.fnt"), FONT_SANS_64_BLACK: i().join(Kt, "fonts/open-sans/open-sans-64-black/open-sans-64-black.fnt"), FONT_SANS_128_BLACK: i().join(Kt, "fonts/open-sans/open-sans-128-black/open-sans-128-black.fnt"), FONT_SANS_8_WHITE: i().join(Kt, "fonts/open-sans/open-sans-8-white/open-sans-8-white.fnt"), FONT_SANS_16_WHITE: i().join(Kt, "fonts/open-sans/open-sans-16-white/open-sans-16-white.fnt"), FONT_SANS_32_WHITE: i().join(Kt, "fonts/open-sans/open-sans-32-white/open-sans-32-white.fnt"), FONT_SANS_64_WHITE: i().join(Kt, "fonts/open-sans/open-sans-64-white/open-sans-64-white.fnt"), FONT_SANS_128_WHITE: i().join(Kt, "fonts/open-sans/open-sans-128-white/open-sans-128-white.fnt"), loadFont(S, A) {
      return typeof S != "string" ? o.call(this, "file must be a string", A) : new Promise((H, Z) => {
        A = A || function(ie, fe) {
          ie ? Z(ie) : H(fe);
        }, Pr()(S, (ie, fe) => {
          const ge = {}, me = {};
          if (ie)
            return o.call(this, ie, A);
          for (let ye = 0; ye < fe.chars.length; ye++)
            ge[String.fromCharCode(fe.chars[ye].id)] = fe.chars[ye];
          for (let ye = 0; ye < fe.kernings.length; ye++) {
            const Ae = String.fromCharCode(fe.kernings[ye].first);
            me[Ae] = me[Ae] || {}, me[Ae][String.fromCharCode(fe.kernings[ye].second)] = fe.kernings[ye].amount;
          }
          (function(ye, Ae, Oe) {
            const ze = Oe.map((it) => ye.read(Ae + "/" + it));
            return Promise.all(ze);
          })(this, i().dirname(S), fe.pages).then((ye) => {
            A(null, { chars: ge, kernings: me, pages: ye, common: fe.common, info: fe.info });
          });
        });
      });
    } }, class: { print(S, A, H, Z, ie, fe, ge) {
      if (typeof ie == "function" && ge === void 0 && (ge = ie, ie = 1 / 0), ie === void 0 && (ie = 1 / 0), typeof fe == "function" && ge === void 0 && (ge = fe, fe = 1 / 0), fe === void 0 && (fe = 1 / 0), typeof S != "object")
        return o.call(this, "font must be a Jimp loadFont", ge);
      if (typeof A != "number" || typeof H != "number" || typeof ie != "number")
        return o.call(this, "x, y and maxWidth must be numbers", ge);
      if (typeof ie != "number")
        return o.call(this, "maxWidth must be a number", ge);
      if (typeof fe != "number")
        return o.call(this, "maxHeight must be a number", ge);
      let me, ye;
      typeof Z == "object" && Z.text !== null && Z.text !== void 0 ? (me = Z.alignmentX || this.constructor.HORIZONTAL_ALIGN_LEFT, ye = Z.alignmentY || this.constructor.VERTICAL_ALIGN_TOP, { text: Z } = Z) : (me = this.constructor.HORIZONTAL_ALIGN_LEFT, ye = this.constructor.VERTICAL_ALIGN_TOP, Z = Z.toString()), fe !== 1 / 0 && ye === this.constructor.VERTICAL_ALIGN_BOTTOM ? H += fe - _r(S, Z, ie) : fe !== 1 / 0 && ye === this.constructor.VERTICAL_ALIGN_MIDDLE && (H += fe / 2 - _r(S, Z, ie) / 2);
      const Ae = Object.entries(S.chars)[0][1].xadvance, { lines: Oe, longestLine: ze } = Er(S, Z, ie);
      return Oe.forEach((it) => {
        const $e = it.join(" "), Ge = function(He, nt, ht, pt, Et) {
          return Et === He.HORIZONTAL_ALIGN_LEFT ? 0 : Et === He.HORIZONTAL_ALIGN_CENTER ? (pt - pr(nt, ht)) / 2 : pt - pr(nt, ht);
        }(this.constructor, S, $e, ie, me);
        Lr.call(this, S, A + Ge, H, $e, Ae), H += S.common.lineHeight;
      }), r(ge) && ge.call(this, null, this, { x: A + ze, y: H }), this;
    } } }), () => ({ constants: { RESIZE_NEAREST_NEIGHBOR: "nearestNeighbor", RESIZE_BILINEAR: "bilinearInterpolation", RESIZE_BICUBIC: "bicubicInterpolation", RESIZE_HERMITE: "hermiteInterpolation", RESIZE_BEZIER: "bezierInterpolation" }, class: { resize(S, A, H, Z) {
      if (typeof S != "number" || typeof A != "number")
        return o.call(this, "w and h must be numbers", Z);
      if (typeof H == "function" && Z === void 0 && (Z = H, H = null), S === this.constructor.AUTO && A === this.constructor.AUTO)
        return o.call(this, "w and h cannot both be set to auto", Z);
      if (S === this.constructor.AUTO && (S = this.bitmap.width * (A / this.bitmap.height)), A === this.constructor.AUTO && (A = this.bitmap.height * (S / this.bitmap.width)), S < 0 || A < 0)
        return o.call(this, "w and h must be positive numbers", Z);
      if (S = Math.round(S) || 1, A = Math.round(A) || 1, typeof kr[H] == "function") {
        const ie = { data: Mr.alloc(S * A * 4), width: S, height: A };
        kr[H](this.bitmap, ie), this.bitmap = ie;
      } else {
        const ie = this;
        new Br(this.bitmap.width, this.bitmap.height, S, A, !0, !0, (fe) => {
          ie.bitmap.data = Mr.from(fe), ie.bitmap.width = S, ie.bitmap.height = A;
        }).resize(this.bitmap.data);
      }
      return r(Z) && Z.call(this, null, this), this;
    } } }), () => ({ rotate(S, A, H) {
      return A == null && (A = !0), typeof A == "function" && H === void 0 && (H = A, A = !0), typeof S != "number" ? o.call(this, "deg must be a number", H) : typeof A != "boolean" && typeof A != "string" ? o.call(this, "mode must be a boolean or a string", H) : (S % 90 != 0 || !A && this.bitmap.width !== this.bitmap.height && S % 180 != 0 ? Dr.call(this, S, A, H) : zr.call(this, S), r(H) && H.call(this, null, this), this);
    } }), () => ({ scale(S, A, H) {
      if (typeof S != "number")
        return o.call(this, "f must be a number", H);
      if (S < 0)
        return o.call(this, "f must be a positive number", H);
      typeof A == "function" && H === void 0 && (H = A, A = null);
      const Z = this.bitmap.width * S, ie = this.bitmap.height * S;
      return this.resize(Z, ie, A), r(H) && H.call(this, null, this), this;
    }, scaleToFit(S, A, H, Z) {
      if (typeof S != "number" || typeof A != "number")
        return o.call(this, "w and h must be numbers", Z);
      typeof H == "function" && Z === void 0 && (Z = H, H = null);
      const ie = S / A > this.bitmap.width / this.bitmap.height ? A / this.bitmap.height : S / this.bitmap.width;
      return this.scale(ie, H), r(Z) && Z.call(this, null, this), this;
    } }), () => ({ shadow() {
      let S = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {}, A = arguments.length > 1 ? arguments[1] : void 0;
      typeof S == "function" && (A = S, S = {});
      const { opacity: H = 0.7, size: Z = 1.1, x: ie = -25, y: fe = 25, blur: ge = 5 } = S, me = this.clone(), ye = this.clone();
      return ye.scan(0, 0, ye.bitmap.width, ye.bitmap.height, (Ae, Oe, ze) => {
        ye.bitmap.data[ze] = 0, ye.bitmap.data[ze + 1] = 0, ye.bitmap.data[ze + 2] = 0, ye.bitmap.data[ze + 3] = ye.constructor.limit255(ye.bitmap.data[ze + 3] * H), this.bitmap.data[ze] = 0, this.bitmap.data[ze + 1] = 0, this.bitmap.data[ze + 2] = 0, this.bitmap.data[ze + 3] = 0;
      }), ye.resize(ye.bitmap.width * Z, ye.bitmap.height * Z).blur(ge), this.composite(ye, ie, fe), this.composite(me, 0, 0), r(A) && A.call(this, null, this), this;
    } }), () => ({ threshold(S, A) {
      let { max: H, replace: Z = 255, autoGreyscale: ie = !0 } = S;
      return typeof H != "number" ? o.call(this, "max must be a number", A) : typeof Z != "number" ? o.call(this, "replace must be a number", A) : typeof ie != "boolean" ? o.call(this, "autoGreyscale must be a boolean", A) : (H = this.constructor.limit255(H), Z = this.constructor.limit255(Z), ie && this.greyscale(), this.scanQuiet(0, 0, this.bitmap.width, this.bitmap.height, (fe, ge, me) => {
        const ye = this.bitmap.data[me] < H ? this.bitmap.data[me] : Z;
        this.bitmap.data[me] = ye, this.bitmap.data[me + 1] = ye, this.bitmap.data[me + 2] = ye;
      }), r(A) && A.call(this, null, this), this);
    } })];
    (function(S) {
      let A = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : pe;
      const H = { hasAlpha: {}, encoders: {}, decoders: {}, class: {}, constants: {} };
      function Z(ie) {
        Object.entries(ie).forEach((fe) => {
          let [ge, me] = fe;
          H[ge] = { ...H[ge], ...me };
        });
      }
      S.types && (S.types.forEach(function(ie) {
        const fe = ie();
        Array.isArray(fe.mime) ? Ft(...fe.mime) : Object.entries(fe.mime).forEach((ge) => Ft(...ge)), delete fe.mime, Z(fe);
      }), A.decoders = { ...A.decoders, ...H.decoders }, A.encoders = { ...A.encoders, ...H.encoders }, A.hasAlpha = { ...A.hasAlpha, ...H.hasAlpha }), S.plugins && S.plugins.forEach(function(ie) {
        const fe = ie(ue) || {};
        fe.class || fe.constants ? Z(fe) : Z({ class: fe });
      }), dr(H.class, A), nr(H.constants, A);
    })({ types: [() => (0, ve.Ee)(qe(), Ve(), { mime: { [xt]: ["bmp"] }, constants: { MIME_BMP: xt, MIME_X_MS_BMP: _t }, decoders: { [xt]: ct, [_t]: ct }, encoders: { [xt]: dt, [_t]: dt } }, { mime: { [Wt]: ["tiff", "tif"] }, constants: { MIME_TIFF: Wt }, decoders: { [Wt]: (S) => {
      const A = Bt().decode(S), H = A[0];
      A.forEach((ie) => {
        Bt().decodeImage(S, ie);
      });
      const Z = Bt().toRGBA8(H);
      return { data: Ht.from(Z), width: H.t256[0], height: H.t257[0] };
    } }, encoders: { [Wt]: (S) => {
      const A = Bt().encodeImage(S.bitmap.data, S.bitmap.width, S.bitmap.height);
      return Ht.from(A);
    } } }, { mime: { [Qt]: ["gif"] }, constants: { MIME_GIF: Qt }, decoders: { [Qt]: (S) => {
      const A = new Zt.N(S), H = gt.alloc(A.width * A.height * 4);
      return A.decodeAndBlitFrameRGBA(0, H), { data: H, width: A.width, height: A.height };
    } }, encoders: { [Qt]: (S) => {
      const A = new $t.BitmapImage(S.bitmap);
      $t.GifUtil.quantizeDekker(A, 256);
      const H = new $t.GifFrame(A);
      return new $t.GifCodec().encodeGif([H], {}).then((Z) => Z.buffer);
    } } })], plugins: [(S) => {
      const A = Nr.map((H) => {
        let Z = H(S) || {};
        return Z.class || Z.constants || (Z = { class: Z }), Z;
      });
      return (0, ve.Ee)(...A);
    }] });
  })();
})();
const MakerConvertBase64 = (d) => d.getBase64Async(Jimp.MIME_PNG), ViewScaleContext = createContext(
  /*window.innerWidth < 480 ? 1 : 2*/
  720
), Canvas = "_Canvas_63y9h_2", MakerView_module = {
  Canvas
}, CanvasImageContext = createContext(null), MakerView = ({}) => {
  const { canvasImage: d } = useContext(CanvasImageContext), l = useContext(ViewScaleContext), s = useRef(null);
  return useEffect(() => {
    (async () => {
      const f = s.current, i = f.getContext("2d");
      d && Promise.all(
        d.map((a) => new Promise(async (t) => {
          const r = new Image();
          r.style.imageRendering = "pixelated", r.src = await MakerConvertBase64(a), r.onload = () => {
            t({ img: r, image: a });
          };
        }))
      ).then((a) => {
        i.clearRect(0, 0, f.width, f.height);
        const t = a[0].img;
        f.width = t.width * l, f.height = t.height * l, a.forEach(({ img: r }) => {
          i.globalCompositeOperation = "source-over", i.imageSmoothingEnabled = !1, i.webkitImageSmoothingEnabled = !1, i.mozImageSmoothingEnabled = !1, i.drawImage(
            r,
            0,
            0,
            r.width * l,
            r.height * l
          );
        });
      });
    })();
  }, [d, l]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx("canvas", { ref: s, className: Canvas }),
    " "
  ] });
}, partsButtonStyle = "_partsButtonStyle_1pkvk_1", partsImg$1 = "_partsImg_1pkvk_6", MakerPartsButton_module = {
  partsButtonStyle,
  partsImg: partsImg$1
}, MakerPartsButton = ({
  onClick: d,
  item: l,
  buttonImage: s
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: partsButtonStyle, onClick: d, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { className: partsImg$1, src: s, alt: l }) }), MakerPartsButton$1 = React__default.memo(MakerPartsButton), menuCategoryStyle = "_menuCategoryStyle_1kdtm_1", styles$3 = {
  menuCategoryStyle
}, MakerPartsCategories = ({
  imageSrc: d,
  category: l,
  isSelected: s,
  onClick: e
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { className: styles$3.menuCategoryStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { onClick: e, src: d, alt: l }) }), MakerPartsCategories$1 = React.memo(MakerPartsCategories), MakerSearchIgnoreTrigger = (d, l) => {
  const s = [];
  for (const e in d) {
    const f = d[e].ignoreTrigger;
    f && f.includes(l) && s.push(e);
  }
  return s.length === 0 ? null : s;
}, MakerChangingPart = (d, l, s, e, f, i) => {
  let a = {
    bodyType: d === "body" ? s : e.bodyType,
    face: e.face,
    category: {
      ...e.category,
      [d]: {
        ...e.category[d],
        partName: s,
        partFlip: e.category[d].partFlip
      }
    },
    selectedColor: e.selectedColor,
    selectedFace: e.selectedFace
  };
  const t = MakerSearchIgnoreTrigger(
    i,
    d
  );
  if (t && t.forEach((r) => {
    a.category[r] = {
      ...e.category[r],
      partName: "",
      partFlip: e.category[r].partFlip
    };
  }), d === "body") {
    if (l) {
      if (l.length != 1)
        throw new Error(":bodybodyType");
    } else
      throw new Error(":bodybodyType");
    for (const r in a.category) {
      r !== "body" && a.category[r].partName !== "" && (a.category[r].partName = !i[r].partList[Object.keys(i[r].partList)[0]].items[e.category[r].partName].bodyType || i[r].partList[Object.keys(i[r].partList)[0]].items[e.category[r].partName].bodyType.includes(s) ? e.category[r].partName : "");
      for (const o in i[r].partList)
        a.selectedColor[i[r].partList[o].colorGroup] || (a.selectedColor[i[r].partList[o].colorGroup] = {
          default: {
            color: e.selectedColor.none.default.color,
            hueReverse: e.selectedColor.none.default.hueReverse,
            saturationReverse: e.selectedColor.none.default.saturationReverse,
            hueGraph: e.selectedColor.none.default.hueGraph,
            saturationGraph: e.selectedColor.none.default.saturationGraph,
            valueGraph: e.selectedColor.none.default.valueGraph
          }
        });
      Object.keys(
        i[d].partList[Object.keys(i[d].partList)[0]].items[s].faces
      ).includes(a.selectedFace[d]) ? a.selectedFace[d] = a.selectedFace[d] : a.selectedFace[d] = "clear";
    }
  }
  f(a);
}, SelectedCategoryContext = createContext(null), SelectedPartsContext = createContext(null), MenuPartIconsContext = createContext(null), PartsObjectContext = createContext({});
function isObject$2(d) {
  return d !== null && typeof d == "object" && "constructor" in d && d.constructor === Object;
}
function extend$2(d, l) {
  d === void 0 && (d = {}), l === void 0 && (l = {}), Object.keys(l).forEach((s) => {
    typeof d[s] > "u" ? d[s] = l[s] : isObject$2(l[s]) && isObject$2(d[s]) && Object.keys(l[s]).length > 0 && extend$2(d[s], l[s]);
  });
}
const ssrDocument = {
  body: {},
  addEventListener() {
  },
  removeEventListener() {
  },
  activeElement: {
    blur() {
    },
    nodeName: ""
  },
  querySelector() {
    return null;
  },
  querySelectorAll() {
    return [];
  },
  getElementById() {
    return null;
  },
  createEvent() {
    return {
      initEvent() {
      }
    };
  },
  createElement() {
    return {
      children: [],
      childNodes: [],
      style: {},
      setAttribute() {
      },
      getElementsByTagName() {
        return [];
      }
    };
  },
  createElementNS() {
    return {};
  },
  importNode() {
    return null;
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  }
};
function getDocument() {
  const d = typeof document < "u" ? document : {};
  return extend$2(d, ssrDocument), d;
}
const ssrWindow = {
  document: ssrDocument,
  navigator: {
    userAgent: ""
  },
  location: {
    hash: "",
    host: "",
    hostname: "",
    href: "",
    origin: "",
    pathname: "",
    protocol: "",
    search: ""
  },
  history: {
    replaceState() {
    },
    pushState() {
    },
    go() {
    },
    back() {
    }
  },
  CustomEvent: function d() {
    return this;
  },
  addEventListener() {
  },
  removeEventListener() {
  },
  getComputedStyle() {
    return {
      getPropertyValue() {
        return "";
      }
    };
  },
  Image() {
  },
  Date() {
  },
  screen: {},
  setTimeout() {
  },
  clearTimeout() {
  },
  matchMedia() {
    return {};
  },
  requestAnimationFrame(d) {
    return typeof setTimeout > "u" ? (d(), null) : setTimeout(d, 0);
  },
  cancelAnimationFrame(d) {
    typeof setTimeout > "u" || clearTimeout(d);
  }
};
function getWindow() {
  const d = typeof window < "u" ? window : {};
  return extend$2(d, ssrWindow), d;
}
function classesToTokens(d) {
  return d === void 0 && (d = ""), d.trim().split(" ").filter((l) => !!l.trim());
}
function deleteProps(d) {
  const l = d;
  Object.keys(l).forEach((s) => {
    try {
      l[s] = null;
    } catch {
    }
    try {
      delete l[s];
    } catch {
    }
  });
}
function nextTick(d, l) {
  return l === void 0 && (l = 0), setTimeout(d, l);
}
function now() {
  return Date.now();
}
function getComputedStyle$1(d) {
  const l = getWindow();
  let s;
  return l.getComputedStyle && (s = l.getComputedStyle(d, null)), !s && d.currentStyle && (s = d.currentStyle), s || (s = d.style), s;
}
function getTranslate(d, l) {
  l === void 0 && (l = "x");
  const s = getWindow();
  let e, f, i;
  const a = getComputedStyle$1(d);
  return s.WebKitCSSMatrix ? (f = a.transform || a.webkitTransform, f.split(",").length > 6 && (f = f.split(", ").map((t) => t.replace(",", ".")).join(", ")), i = new s.WebKitCSSMatrix(f === "none" ? "" : f)) : (i = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), e = i.toString().split(",")), l === "x" && (s.WebKitCSSMatrix ? f = i.m41 : e.length === 16 ? f = parseFloat(e[12]) : f = parseFloat(e[4])), l === "y" && (s.WebKitCSSMatrix ? f = i.m42 : e.length === 16 ? f = parseFloat(e[13]) : f = parseFloat(e[5])), f || 0;
}
function isObject$1(d) {
  return typeof d == "object" && d !== null && d.constructor && Object.prototype.toString.call(d).slice(8, -1) === "Object";
}
function isNode(d) {
  return typeof window < "u" && typeof window.HTMLElement < "u" ? d instanceof HTMLElement : d && (d.nodeType === 1 || d.nodeType === 11);
}
function extend$1() {
  const d = Object(arguments.length <= 0 ? void 0 : arguments[0]), l = ["__proto__", "constructor", "prototype"];
  for (let s = 1; s < arguments.length; s += 1) {
    const e = s < 0 || arguments.length <= s ? void 0 : arguments[s];
    if (e != null && !isNode(e)) {
      const f = Object.keys(Object(e)).filter((i) => l.indexOf(i) < 0);
      for (let i = 0, a = f.length; i < a; i += 1) {
        const t = f[i], r = Object.getOwnPropertyDescriptor(e, t);
        r !== void 0 && r.enumerable && (isObject$1(d[t]) && isObject$1(e[t]) ? e[t].__swiper__ ? d[t] = e[t] : extend$1(d[t], e[t]) : !isObject$1(d[t]) && isObject$1(e[t]) ? (d[t] = {}, e[t].__swiper__ ? d[t] = e[t] : extend$1(d[t], e[t])) : d[t] = e[t]);
      }
    }
  }
  return d;
}
function setCSSProperty(d, l, s) {
  d.style.setProperty(l, s);
}
function animateCSSModeScroll(d) {
  let {
    swiper: l,
    targetPosition: s,
    side: e
  } = d;
  const f = getWindow(), i = -l.translate;
  let a = null, t;
  const r = l.params.speed;
  l.wrapperEl.style.scrollSnapType = "none", f.cancelAnimationFrame(l.cssModeFrameID);
  const o = s > i ? "next" : "prev", n = (p, g) => o === "next" && p >= g || o === "prev" && p <= g, u = () => {
    t = (/* @__PURE__ */ new Date()).getTime(), a === null && (a = t);
    const p = Math.max(Math.min((t - a) / r, 1), 0), g = 0.5 - Math.cos(p * Math.PI) / 2;
    let v = i + g * (s - i);
    if (n(v, s) && (v = s), l.wrapperEl.scrollTo({
      [e]: v
    }), n(v, s)) {
      l.wrapperEl.style.overflow = "hidden", l.wrapperEl.style.scrollSnapType = "", setTimeout(() => {
        l.wrapperEl.style.overflow = "", l.wrapperEl.scrollTo({
          [e]: v
        });
      }), f.cancelAnimationFrame(l.cssModeFrameID);
      return;
    }
    l.cssModeFrameID = f.requestAnimationFrame(u);
  };
  u();
}
function elementChildren(d, l) {
  return l === void 0 && (l = ""), [...d.children].filter((s) => s.matches(l));
}
function showWarning(d) {
  try {
    console.warn(d);
    return;
  } catch {
  }
}
function createElement(d, l) {
  l === void 0 && (l = []);
  const s = document.createElement(d);
  return s.classList.add(...Array.isArray(l) ? l : classesToTokens(l)), s;
}
function elementPrevAll(d, l) {
  const s = [];
  for (; d.previousElementSibling; ) {
    const e = d.previousElementSibling;
    l ? e.matches(l) && s.push(e) : s.push(e), d = e;
  }
  return s;
}
function elementNextAll(d, l) {
  const s = [];
  for (; d.nextElementSibling; ) {
    const e = d.nextElementSibling;
    l ? e.matches(l) && s.push(e) : s.push(e), d = e;
  }
  return s;
}
function elementStyle(d, l) {
  return getWindow().getComputedStyle(d, null).getPropertyValue(l);
}
function elementIndex(d) {
  let l = d, s;
  if (l) {
    for (s = 0; (l = l.previousSibling) !== null; )
      l.nodeType === 1 && (s += 1);
    return s;
  }
}
function elementParents(d, l) {
  const s = [];
  let e = d.parentElement;
  for (; e; )
    l ? e.matches(l) && s.push(e) : s.push(e), e = e.parentElement;
  return s;
}
function elementOuterSize(d, l, s) {
  const e = getWindow();
  return s ? d[l === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(e.getComputedStyle(d, null).getPropertyValue(l === "width" ? "margin-right" : "margin-top")) + parseFloat(e.getComputedStyle(d, null).getPropertyValue(l === "width" ? "margin-left" : "margin-bottom")) : d.offsetWidth;
}
let support;
function calcSupport() {
  const d = getWindow(), l = getDocument();
  return {
    smoothScroll: l.documentElement && l.documentElement.style && "scrollBehavior" in l.documentElement.style,
    touch: !!("ontouchstart" in d || d.DocumentTouch && l instanceof d.DocumentTouch)
  };
}
function getSupport() {
  return support || (support = calcSupport()), support;
}
let deviceCached;
function calcDevice(d) {
  let {
    userAgent: l
  } = d === void 0 ? {} : d;
  const s = getSupport(), e = getWindow(), f = e.navigator.platform, i = l || e.navigator.userAgent, a = {
    ios: !1,
    android: !1
  }, t = e.screen.width, r = e.screen.height, o = i.match(/(Android);?[\s\/]+([\d.]+)?/);
  let n = i.match(/(iPad).*OS\s([\d_]+)/);
  const u = i.match(/(iPod)(.*OS\s([\d_]+))?/), p = !n && i.match(/(iPhone\sOS|iOS)\s([\d_]+)/), g = f === "Win32";
  let v = f === "MacIntel";
  const x = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"];
  return !n && v && s.touch && x.indexOf(`${t}x${r}`) >= 0 && (n = i.match(/(Version)\/([\d.]+)/), n || (n = [0, 1, "13_0_0"]), v = !1), o && !g && (a.os = "android", a.android = !0), (n || p || u) && (a.os = "ios", a.ios = !0), a;
}
function getDevice(d) {
  return d === void 0 && (d = {}), deviceCached || (deviceCached = calcDevice(d)), deviceCached;
}
let browser;
function calcBrowser() {
  const d = getWindow();
  let l = !1;
  function s() {
    const e = d.navigator.userAgent.toLowerCase();
    return e.indexOf("safari") >= 0 && e.indexOf("chrome") < 0 && e.indexOf("android") < 0;
  }
  if (s()) {
    const e = String(d.navigator.userAgent);
    if (e.includes("Version/")) {
      const [f, i] = e.split("Version/")[1].split(" ")[0].split(".").map((a) => Number(a));
      l = f < 16 || f === 16 && i < 2;
    }
  }
  return {
    isSafari: l || s(),
    needPerspectiveFix: l,
    isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(d.navigator.userAgent)
  };
}
function getBrowser() {
  return browser || (browser = calcBrowser()), browser;
}
function Resize(d) {
  let {
    swiper: l,
    on: s,
    emit: e
  } = d;
  const f = getWindow();
  let i = null, a = null;
  const t = () => {
    !l || l.destroyed || !l.initialized || (e("beforeResize"), e("resize"));
  }, r = () => {
    !l || l.destroyed || !l.initialized || (i = new ResizeObserver((u) => {
      a = f.requestAnimationFrame(() => {
        const {
          width: p,
          height: g
        } = l;
        let v = p, x = g;
        u.forEach((b) => {
          let {
            contentBoxSize: w,
            contentRect: M,
            target: G
          } = b;
          G && G !== l.el || (v = M ? M.width : (w[0] || w).inlineSize, x = M ? M.height : (w[0] || w).blockSize);
        }), (v !== p || x !== g) && t();
      });
    }), i.observe(l.el));
  }, o = () => {
    a && f.cancelAnimationFrame(a), i && i.unobserve && l.el && (i.unobserve(l.el), i = null);
  }, n = () => {
    !l || l.destroyed || !l.initialized || e("orientationchange");
  };
  s("init", () => {
    if (l.params.resizeObserver && typeof f.ResizeObserver < "u") {
      r();
      return;
    }
    f.addEventListener("resize", t), f.addEventListener("orientationchange", n);
  }), s("destroy", () => {
    o(), f.removeEventListener("resize", t), f.removeEventListener("orientationchange", n);
  });
}
function Observer(d) {
  let {
    swiper: l,
    extendParams: s,
    on: e,
    emit: f
  } = d;
  const i = [], a = getWindow(), t = function(n, u) {
    u === void 0 && (u = {});
    const p = a.MutationObserver || a.WebkitMutationObserver, g = new p((v) => {
      if (l.__preventObserver__)
        return;
      if (v.length === 1) {
        f("observerUpdate", v[0]);
        return;
      }
      const x = function() {
        f("observerUpdate", v[0]);
      };
      a.requestAnimationFrame ? a.requestAnimationFrame(x) : a.setTimeout(x, 0);
    });
    g.observe(n, {
      attributes: typeof u.attributes > "u" ? !0 : u.attributes,
      childList: typeof u.childList > "u" ? !0 : u.childList,
      characterData: typeof u.characterData > "u" ? !0 : u.characterData
    }), i.push(g);
  }, r = () => {
    if (l.params.observer) {
      if (l.params.observeParents) {
        const n = elementParents(l.hostEl);
        for (let u = 0; u < n.length; u += 1)
          t(n[u]);
      }
      t(l.hostEl, {
        childList: l.params.observeSlideChildren
      }), t(l.wrapperEl, {
        attributes: !1
      });
    }
  }, o = () => {
    i.forEach((n) => {
      n.disconnect();
    }), i.splice(0, i.length);
  };
  s({
    observer: !1,
    observeParents: !1,
    observeSlideChildren: !1
  }), e("init", r), e("destroy", o);
}
var eventsEmitter = {
  on(d, l, s) {
    const e = this;
    if (!e.eventsListeners || e.destroyed || typeof l != "function")
      return e;
    const f = s ? "unshift" : "push";
    return d.split(" ").forEach((i) => {
      e.eventsListeners[i] || (e.eventsListeners[i] = []), e.eventsListeners[i][f](l);
    }), e;
  },
  once(d, l, s) {
    const e = this;
    if (!e.eventsListeners || e.destroyed || typeof l != "function")
      return e;
    function f() {
      e.off(d, f), f.__emitterProxy && delete f.__emitterProxy;
      for (var i = arguments.length, a = new Array(i), t = 0; t < i; t++)
        a[t] = arguments[t];
      l.apply(e, a);
    }
    return f.__emitterProxy = l, e.on(d, f, s);
  },
  onAny(d, l) {
    const s = this;
    if (!s.eventsListeners || s.destroyed || typeof d != "function")
      return s;
    const e = l ? "unshift" : "push";
    return s.eventsAnyListeners.indexOf(d) < 0 && s.eventsAnyListeners[e](d), s;
  },
  offAny(d) {
    const l = this;
    if (!l.eventsListeners || l.destroyed || !l.eventsAnyListeners)
      return l;
    const s = l.eventsAnyListeners.indexOf(d);
    return s >= 0 && l.eventsAnyListeners.splice(s, 1), l;
  },
  off(d, l) {
    const s = this;
    return !s.eventsListeners || s.destroyed || !s.eventsListeners || d.split(" ").forEach((e) => {
      typeof l > "u" ? s.eventsListeners[e] = [] : s.eventsListeners[e] && s.eventsListeners[e].forEach((f, i) => {
        (f === l || f.__emitterProxy && f.__emitterProxy === l) && s.eventsListeners[e].splice(i, 1);
      });
    }), s;
  },
  emit() {
    const d = this;
    if (!d.eventsListeners || d.destroyed || !d.eventsListeners)
      return d;
    let l, s, e;
    for (var f = arguments.length, i = new Array(f), a = 0; a < f; a++)
      i[a] = arguments[a];
    return typeof i[0] == "string" || Array.isArray(i[0]) ? (l = i[0], s = i.slice(1, i.length), e = d) : (l = i[0].events, s = i[0].data, e = i[0].context || d), s.unshift(e), (Array.isArray(l) ? l : l.split(" ")).forEach((r) => {
      d.eventsAnyListeners && d.eventsAnyListeners.length && d.eventsAnyListeners.forEach((o) => {
        o.apply(e, [r, ...s]);
      }), d.eventsListeners && d.eventsListeners[r] && d.eventsListeners[r].forEach((o) => {
        o.apply(e, s);
      });
    }), d;
  }
};
function updateSize() {
  const d = this;
  let l, s;
  const e = d.el;
  typeof d.params.width < "u" && d.params.width !== null ? l = d.params.width : l = e.clientWidth, typeof d.params.height < "u" && d.params.height !== null ? s = d.params.height : s = e.clientHeight, !(l === 0 && d.isHorizontal() || s === 0 && d.isVertical()) && (l = l - parseInt(elementStyle(e, "padding-left") || 0, 10) - parseInt(elementStyle(e, "padding-right") || 0, 10), s = s - parseInt(elementStyle(e, "padding-top") || 0, 10) - parseInt(elementStyle(e, "padding-bottom") || 0, 10), Number.isNaN(l) && (l = 0), Number.isNaN(s) && (s = 0), Object.assign(d, {
    width: l,
    height: s,
    size: d.isHorizontal() ? l : s
  }));
}
function updateSlides() {
  const d = this;
  function l(W, O) {
    return parseFloat(W.getPropertyValue(d.getDirectionLabel(O)) || 0);
  }
  const s = d.params, {
    wrapperEl: e,
    slidesEl: f,
    size: i,
    rtlTranslate: a,
    wrongRTL: t
  } = d, r = d.virtual && s.virtual.enabled, o = r ? d.virtual.slides.length : d.slides.length, n = elementChildren(f, `.${d.params.slideClass}, swiper-slide`), u = r ? d.virtual.slides.length : n.length;
  let p = [];
  const g = [], v = [];
  let x = s.slidesOffsetBefore;
  typeof x == "function" && (x = s.slidesOffsetBefore.call(d));
  let b = s.slidesOffsetAfter;
  typeof b == "function" && (b = s.slidesOffsetAfter.call(d));
  const w = d.snapGrid.length, M = d.slidesGrid.length;
  let G = s.spaceBetween, F = -x, V = 0, q = 0;
  if (typeof i > "u")
    return;
  typeof G == "string" && G.indexOf("%") >= 0 ? G = parseFloat(G.replace("%", "")) / 100 * i : typeof G == "string" && (G = parseFloat(G)), d.virtualSize = -G, n.forEach((W) => {
    a ? W.style.marginLeft = "" : W.style.marginRight = "", W.style.marginBottom = "", W.style.marginTop = "";
  }), s.centeredSlides && s.cssMode && (setCSSProperty(e, "--swiper-centered-offset-before", ""), setCSSProperty(e, "--swiper-centered-offset-after", ""));
  const I = s.grid && s.grid.rows > 1 && d.grid;
  I ? d.grid.initSlides(n) : d.grid && d.grid.unsetSlides();
  let _;
  const R = s.slidesPerView === "auto" && s.breakpoints && Object.keys(s.breakpoints).filter((W) => typeof s.breakpoints[W].slidesPerView < "u").length > 0;
  for (let W = 0; W < u; W += 1) {
    _ = 0;
    let O;
    if (n[W] && (O = n[W]), I && d.grid.updateSlide(W, O, n), !(n[W] && elementStyle(O, "display") === "none")) {
      if (s.slidesPerView === "auto") {
        R && (n[W].style[d.getDirectionLabel("width")] = "");
        const j = getComputedStyle(O), U = O.style.transform, C = O.style.webkitTransform;
        if (U && (O.style.transform = "none"), C && (O.style.webkitTransform = "none"), s.roundLengths)
          _ = d.isHorizontal() ? elementOuterSize(O, "width", !0) : elementOuterSize(O, "height", !0);
        else {
          const ae = l(j, "width"), J = l(j, "padding-left"), te = l(j, "padding-right"), $ = l(j, "margin-left"), L = l(j, "margin-right"), re = j.getPropertyValue("box-sizing");
          if (re && re === "border-box")
            _ = ae + $ + L;
          else {
            const {
              clientWidth: z,
              offsetWidth: N
            } = O;
            _ = ae + J + te + $ + L + (N - z);
          }
        }
        U && (O.style.transform = U), C && (O.style.webkitTransform = C), s.roundLengths && (_ = Math.floor(_));
      } else
        _ = (i - (s.slidesPerView - 1) * G) / s.slidesPerView, s.roundLengths && (_ = Math.floor(_)), n[W] && (n[W].style[d.getDirectionLabel("width")] = `${_}px`);
      n[W] && (n[W].swiperSlideSize = _), v.push(_), s.centeredSlides ? (F = F + _ / 2 + V / 2 + G, V === 0 && W !== 0 && (F = F - i / 2 - G), W === 0 && (F = F - i / 2 - G), Math.abs(F) < 1 / 1e3 && (F = 0), s.roundLengths && (F = Math.floor(F)), q % s.slidesPerGroup === 0 && p.push(F), g.push(F)) : (s.roundLengths && (F = Math.floor(F)), (q - Math.min(d.params.slidesPerGroupSkip, q)) % d.params.slidesPerGroup === 0 && p.push(F), g.push(F), F = F + _ + G), d.virtualSize += _ + G, V = _, q += 1;
    }
  }
  if (d.virtualSize = Math.max(d.virtualSize, i) + b, a && t && (s.effect === "slide" || s.effect === "coverflow") && (e.style.width = `${d.virtualSize + G}px`), s.setWrapperSize && (e.style[d.getDirectionLabel("width")] = `${d.virtualSize + G}px`), I && d.grid.updateWrapperSize(_, p), !s.centeredSlides) {
    const W = [];
    for (let O = 0; O < p.length; O += 1) {
      let j = p[O];
      s.roundLengths && (j = Math.floor(j)), p[O] <= d.virtualSize - i && W.push(j);
    }
    p = W, Math.floor(d.virtualSize - i) - Math.floor(p[p.length - 1]) > 1 && p.push(d.virtualSize - i);
  }
  if (r && s.loop) {
    const W = v[0] + G;
    if (s.slidesPerGroup > 1) {
      const O = Math.ceil((d.virtual.slidesBefore + d.virtual.slidesAfter) / s.slidesPerGroup), j = W * s.slidesPerGroup;
      for (let U = 0; U < O; U += 1)
        p.push(p[p.length - 1] + j);
    }
    for (let O = 0; O < d.virtual.slidesBefore + d.virtual.slidesAfter; O += 1)
      s.slidesPerGroup === 1 && p.push(p[p.length - 1] + W), g.push(g[g.length - 1] + W), d.virtualSize += W;
  }
  if (p.length === 0 && (p = [0]), G !== 0) {
    const W = d.isHorizontal() && a ? "marginLeft" : d.getDirectionLabel("marginRight");
    n.filter((O, j) => !s.cssMode || s.loop ? !0 : j !== n.length - 1).forEach((O) => {
      O.style[W] = `${G}px`;
    });
  }
  if (s.centeredSlides && s.centeredSlidesBounds) {
    let W = 0;
    v.forEach((j) => {
      W += j + (G || 0);
    }), W -= G;
    const O = W - i;
    p = p.map((j) => j <= 0 ? -x : j > O ? O + b : j);
  }
  if (s.centerInsufficientSlides) {
    let W = 0;
    if (v.forEach((O) => {
      W += O + (G || 0);
    }), W -= G, W < i) {
      const O = (i - W) / 2;
      p.forEach((j, U) => {
        p[U] = j - O;
      }), g.forEach((j, U) => {
        g[U] = j + O;
      });
    }
  }
  if (Object.assign(d, {
    slides: n,
    snapGrid: p,
    slidesGrid: g,
    slidesSizesGrid: v
  }), s.centeredSlides && s.cssMode && !s.centeredSlidesBounds) {
    setCSSProperty(e, "--swiper-centered-offset-before", `${-p[0]}px`), setCSSProperty(e, "--swiper-centered-offset-after", `${d.size / 2 - v[v.length - 1] / 2}px`);
    const W = -d.snapGrid[0], O = -d.slidesGrid[0];
    d.snapGrid = d.snapGrid.map((j) => j + W), d.slidesGrid = d.slidesGrid.map((j) => j + O);
  }
  if (u !== o && d.emit("slidesLengthChange"), p.length !== w && (d.params.watchOverflow && d.checkOverflow(), d.emit("snapGridLengthChange")), g.length !== M && d.emit("slidesGridLengthChange"), s.watchSlidesProgress && d.updateSlidesOffset(), d.emit("slidesUpdated"), !r && !s.cssMode && (s.effect === "slide" || s.effect === "fade")) {
    const W = `${s.containerModifierClass}backface-hidden`, O = d.el.classList.contains(W);
    u <= s.maxBackfaceHiddenSlides ? O || d.el.classList.add(W) : O && d.el.classList.remove(W);
  }
}
function updateAutoHeight(d) {
  const l = this, s = [], e = l.virtual && l.params.virtual.enabled;
  let f = 0, i;
  typeof d == "number" ? l.setTransition(d) : d === !0 && l.setTransition(l.params.speed);
  const a = (t) => e ? l.slides[l.getSlideIndexByData(t)] : l.slides[t];
  if (l.params.slidesPerView !== "auto" && l.params.slidesPerView > 1)
    if (l.params.centeredSlides)
      (l.visibleSlides || []).forEach((t) => {
        s.push(t);
      });
    else
      for (i = 0; i < Math.ceil(l.params.slidesPerView); i += 1) {
        const t = l.activeIndex + i;
        if (t > l.slides.length && !e)
          break;
        s.push(a(t));
      }
  else
    s.push(a(l.activeIndex));
  for (i = 0; i < s.length; i += 1)
    if (typeof s[i] < "u") {
      const t = s[i].offsetHeight;
      f = t > f ? t : f;
    }
  (f || f === 0) && (l.wrapperEl.style.height = `${f}px`);
}
function updateSlidesOffset() {
  const d = this, l = d.slides, s = d.isElement ? d.isHorizontal() ? d.wrapperEl.offsetLeft : d.wrapperEl.offsetTop : 0;
  for (let e = 0; e < l.length; e += 1)
    l[e].swiperSlideOffset = (d.isHorizontal() ? l[e].offsetLeft : l[e].offsetTop) - s - d.cssOverflowAdjustment();
}
function updateSlidesProgress(d) {
  d === void 0 && (d = this && this.translate || 0);
  const l = this, s = l.params, {
    slides: e,
    rtlTranslate: f,
    snapGrid: i
  } = l;
  if (e.length === 0)
    return;
  typeof e[0].swiperSlideOffset > "u" && l.updateSlidesOffset();
  let a = -d;
  f && (a = d), e.forEach((r) => {
    r.classList.remove(s.slideVisibleClass, s.slideFullyVisibleClass);
  }), l.visibleSlidesIndexes = [], l.visibleSlides = [];
  let t = s.spaceBetween;
  typeof t == "string" && t.indexOf("%") >= 0 ? t = parseFloat(t.replace("%", "")) / 100 * l.size : typeof t == "string" && (t = parseFloat(t));
  for (let r = 0; r < e.length; r += 1) {
    const o = e[r];
    let n = o.swiperSlideOffset;
    s.cssMode && s.centeredSlides && (n -= e[0].swiperSlideOffset);
    const u = (a + (s.centeredSlides ? l.minTranslate() : 0) - n) / (o.swiperSlideSize + t), p = (a - i[0] + (s.centeredSlides ? l.minTranslate() : 0) - n) / (o.swiperSlideSize + t), g = -(a - n), v = g + l.slidesSizesGrid[r], x = g >= 0 && g <= l.size - l.slidesSizesGrid[r];
    (g >= 0 && g < l.size - 1 || v > 1 && v <= l.size || g <= 0 && v >= l.size) && (l.visibleSlides.push(o), l.visibleSlidesIndexes.push(r), e[r].classList.add(s.slideVisibleClass)), x && e[r].classList.add(s.slideFullyVisibleClass), o.progress = f ? -u : u, o.originalProgress = f ? -p : p;
  }
}
function updateProgress(d) {
  const l = this;
  if (typeof d > "u") {
    const n = l.rtlTranslate ? -1 : 1;
    d = l && l.translate && l.translate * n || 0;
  }
  const s = l.params, e = l.maxTranslate() - l.minTranslate();
  let {
    progress: f,
    isBeginning: i,
    isEnd: a,
    progressLoop: t
  } = l;
  const r = i, o = a;
  if (e === 0)
    f = 0, i = !0, a = !0;
  else {
    f = (d - l.minTranslate()) / e;
    const n = Math.abs(d - l.minTranslate()) < 1, u = Math.abs(d - l.maxTranslate()) < 1;
    i = n || f <= 0, a = u || f >= 1, n && (f = 0), u && (f = 1);
  }
  if (s.loop) {
    const n = l.getSlideIndexByData(0), u = l.getSlideIndexByData(l.slides.length - 1), p = l.slidesGrid[n], g = l.slidesGrid[u], v = l.slidesGrid[l.slidesGrid.length - 1], x = Math.abs(d);
    x >= p ? t = (x - p) / v : t = (x + v - g) / v, t > 1 && (t -= 1);
  }
  Object.assign(l, {
    progress: f,
    progressLoop: t,
    isBeginning: i,
    isEnd: a
  }), (s.watchSlidesProgress || s.centeredSlides && s.autoHeight) && l.updateSlidesProgress(d), i && !r && l.emit("reachBeginning toEdge"), a && !o && l.emit("reachEnd toEdge"), (r && !i || o && !a) && l.emit("fromEdge"), l.emit("progress", f);
}
function updateSlidesClasses() {
  const d = this, {
    slides: l,
    params: s,
    slidesEl: e,
    activeIndex: f
  } = d, i = d.virtual && s.virtual.enabled, a = d.grid && s.grid && s.grid.rows > 1, t = (u) => elementChildren(e, `.${s.slideClass}${u}, swiper-slide${u}`)[0];
  l.forEach((u) => {
    u.classList.remove(s.slideActiveClass, s.slideNextClass, s.slidePrevClass);
  });
  let r, o, n;
  if (i)
    if (s.loop) {
      let u = f - d.virtual.slidesBefore;
      u < 0 && (u = d.virtual.slides.length + u), u >= d.virtual.slides.length && (u -= d.virtual.slides.length), r = t(`[data-swiper-slide-index="${u}"]`);
    } else
      r = t(`[data-swiper-slide-index="${f}"]`);
  else
    a ? (r = l.filter((u) => u.column === f)[0], n = l.filter((u) => u.column === f + 1)[0], o = l.filter((u) => u.column === f - 1)[0]) : r = l[f];
  r && (r.classList.add(s.slideActiveClass), a ? (n && n.classList.add(s.slideNextClass), o && o.classList.add(s.slidePrevClass)) : (n = elementNextAll(r, `.${s.slideClass}, swiper-slide`)[0], s.loop && !n && (n = l[0]), n && n.classList.add(s.slideNextClass), o = elementPrevAll(r, `.${s.slideClass}, swiper-slide`)[0], s.loop && !o === 0 && (o = l[l.length - 1]), o && o.classList.add(s.slidePrevClass))), d.emitSlidesClasses();
}
const processLazyPreloader = (d, l) => {
  if (!d || d.destroyed || !d.params)
    return;
  const s = () => d.isElement ? "swiper-slide" : `.${d.params.slideClass}`, e = l.closest(s());
  if (e) {
    let f = e.querySelector(`.${d.params.lazyPreloaderClass}`);
    !f && d.isElement && (e.shadowRoot ? f = e.shadowRoot.querySelector(`.${d.params.lazyPreloaderClass}`) : requestAnimationFrame(() => {
      e.shadowRoot && (f = e.shadowRoot.querySelector(`.${d.params.lazyPreloaderClass}`), f && f.remove());
    })), f && f.remove();
  }
}, unlazy = (d, l) => {
  if (!d.slides[l])
    return;
  const s = d.slides[l].querySelector('[loading="lazy"]');
  s && s.removeAttribute("loading");
}, preload = (d) => {
  if (!d || d.destroyed || !d.params)
    return;
  let l = d.params.lazyPreloadPrevNext;
  const s = d.slides.length;
  if (!s || !l || l < 0)
    return;
  l = Math.min(l, s);
  const e = d.params.slidesPerView === "auto" ? d.slidesPerViewDynamic() : Math.ceil(d.params.slidesPerView), f = d.activeIndex;
  if (d.params.grid && d.params.grid.rows > 1) {
    const a = f, t = [a - l];
    t.push(...Array.from({
      length: l
    }).map((r, o) => a + e + o)), d.slides.forEach((r, o) => {
      t.includes(r.column) && unlazy(d, o);
    });
    return;
  }
  const i = f + e - 1;
  if (d.params.rewind || d.params.loop)
    for (let a = f - l; a <= i + l; a += 1) {
      const t = (a % s + s) % s;
      (t < f || t > i) && unlazy(d, t);
    }
  else
    for (let a = Math.max(f - l, 0); a <= Math.min(i + l, s - 1); a += 1)
      a !== f && (a > i || a < f) && unlazy(d, a);
};
function getActiveIndexByTranslate(d) {
  const {
    slidesGrid: l,
    params: s
  } = d, e = d.rtlTranslate ? d.translate : -d.translate;
  let f;
  for (let i = 0; i < l.length; i += 1)
    typeof l[i + 1] < "u" ? e >= l[i] && e < l[i + 1] - (l[i + 1] - l[i]) / 2 ? f = i : e >= l[i] && e < l[i + 1] && (f = i + 1) : e >= l[i] && (f = i);
  return s.normalizeSlideIndex && (f < 0 || typeof f > "u") && (f = 0), f;
}
function updateActiveIndex(d) {
  const l = this, s = l.rtlTranslate ? l.translate : -l.translate, {
    snapGrid: e,
    params: f,
    activeIndex: i,
    realIndex: a,
    snapIndex: t
  } = l;
  let r = d, o;
  const n = (g) => {
    let v = g - l.virtual.slidesBefore;
    return v < 0 && (v = l.virtual.slides.length + v), v >= l.virtual.slides.length && (v -= l.virtual.slides.length), v;
  };
  if (typeof r > "u" && (r = getActiveIndexByTranslate(l)), e.indexOf(s) >= 0)
    o = e.indexOf(s);
  else {
    const g = Math.min(f.slidesPerGroupSkip, r);
    o = g + Math.floor((r - g) / f.slidesPerGroup);
  }
  if (o >= e.length && (o = e.length - 1), r === i && !l.params.loop) {
    o !== t && (l.snapIndex = o, l.emit("snapIndexChange"));
    return;
  }
  if (r === i && l.params.loop && l.virtual && l.params.virtual.enabled) {
    l.realIndex = n(r);
    return;
  }
  const u = l.grid && f.grid && f.grid.rows > 1;
  let p;
  if (l.virtual && f.virtual.enabled && f.loop)
    p = n(r);
  else if (u) {
    const g = l.slides.filter((x) => x.column === r)[0];
    let v = parseInt(g.getAttribute("data-swiper-slide-index"), 10);
    Number.isNaN(v) && (v = Math.max(l.slides.indexOf(g), 0)), p = Math.floor(v / f.grid.rows);
  } else if (l.slides[r]) {
    const g = l.slides[r].getAttribute("data-swiper-slide-index");
    g ? p = parseInt(g, 10) : p = r;
  } else
    p = r;
  Object.assign(l, {
    previousSnapIndex: t,
    snapIndex: o,
    previousRealIndex: a,
    realIndex: p,
    previousIndex: i,
    activeIndex: r
  }), l.initialized && preload(l), l.emit("activeIndexChange"), l.emit("snapIndexChange"), (l.initialized || l.params.runCallbacksOnInit) && (a !== p && l.emit("realIndexChange"), l.emit("slideChange"));
}
function updateClickedSlide(d, l) {
  const s = this, e = s.params;
  let f = d.closest(`.${e.slideClass}, swiper-slide`);
  !f && s.isElement && l && l.length > 1 && l.includes(d) && [...l.slice(l.indexOf(d) + 1, l.length)].forEach((t) => {
    !f && t.matches && t.matches(`.${e.slideClass}, swiper-slide`) && (f = t);
  });
  let i = !1, a;
  if (f) {
    for (let t = 0; t < s.slides.length; t += 1)
      if (s.slides[t] === f) {
        i = !0, a = t;
        break;
      }
  }
  if (f && i)
    s.clickedSlide = f, s.virtual && s.params.virtual.enabled ? s.clickedIndex = parseInt(f.getAttribute("data-swiper-slide-index"), 10) : s.clickedIndex = a;
  else {
    s.clickedSlide = void 0, s.clickedIndex = void 0;
    return;
  }
  e.slideToClickedSlide && s.clickedIndex !== void 0 && s.clickedIndex !== s.activeIndex && s.slideToClickedSlide();
}
var update = {
  updateSize,
  updateSlides,
  updateAutoHeight,
  updateSlidesOffset,
  updateSlidesProgress,
  updateProgress,
  updateSlidesClasses,
  updateActiveIndex,
  updateClickedSlide
};
function getSwiperTranslate(d) {
  d === void 0 && (d = this.isHorizontal() ? "x" : "y");
  const l = this, {
    params: s,
    rtlTranslate: e,
    translate: f,
    wrapperEl: i
  } = l;
  if (s.virtualTranslate)
    return e ? -f : f;
  if (s.cssMode)
    return f;
  let a = getTranslate(i, d);
  return a += l.cssOverflowAdjustment(), e && (a = -a), a || 0;
}
function setTranslate(d, l) {
  const s = this, {
    rtlTranslate: e,
    params: f,
    wrapperEl: i,
    progress: a
  } = s;
  let t = 0, r = 0;
  const o = 0;
  s.isHorizontal() ? t = e ? -d : d : r = d, f.roundLengths && (t = Math.floor(t), r = Math.floor(r)), s.previousTranslate = s.translate, s.translate = s.isHorizontal() ? t : r, f.cssMode ? i[s.isHorizontal() ? "scrollLeft" : "scrollTop"] = s.isHorizontal() ? -t : -r : f.virtualTranslate || (s.isHorizontal() ? t -= s.cssOverflowAdjustment() : r -= s.cssOverflowAdjustment(), i.style.transform = `translate3d(${t}px, ${r}px, ${o}px)`);
  let n;
  const u = s.maxTranslate() - s.minTranslate();
  u === 0 ? n = 0 : n = (d - s.minTranslate()) / u, n !== a && s.updateProgress(d), s.emit("setTranslate", s.translate, l);
}
function minTranslate() {
  return -this.snapGrid[0];
}
function maxTranslate() {
  return -this.snapGrid[this.snapGrid.length - 1];
}
function translateTo(d, l, s, e, f) {
  d === void 0 && (d = 0), l === void 0 && (l = this.params.speed), s === void 0 && (s = !0), e === void 0 && (e = !0);
  const i = this, {
    params: a,
    wrapperEl: t
  } = i;
  if (i.animating && a.preventInteractionOnTransition)
    return !1;
  const r = i.minTranslate(), o = i.maxTranslate();
  let n;
  if (e && d > r ? n = r : e && d < o ? n = o : n = d, i.updateProgress(n), a.cssMode) {
    const u = i.isHorizontal();
    if (l === 0)
      t[u ? "scrollLeft" : "scrollTop"] = -n;
    else {
      if (!i.support.smoothScroll)
        return animateCSSModeScroll({
          swiper: i,
          targetPosition: -n,
          side: u ? "left" : "top"
        }), !0;
      t.scrollTo({
        [u ? "left" : "top"]: -n,
        behavior: "smooth"
      });
    }
    return !0;
  }
  return l === 0 ? (i.setTransition(0), i.setTranslate(n), s && (i.emit("beforeTransitionStart", l, f), i.emit("transitionEnd"))) : (i.setTransition(l), i.setTranslate(n), s && (i.emit("beforeTransitionStart", l, f), i.emit("transitionStart")), i.animating || (i.animating = !0, i.onTranslateToWrapperTransitionEnd || (i.onTranslateToWrapperTransitionEnd = function(p) {
    !i || i.destroyed || p.target === this && (i.wrapperEl.removeEventListener("transitionend", i.onTranslateToWrapperTransitionEnd), i.onTranslateToWrapperTransitionEnd = null, delete i.onTranslateToWrapperTransitionEnd, s && i.emit("transitionEnd"));
  }), i.wrapperEl.addEventListener("transitionend", i.onTranslateToWrapperTransitionEnd))), !0;
}
var translate = {
  getTranslate: getSwiperTranslate,
  setTranslate,
  minTranslate,
  maxTranslate,
  translateTo
};
function setTransition(d, l) {
  const s = this;
  s.params.cssMode || (s.wrapperEl.style.transitionDuration = `${d}ms`, s.wrapperEl.style.transitionDelay = d === 0 ? "0ms" : ""), s.emit("setTransition", d, l);
}
function transitionEmit(d) {
  let {
    swiper: l,
    runCallbacks: s,
    direction: e,
    step: f
  } = d;
  const {
    activeIndex: i,
    previousIndex: a
  } = l;
  let t = e;
  if (t || (i > a ? t = "next" : i < a ? t = "prev" : t = "reset"), l.emit(`transition${f}`), s && i !== a) {
    if (t === "reset") {
      l.emit(`slideResetTransition${f}`);
      return;
    }
    l.emit(`slideChangeTransition${f}`), t === "next" ? l.emit(`slideNextTransition${f}`) : l.emit(`slidePrevTransition${f}`);
  }
}
function transitionStart(d, l) {
  d === void 0 && (d = !0);
  const s = this, {
    params: e
  } = s;
  e.cssMode || (e.autoHeight && s.updateAutoHeight(), transitionEmit({
    swiper: s,
    runCallbacks: d,
    direction: l,
    step: "Start"
  }));
}
function transitionEnd(d, l) {
  d === void 0 && (d = !0);
  const s = this, {
    params: e
  } = s;
  s.animating = !1, !e.cssMode && (s.setTransition(0), transitionEmit({
    swiper: s,
    runCallbacks: d,
    direction: l,
    step: "End"
  }));
}
var transition = {
  setTransition,
  transitionStart,
  transitionEnd
};
function slideTo(d, l, s, e, f) {
  d === void 0 && (d = 0), l === void 0 && (l = this.params.speed), s === void 0 && (s = !0), typeof d == "string" && (d = parseInt(d, 10));
  const i = this;
  let a = d;
  a < 0 && (a = 0);
  const {
    params: t,
    snapGrid: r,
    slidesGrid: o,
    previousIndex: n,
    activeIndex: u,
    rtlTranslate: p,
    wrapperEl: g,
    enabled: v
  } = i;
  if (i.animating && t.preventInteractionOnTransition || !v && !e && !f)
    return !1;
  const x = Math.min(i.params.slidesPerGroupSkip, a);
  let b = x + Math.floor((a - x) / i.params.slidesPerGroup);
  b >= r.length && (b = r.length - 1);
  const w = -r[b];
  if (t.normalizeSlideIndex)
    for (let G = 0; G < o.length; G += 1) {
      const F = -Math.floor(w * 100), V = Math.floor(o[G] * 100), q = Math.floor(o[G + 1] * 100);
      typeof o[G + 1] < "u" ? F >= V && F < q - (q - V) / 2 ? a = G : F >= V && F < q && (a = G + 1) : F >= V && (a = G);
    }
  if (i.initialized && a !== u && (!i.allowSlideNext && (p ? w > i.translate && w > i.minTranslate() : w < i.translate && w < i.minTranslate()) || !i.allowSlidePrev && w > i.translate && w > i.maxTranslate() && (u || 0) !== a))
    return !1;
  a !== (n || 0) && s && i.emit("beforeSlideChangeStart"), i.updateProgress(w);
  let M;
  if (a > u ? M = "next" : a < u ? M = "prev" : M = "reset", p && -w === i.translate || !p && w === i.translate)
    return i.updateActiveIndex(a), t.autoHeight && i.updateAutoHeight(), i.updateSlidesClasses(), t.effect !== "slide" && i.setTranslate(w), M !== "reset" && (i.transitionStart(s, M), i.transitionEnd(s, M)), !1;
  if (t.cssMode) {
    const G = i.isHorizontal(), F = p ? w : -w;
    if (l === 0) {
      const V = i.virtual && i.params.virtual.enabled;
      V && (i.wrapperEl.style.scrollSnapType = "none", i._immediateVirtual = !0), V && !i._cssModeVirtualInitialSet && i.params.initialSlide > 0 ? (i._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => {
        g[G ? "scrollLeft" : "scrollTop"] = F;
      })) : g[G ? "scrollLeft" : "scrollTop"] = F, V && requestAnimationFrame(() => {
        i.wrapperEl.style.scrollSnapType = "", i._immediateVirtual = !1;
      });
    } else {
      if (!i.support.smoothScroll)
        return animateCSSModeScroll({
          swiper: i,
          targetPosition: F,
          side: G ? "left" : "top"
        }), !0;
      g.scrollTo({
        [G ? "left" : "top"]: F,
        behavior: "smooth"
      });
    }
    return !0;
  }
  return i.setTransition(l), i.setTranslate(w), i.updateActiveIndex(a), i.updateSlidesClasses(), i.emit("beforeTransitionStart", l, e), i.transitionStart(s, M), l === 0 ? i.transitionEnd(s, M) : i.animating || (i.animating = !0, i.onSlideToWrapperTransitionEnd || (i.onSlideToWrapperTransitionEnd = function(F) {
    !i || i.destroyed || F.target === this && (i.wrapperEl.removeEventListener("transitionend", i.onSlideToWrapperTransitionEnd), i.onSlideToWrapperTransitionEnd = null, delete i.onSlideToWrapperTransitionEnd, i.transitionEnd(s, M));
  }), i.wrapperEl.addEventListener("transitionend", i.onSlideToWrapperTransitionEnd)), !0;
}
function slideToLoop(d, l, s, e) {
  d === void 0 && (d = 0), l === void 0 && (l = this.params.speed), s === void 0 && (s = !0), typeof d == "string" && (d = parseInt(d, 10));
  const f = this, i = f.grid && f.params.grid && f.params.grid.rows > 1;
  let a = d;
  if (f.params.loop)
    if (f.virtual && f.params.virtual.enabled)
      a = a + f.virtual.slidesBefore;
    else {
      let t;
      if (i) {
        const p = a * f.params.grid.rows;
        t = f.slides.filter((g) => g.getAttribute("data-swiper-slide-index") * 1 === p)[0].column;
      } else
        t = f.getSlideIndexByData(a);
      const r = i ? Math.ceil(f.slides.length / f.params.grid.rows) : f.slides.length, {
        centeredSlides: o
      } = f.params;
      let n = f.params.slidesPerView;
      n === "auto" ? n = f.slidesPerViewDynamic() : (n = Math.ceil(parseFloat(f.params.slidesPerView, 10)), o && n % 2 === 0 && (n = n + 1));
      let u = r - t < n;
      if (o && (u = u || t < Math.ceil(n / 2)), u) {
        const p = o ? t < f.activeIndex ? "prev" : "next" : t - f.activeIndex - 1 < f.params.slidesPerView ? "next" : "prev";
        f.loopFix({
          direction: p,
          slideTo: !0,
          activeSlideIndex: p === "next" ? t + 1 : t - r + 1,
          slideRealIndex: p === "next" ? f.realIndex : void 0
        });
      }
      if (i) {
        const p = a * f.params.grid.rows;
        a = f.slides.filter((g) => g.getAttribute("data-swiper-slide-index") * 1 === p)[0].column;
      } else
        a = f.getSlideIndexByData(a);
    }
  return requestAnimationFrame(() => {
    f.slideTo(a, l, s, e);
  }), f;
}
function slideNext(d, l, s) {
  d === void 0 && (d = this.params.speed), l === void 0 && (l = !0);
  const e = this, {
    enabled: f,
    params: i,
    animating: a
  } = e;
  if (!f)
    return e;
  let t = i.slidesPerGroup;
  i.slidesPerView === "auto" && i.slidesPerGroup === 1 && i.slidesPerGroupAuto && (t = Math.max(e.slidesPerViewDynamic("current", !0), 1));
  const r = e.activeIndex < i.slidesPerGroupSkip ? 1 : t, o = e.virtual && i.virtual.enabled;
  if (i.loop) {
    if (a && !o && i.loopPreventsSliding)
      return !1;
    if (e.loopFix({
      direction: "next"
    }), e._clientLeft = e.wrapperEl.clientLeft, e.activeIndex === e.slides.length - 1 && i.cssMode)
      return requestAnimationFrame(() => {
        e.slideTo(e.activeIndex + r, d, l, s);
      }), !0;
  }
  return i.rewind && e.isEnd ? e.slideTo(0, d, l, s) : e.slideTo(e.activeIndex + r, d, l, s);
}
function slidePrev(d, l, s) {
  d === void 0 && (d = this.params.speed), l === void 0 && (l = !0);
  const e = this, {
    params: f,
    snapGrid: i,
    slidesGrid: a,
    rtlTranslate: t,
    enabled: r,
    animating: o
  } = e;
  if (!r)
    return e;
  const n = e.virtual && f.virtual.enabled;
  if (f.loop) {
    if (o && !n && f.loopPreventsSliding)
      return !1;
    e.loopFix({
      direction: "prev"
    }), e._clientLeft = e.wrapperEl.clientLeft;
  }
  const u = t ? e.translate : -e.translate;
  function p(w) {
    return w < 0 ? -Math.floor(Math.abs(w)) : Math.floor(w);
  }
  const g = p(u), v = i.map((w) => p(w));
  let x = i[v.indexOf(g) - 1];
  if (typeof x > "u" && f.cssMode) {
    let w;
    i.forEach((M, G) => {
      g >= M && (w = G);
    }), typeof w < "u" && (x = i[w > 0 ? w - 1 : w]);
  }
  let b = 0;
  if (typeof x < "u" && (b = a.indexOf(x), b < 0 && (b = e.activeIndex - 1), f.slidesPerView === "auto" && f.slidesPerGroup === 1 && f.slidesPerGroupAuto && (b = b - e.slidesPerViewDynamic("previous", !0) + 1, b = Math.max(b, 0))), f.rewind && e.isBeginning) {
    const w = e.params.virtual && e.params.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1;
    return e.slideTo(w, d, l, s);
  } else if (f.loop && e.activeIndex === 0 && f.cssMode)
    return requestAnimationFrame(() => {
      e.slideTo(b, d, l, s);
    }), !0;
  return e.slideTo(b, d, l, s);
}
function slideReset(d, l, s) {
  d === void 0 && (d = this.params.speed), l === void 0 && (l = !0);
  const e = this;
  return e.slideTo(e.activeIndex, d, l, s);
}
function slideToClosest(d, l, s, e) {
  d === void 0 && (d = this.params.speed), l === void 0 && (l = !0), e === void 0 && (e = 0.5);
  const f = this;
  let i = f.activeIndex;
  const a = Math.min(f.params.slidesPerGroupSkip, i), t = a + Math.floor((i - a) / f.params.slidesPerGroup), r = f.rtlTranslate ? f.translate : -f.translate;
  if (r >= f.snapGrid[t]) {
    const o = f.snapGrid[t], n = f.snapGrid[t + 1];
    r - o > (n - o) * e && (i += f.params.slidesPerGroup);
  } else {
    const o = f.snapGrid[t - 1], n = f.snapGrid[t];
    r - o <= (n - o) * e && (i -= f.params.slidesPerGroup);
  }
  return i = Math.max(i, 0), i = Math.min(i, f.slidesGrid.length - 1), f.slideTo(i, d, l, s);
}
function slideToClickedSlide() {
  const d = this, {
    params: l,
    slidesEl: s
  } = d, e = l.slidesPerView === "auto" ? d.slidesPerViewDynamic() : l.slidesPerView;
  let f = d.clickedIndex, i;
  const a = d.isElement ? "swiper-slide" : `.${l.slideClass}`;
  if (l.loop) {
    if (d.animating)
      return;
    i = parseInt(d.clickedSlide.getAttribute("data-swiper-slide-index"), 10), l.centeredSlides ? f < d.loopedSlides - e / 2 || f > d.slides.length - d.loopedSlides + e / 2 ? (d.loopFix(), f = d.getSlideIndex(elementChildren(s, `${a}[data-swiper-slide-index="${i}"]`)[0]), nextTick(() => {
      d.slideTo(f);
    })) : d.slideTo(f) : f > d.slides.length - e ? (d.loopFix(), f = d.getSlideIndex(elementChildren(s, `${a}[data-swiper-slide-index="${i}"]`)[0]), nextTick(() => {
      d.slideTo(f);
    })) : d.slideTo(f);
  } else
    d.slideTo(f);
}
var slide = {
  slideTo,
  slideToLoop,
  slideNext,
  slidePrev,
  slideReset,
  slideToClosest,
  slideToClickedSlide
};
function loopCreate(d) {
  const l = this, {
    params: s,
    slidesEl: e
  } = l;
  if (!s.loop || l.virtual && l.params.virtual.enabled)
    return;
  const f = () => {
    elementChildren(e, `.${s.slideClass}, swiper-slide`).forEach((u, p) => {
      u.setAttribute("data-swiper-slide-index", p);
    });
  }, i = l.grid && s.grid && s.grid.rows > 1, a = s.slidesPerGroup * (i ? s.grid.rows : 1), t = l.slides.length % a !== 0, r = i && l.slides.length % s.grid.rows !== 0, o = (n) => {
    for (let u = 0; u < n; u += 1) {
      const p = l.isElement ? createElement("swiper-slide", [s.slideBlankClass]) : createElement("div", [s.slideClass, s.slideBlankClass]);
      l.slidesEl.append(p);
    }
  };
  if (t) {
    if (s.loopAddBlankSlides) {
      const n = a - l.slides.length % a;
      o(n), l.recalcSlides(), l.updateSlides();
    } else
      showWarning("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    f();
  } else if (r) {
    if (s.loopAddBlankSlides) {
      const n = s.grid.rows - l.slides.length % s.grid.rows;
      o(n), l.recalcSlides(), l.updateSlides();
    } else
      showWarning("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)");
    f();
  } else
    f();
  l.loopFix({
    slideRealIndex: d,
    direction: s.centeredSlides ? void 0 : "next"
  });
}
function loopFix(d) {
  let {
    slideRealIndex: l,
    slideTo: s = !0,
    direction: e,
    setTranslate: f,
    activeSlideIndex: i,
    byController: a,
    byMousewheel: t
  } = d === void 0 ? {} : d;
  const r = this;
  if (!r.params.loop)
    return;
  r.emit("beforeLoopFix");
  const {
    slides: o,
    allowSlidePrev: n,
    allowSlideNext: u,
    slidesEl: p,
    params: g
  } = r, {
    centeredSlides: v
  } = g;
  if (r.allowSlidePrev = !0, r.allowSlideNext = !0, r.virtual && g.virtual.enabled) {
    s && (!g.centeredSlides && r.snapIndex === 0 ? r.slideTo(r.virtual.slides.length, 0, !1, !0) : g.centeredSlides && r.snapIndex < g.slidesPerView ? r.slideTo(r.virtual.slides.length + r.snapIndex, 0, !1, !0) : r.snapIndex === r.snapGrid.length - 1 && r.slideTo(r.virtual.slidesBefore, 0, !1, !0)), r.allowSlidePrev = n, r.allowSlideNext = u, r.emit("loopFix");
    return;
  }
  let x = g.slidesPerView;
  x === "auto" ? x = r.slidesPerViewDynamic() : (x = Math.ceil(parseFloat(g.slidesPerView, 10)), v && x % 2 === 0 && (x = x + 1));
  const b = g.slidesPerGroupAuto ? x : g.slidesPerGroup;
  let w = b;
  w % b !== 0 && (w += b - w % b), w += g.loopAdditionalSlides, r.loopedSlides = w;
  const M = r.grid && g.grid && g.grid.rows > 1;
  o.length < x + w ? showWarning("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : M && g.grid.fill === "row" && showWarning("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`");
  const G = [], F = [];
  let V = r.activeIndex;
  typeof i > "u" ? i = r.getSlideIndex(o.filter((U) => U.classList.contains(g.slideActiveClass))[0]) : V = i;
  const q = e === "next" || !e, I = e === "prev" || !e;
  let _ = 0, R = 0;
  const W = M ? Math.ceil(o.length / g.grid.rows) : o.length, j = (M ? o[i].column : i) + (v && typeof f > "u" ? -x / 2 + 0.5 : 0);
  if (j < w) {
    _ = Math.max(w - j, b);
    for (let U = 0; U < w - j; U += 1) {
      const C = U - Math.floor(U / W) * W;
      if (M) {
        const ae = W - C - 1;
        for (let J = o.length - 1; J >= 0; J -= 1)
          o[J].column === ae && G.push(J);
      } else
        G.push(W - C - 1);
    }
  } else if (j + x > W - w) {
    R = Math.max(j - (W - w * 2), b);
    for (let U = 0; U < R; U += 1) {
      const C = U - Math.floor(U / W) * W;
      M ? o.forEach((ae, J) => {
        ae.column === C && F.push(J);
      }) : F.push(C);
    }
  }
  if (r.__preventObserver__ = !0, requestAnimationFrame(() => {
    r.__preventObserver__ = !1;
  }), I && G.forEach((U) => {
    o[U].swiperLoopMoveDOM = !0, p.prepend(o[U]), o[U].swiperLoopMoveDOM = !1;
  }), q && F.forEach((U) => {
    o[U].swiperLoopMoveDOM = !0, p.append(o[U]), o[U].swiperLoopMoveDOM = !1;
  }), r.recalcSlides(), g.slidesPerView === "auto" ? r.updateSlides() : M && (G.length > 0 && I || F.length > 0 && q) && r.slides.forEach((U, C) => {
    r.grid.updateSlide(C, U, r.slides);
  }), g.watchSlidesProgress && r.updateSlidesOffset(), s) {
    if (G.length > 0 && I) {
      if (typeof l > "u") {
        const U = r.slidesGrid[V], ae = r.slidesGrid[V + _] - U;
        t ? r.setTranslate(r.translate - ae) : (r.slideTo(V + _, 0, !1, !0), f && (r.touchEventsData.startTranslate = r.touchEventsData.startTranslate - ae, r.touchEventsData.currentTranslate = r.touchEventsData.currentTranslate - ae));
      } else if (f) {
        const U = M ? G.length / g.grid.rows : G.length;
        r.slideTo(r.activeIndex + U, 0, !1, !0), r.touchEventsData.currentTranslate = r.translate;
      }
    } else if (F.length > 0 && q)
      if (typeof l > "u") {
        const U = r.slidesGrid[V], ae = r.slidesGrid[V - R] - U;
        t ? r.setTranslate(r.translate - ae) : (r.slideTo(V - R, 0, !1, !0), f && (r.touchEventsData.startTranslate = r.touchEventsData.startTranslate - ae, r.touchEventsData.currentTranslate = r.touchEventsData.currentTranslate - ae));
      } else {
        const U = M ? F.length / g.grid.rows : F.length;
        r.slideTo(r.activeIndex - U, 0, !1, !0);
      }
  }
  if (r.allowSlidePrev = n, r.allowSlideNext = u, r.controller && r.controller.control && !a) {
    const U = {
      slideRealIndex: l,
      direction: e,
      setTranslate: f,
      activeSlideIndex: i,
      byController: !0
    };
    Array.isArray(r.controller.control) ? r.controller.control.forEach((C) => {
      !C.destroyed && C.params.loop && C.loopFix({
        ...U,
        slideTo: C.params.slidesPerView === g.slidesPerView ? s : !1
      });
    }) : r.controller.control instanceof r.constructor && r.controller.control.params.loop && r.controller.control.loopFix({
      ...U,
      slideTo: r.controller.control.params.slidesPerView === g.slidesPerView ? s : !1
    });
  }
  r.emit("loopFix");
}
function loopDestroy() {
  const d = this, {
    params: l,
    slidesEl: s
  } = d;
  if (!l.loop || d.virtual && d.params.virtual.enabled)
    return;
  d.recalcSlides();
  const e = [];
  d.slides.forEach((f) => {
    const i = typeof f.swiperSlideIndex > "u" ? f.getAttribute("data-swiper-slide-index") * 1 : f.swiperSlideIndex;
    e[i] = f;
  }), d.slides.forEach((f) => {
    f.removeAttribute("data-swiper-slide-index");
  }), e.forEach((f) => {
    s.append(f);
  }), d.recalcSlides(), d.slideTo(d.realIndex, 0);
}
var loop = {
  loopCreate,
  loopFix,
  loopDestroy
};
function setGrabCursor(d) {
  const l = this;
  if (!l.params.simulateTouch || l.params.watchOverflow && l.isLocked || l.params.cssMode)
    return;
  const s = l.params.touchEventsTarget === "container" ? l.el : l.wrapperEl;
  l.isElement && (l.__preventObserver__ = !0), s.style.cursor = "move", s.style.cursor = d ? "grabbing" : "grab", l.isElement && requestAnimationFrame(() => {
    l.__preventObserver__ = !1;
  });
}
function unsetGrabCursor() {
  const d = this;
  d.params.watchOverflow && d.isLocked || d.params.cssMode || (d.isElement && (d.__preventObserver__ = !0), d[d.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", d.isElement && requestAnimationFrame(() => {
    d.__preventObserver__ = !1;
  }));
}
var grabCursor = {
  setGrabCursor,
  unsetGrabCursor
};
function closestElement(d, l) {
  l === void 0 && (l = this);
  function s(e) {
    if (!e || e === getDocument() || e === getWindow())
      return null;
    e.assignedSlot && (e = e.assignedSlot);
    const f = e.closest(d);
    return !f && !e.getRootNode ? null : f || s(e.getRootNode().host);
  }
  return s(l);
}
function preventEdgeSwipe(d, l, s) {
  const e = getWindow(), {
    params: f
  } = d, i = f.edgeSwipeDetection, a = f.edgeSwipeThreshold;
  return i && (s <= a || s >= e.innerWidth - a) ? i === "prevent" ? (l.preventDefault(), !0) : !1 : !0;
}
function onTouchStart(d) {
  const l = this, s = getDocument();
  let e = d;
  e.originalEvent && (e = e.originalEvent);
  const f = l.touchEventsData;
  if (e.type === "pointerdown") {
    if (f.pointerId !== null && f.pointerId !== e.pointerId)
      return;
    f.pointerId = e.pointerId;
  } else
    e.type === "touchstart" && e.targetTouches.length === 1 && (f.touchId = e.targetTouches[0].identifier);
  if (e.type === "touchstart") {
    preventEdgeSwipe(l, e, e.targetTouches[0].pageX);
    return;
  }
  const {
    params: i,
    touches: a,
    enabled: t
  } = l;
  if (!t || !i.simulateTouch && e.pointerType === "mouse" || l.animating && i.preventInteractionOnTransition)
    return;
  !l.animating && i.cssMode && i.loop && l.loopFix();
  let r = e.target;
  if (i.touchEventsTarget === "wrapper" && !l.wrapperEl.contains(r) || "which" in e && e.which === 3 || "button" in e && e.button > 0 || f.isTouched && f.isMoved)
    return;
  const o = !!i.noSwipingClass && i.noSwipingClass !== "", n = e.composedPath ? e.composedPath() : e.path;
  o && e.target && e.target.shadowRoot && n && (r = n[0]);
  const u = i.noSwipingSelector ? i.noSwipingSelector : `.${i.noSwipingClass}`, p = !!(e.target && e.target.shadowRoot);
  if (i.noSwiping && (p ? closestElement(u, r) : r.closest(u))) {
    l.allowClick = !0;
    return;
  }
  if (i.swipeHandler && !r.closest(i.swipeHandler))
    return;
  a.currentX = e.pageX, a.currentY = e.pageY;
  const g = a.currentX, v = a.currentY;
  if (!preventEdgeSwipe(l, e, g))
    return;
  Object.assign(f, {
    isTouched: !0,
    isMoved: !1,
    allowTouchCallbacks: !0,
    isScrolling: void 0,
    startMoving: void 0
  }), a.startX = g, a.startY = v, f.touchStartTime = now(), l.allowClick = !0, l.updateSize(), l.swipeDirection = void 0, i.threshold > 0 && (f.allowThresholdMove = !1);
  let x = !0;
  r.matches(f.focusableElements) && (x = !1, r.nodeName === "SELECT" && (f.isTouched = !1)), s.activeElement && s.activeElement.matches(f.focusableElements) && s.activeElement !== r && s.activeElement.blur();
  const b = x && l.allowTouchMove && i.touchStartPreventDefault;
  (i.touchStartForcePreventDefault || b) && !r.isContentEditable && e.preventDefault(), i.freeMode && i.freeMode.enabled && l.freeMode && l.animating && !i.cssMode && l.freeMode.onTouchStart(), l.emit("touchStart", e);
}
function onTouchMove(d) {
  const l = getDocument(), s = this, e = s.touchEventsData, {
    params: f,
    touches: i,
    rtlTranslate: a,
    enabled: t
  } = s;
  if (!t || !f.simulateTouch && d.pointerType === "mouse")
    return;
  let r = d;
  if (r.originalEvent && (r = r.originalEvent), r.type === "pointermove" && (e.touchId !== null || r.pointerId !== e.pointerId))
    return;
  let o;
  if (r.type === "touchmove") {
    if (o = [...r.changedTouches].filter((q) => q.identifier === e.touchId)[0], !o || o.identifier !== e.touchId)
      return;
  } else
    o = r;
  if (!e.isTouched) {
    e.startMoving && e.isScrolling && s.emit("touchMoveOpposite", r);
    return;
  }
  const n = o.pageX, u = o.pageY;
  if (r.preventedByNestedSwiper) {
    i.startX = n, i.startY = u;
    return;
  }
  if (!s.allowTouchMove) {
    r.target.matches(e.focusableElements) || (s.allowClick = !1), e.isTouched && (Object.assign(i, {
      startX: n,
      startY: u,
      currentX: n,
      currentY: u
    }), e.touchStartTime = now());
    return;
  }
  if (f.touchReleaseOnEdges && !f.loop) {
    if (s.isVertical()) {
      if (u < i.startY && s.translate <= s.maxTranslate() || u > i.startY && s.translate >= s.minTranslate()) {
        e.isTouched = !1, e.isMoved = !1;
        return;
      }
    } else if (n < i.startX && s.translate <= s.maxTranslate() || n > i.startX && s.translate >= s.minTranslate())
      return;
  }
  if (l.activeElement && r.target === l.activeElement && r.target.matches(e.focusableElements)) {
    e.isMoved = !0, s.allowClick = !1;
    return;
  }
  e.allowTouchCallbacks && s.emit("touchMove", r), i.previousX = i.currentX, i.previousY = i.currentY, i.currentX = n, i.currentY = u;
  const p = i.currentX - i.startX, g = i.currentY - i.startY;
  if (s.params.threshold && Math.sqrt(p ** 2 + g ** 2) < s.params.threshold)
    return;
  if (typeof e.isScrolling > "u") {
    let q;
    s.isHorizontal() && i.currentY === i.startY || s.isVertical() && i.currentX === i.startX ? e.isScrolling = !1 : p * p + g * g >= 25 && (q = Math.atan2(Math.abs(g), Math.abs(p)) * 180 / Math.PI, e.isScrolling = s.isHorizontal() ? q > f.touchAngle : 90 - q > f.touchAngle);
  }
  if (e.isScrolling && s.emit("touchMoveOpposite", r), typeof e.startMoving > "u" && (i.currentX !== i.startX || i.currentY !== i.startY) && (e.startMoving = !0), e.isScrolling) {
    e.isTouched = !1;
    return;
  }
  if (!e.startMoving)
    return;
  s.allowClick = !1, !f.cssMode && r.cancelable && r.preventDefault(), f.touchMoveStopPropagation && !f.nested && r.stopPropagation();
  let v = s.isHorizontal() ? p : g, x = s.isHorizontal() ? i.currentX - i.previousX : i.currentY - i.previousY;
  f.oneWayMovement && (v = Math.abs(v) * (a ? 1 : -1), x = Math.abs(x) * (a ? 1 : -1)), i.diff = v, v *= f.touchRatio, a && (v = -v, x = -x);
  const b = s.touchesDirection;
  s.swipeDirection = v > 0 ? "prev" : "next", s.touchesDirection = x > 0 ? "prev" : "next";
  const w = s.params.loop && !f.cssMode, M = s.touchesDirection === "next" && s.allowSlideNext || s.touchesDirection === "prev" && s.allowSlidePrev;
  if (!e.isMoved) {
    if (w && M && s.loopFix({
      direction: s.swipeDirection
    }), e.startTranslate = s.getTranslate(), s.setTransition(0), s.animating) {
      const q = new window.CustomEvent("transitionend", {
        bubbles: !0,
        cancelable: !0
      });
      s.wrapperEl.dispatchEvent(q);
    }
    e.allowMomentumBounce = !1, f.grabCursor && (s.allowSlideNext === !0 || s.allowSlidePrev === !0) && s.setGrabCursor(!0), s.emit("sliderFirstMove", r);
  }
  let G;
  if ((/* @__PURE__ */ new Date()).getTime(), e.isMoved && e.allowThresholdMove && b !== s.touchesDirection && w && M && Math.abs(v) >= 1) {
    Object.assign(i, {
      startX: n,
      startY: u,
      currentX: n,
      currentY: u,
      startTranslate: e.currentTranslate
    }), e.loopSwapReset = !0, e.startTranslate = e.currentTranslate;
    return;
  }
  s.emit("sliderMove", r), e.isMoved = !0, e.currentTranslate = v + e.startTranslate;
  let F = !0, V = f.resistanceRatio;
  if (f.touchReleaseOnEdges && (V = 0), v > 0 ? (w && M && !G && e.allowThresholdMove && e.currentTranslate > (f.centeredSlides ? s.minTranslate() - s.slidesSizesGrid[s.activeIndex + 1] : s.minTranslate()) && s.loopFix({
    direction: "prev",
    setTranslate: !0,
    activeSlideIndex: 0
  }), e.currentTranslate > s.minTranslate() && (F = !1, f.resistance && (e.currentTranslate = s.minTranslate() - 1 + (-s.minTranslate() + e.startTranslate + v) ** V))) : v < 0 && (w && M && !G && e.allowThresholdMove && e.currentTranslate < (f.centeredSlides ? s.maxTranslate() + s.slidesSizesGrid[s.slidesSizesGrid.length - 1] : s.maxTranslate()) && s.loopFix({
    direction: "next",
    setTranslate: !0,
    activeSlideIndex: s.slides.length - (f.slidesPerView === "auto" ? s.slidesPerViewDynamic() : Math.ceil(parseFloat(f.slidesPerView, 10)))
  }), e.currentTranslate < s.maxTranslate() && (F = !1, f.resistance && (e.currentTranslate = s.maxTranslate() + 1 - (s.maxTranslate() - e.startTranslate - v) ** V))), F && (r.preventedByNestedSwiper = !0), !s.allowSlideNext && s.swipeDirection === "next" && e.currentTranslate < e.startTranslate && (e.currentTranslate = e.startTranslate), !s.allowSlidePrev && s.swipeDirection === "prev" && e.currentTranslate > e.startTranslate && (e.currentTranslate = e.startTranslate), !s.allowSlidePrev && !s.allowSlideNext && (e.currentTranslate = e.startTranslate), f.threshold > 0)
    if (Math.abs(v) > f.threshold || e.allowThresholdMove) {
      if (!e.allowThresholdMove) {
        e.allowThresholdMove = !0, i.startX = i.currentX, i.startY = i.currentY, e.currentTranslate = e.startTranslate, i.diff = s.isHorizontal() ? i.currentX - i.startX : i.currentY - i.startY;
        return;
      }
    } else {
      e.currentTranslate = e.startTranslate;
      return;
    }
  !f.followFinger || f.cssMode || ((f.freeMode && f.freeMode.enabled && s.freeMode || f.watchSlidesProgress) && (s.updateActiveIndex(), s.updateSlidesClasses()), f.freeMode && f.freeMode.enabled && s.freeMode && s.freeMode.onTouchMove(), s.updateProgress(e.currentTranslate), s.setTranslate(e.currentTranslate));
}
function onTouchEnd(d) {
  const l = this, s = l.touchEventsData;
  let e = d;
  e.originalEvent && (e = e.originalEvent);
  let f;
  if (e.type === "touchend" || e.type === "touchcancel") {
    if (f = [...e.changedTouches].filter((V) => V.identifier === s.touchId)[0], !f || f.identifier !== s.touchId)
      return;
  } else {
    if (s.touchId !== null || e.pointerId !== s.pointerId)
      return;
    f = e;
  }
  if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(e.type) && !(["pointercancel", "contextmenu"].includes(e.type) && (l.browser.isSafari || l.browser.isWebView)))
    return;
  s.pointerId = null, s.touchId = null;
  const {
    params: a,
    touches: t,
    rtlTranslate: r,
    slidesGrid: o,
    enabled: n
  } = l;
  if (!n || !a.simulateTouch && e.pointerType === "mouse")
    return;
  if (s.allowTouchCallbacks && l.emit("touchEnd", e), s.allowTouchCallbacks = !1, !s.isTouched) {
    s.isMoved && a.grabCursor && l.setGrabCursor(!1), s.isMoved = !1, s.startMoving = !1;
    return;
  }
  a.grabCursor && s.isMoved && s.isTouched && (l.allowSlideNext === !0 || l.allowSlidePrev === !0) && l.setGrabCursor(!1);
  const u = now(), p = u - s.touchStartTime;
  if (l.allowClick) {
    const V = e.path || e.composedPath && e.composedPath();
    l.updateClickedSlide(V && V[0] || e.target, V), l.emit("tap click", e), p < 300 && u - s.lastClickTime < 300 && l.emit("doubleTap doubleClick", e);
  }
  if (s.lastClickTime = now(), nextTick(() => {
    l.destroyed || (l.allowClick = !0);
  }), !s.isTouched || !s.isMoved || !l.swipeDirection || t.diff === 0 && !s.loopSwapReset || s.currentTranslate === s.startTranslate && !s.loopSwapReset) {
    s.isTouched = !1, s.isMoved = !1, s.startMoving = !1;
    return;
  }
  s.isTouched = !1, s.isMoved = !1, s.startMoving = !1;
  let g;
  if (a.followFinger ? g = r ? l.translate : -l.translate : g = -s.currentTranslate, a.cssMode)
    return;
  if (a.freeMode && a.freeMode.enabled) {
    l.freeMode.onTouchEnd({
      currentPos: g
    });
    return;
  }
  const v = g >= -l.maxTranslate() && !l.params.loop;
  let x = 0, b = l.slidesSizesGrid[0];
  for (let V = 0; V < o.length; V += V < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) {
    const q = V < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
    typeof o[V + q] < "u" ? (v || g >= o[V] && g < o[V + q]) && (x = V, b = o[V + q] - o[V]) : (v || g >= o[V]) && (x = V, b = o[o.length - 1] - o[o.length - 2]);
  }
  let w = null, M = null;
  a.rewind && (l.isBeginning ? M = a.virtual && a.virtual.enabled && l.virtual ? l.virtual.slides.length - 1 : l.slides.length - 1 : l.isEnd && (w = 0));
  const G = (g - o[x]) / b, F = x < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup;
  if (p > a.longSwipesMs) {
    if (!a.longSwipes) {
      l.slideTo(l.activeIndex);
      return;
    }
    l.swipeDirection === "next" && (G >= a.longSwipesRatio ? l.slideTo(a.rewind && l.isEnd ? w : x + F) : l.slideTo(x)), l.swipeDirection === "prev" && (G > 1 - a.longSwipesRatio ? l.slideTo(x + F) : M !== null && G < 0 && Math.abs(G) > a.longSwipesRatio ? l.slideTo(M) : l.slideTo(x));
  } else {
    if (!a.shortSwipes) {
      l.slideTo(l.activeIndex);
      return;
    }
    l.navigation && (e.target === l.navigation.nextEl || e.target === l.navigation.prevEl) ? e.target === l.navigation.nextEl ? l.slideTo(x + F) : l.slideTo(x) : (l.swipeDirection === "next" && l.slideTo(w !== null ? w : x + F), l.swipeDirection === "prev" && l.slideTo(M !== null ? M : x));
  }
}
function onResize() {
  const d = this, {
    params: l,
    el: s
  } = d;
  if (s && s.offsetWidth === 0)
    return;
  l.breakpoints && d.setBreakpoint();
  const {
    allowSlideNext: e,
    allowSlidePrev: f,
    snapGrid: i
  } = d, a = d.virtual && d.params.virtual.enabled;
  d.allowSlideNext = !0, d.allowSlidePrev = !0, d.updateSize(), d.updateSlides(), d.updateSlidesClasses();
  const t = a && l.loop;
  (l.slidesPerView === "auto" || l.slidesPerView > 1) && d.isEnd && !d.isBeginning && !d.params.centeredSlides && !t ? d.slideTo(d.slides.length - 1, 0, !1, !0) : d.params.loop && !a ? d.slideToLoop(d.realIndex, 0, !1, !0) : d.slideTo(d.activeIndex, 0, !1, !0), d.autoplay && d.autoplay.running && d.autoplay.paused && (clearTimeout(d.autoplay.resizeTimeout), d.autoplay.resizeTimeout = setTimeout(() => {
    d.autoplay && d.autoplay.running && d.autoplay.paused && d.autoplay.resume();
  }, 500)), d.allowSlidePrev = f, d.allowSlideNext = e, d.params.watchOverflow && i !== d.snapGrid && d.checkOverflow();
}
function onClick(d) {
  const l = this;
  l.enabled && (l.allowClick || (l.params.preventClicks && d.preventDefault(), l.params.preventClicksPropagation && l.animating && (d.stopPropagation(), d.stopImmediatePropagation())));
}
function onScroll() {
  const d = this, {
    wrapperEl: l,
    rtlTranslate: s,
    enabled: e
  } = d;
  if (!e)
    return;
  d.previousTranslate = d.translate, d.isHorizontal() ? d.translate = -l.scrollLeft : d.translate = -l.scrollTop, d.translate === 0 && (d.translate = 0), d.updateActiveIndex(), d.updateSlidesClasses();
  let f;
  const i = d.maxTranslate() - d.minTranslate();
  i === 0 ? f = 0 : f = (d.translate - d.minTranslate()) / i, f !== d.progress && d.updateProgress(s ? -d.translate : d.translate), d.emit("setTranslate", d.translate, !1);
}
function onLoad(d) {
  const l = this;
  processLazyPreloader(l, d.target), !(l.params.cssMode || l.params.slidesPerView !== "auto" && !l.params.autoHeight) && l.update();
}
function onDocumentTouchStart() {
  const d = this;
  d.documentTouchHandlerProceeded || (d.documentTouchHandlerProceeded = !0, d.params.touchReleaseOnEdges && (d.el.style.touchAction = "auto"));
}
const events = (d, l) => {
  const s = getDocument(), {
    params: e,
    el: f,
    wrapperEl: i,
    device: a
  } = d, t = !!e.nested, r = l === "on" ? "addEventListener" : "removeEventListener", o = l;
  s[r]("touchstart", d.onDocumentTouchStart, {
    passive: !1,
    capture: t
  }), f[r]("touchstart", d.onTouchStart, {
    passive: !1
  }), f[r]("pointerdown", d.onTouchStart, {
    passive: !1
  }), s[r]("touchmove", d.onTouchMove, {
    passive: !1,
    capture: t
  }), s[r]("pointermove", d.onTouchMove, {
    passive: !1,
    capture: t
  }), s[r]("touchend", d.onTouchEnd, {
    passive: !0
  }), s[r]("pointerup", d.onTouchEnd, {
    passive: !0
  }), s[r]("pointercancel", d.onTouchEnd, {
    passive: !0
  }), s[r]("touchcancel", d.onTouchEnd, {
    passive: !0
  }), s[r]("pointerout", d.onTouchEnd, {
    passive: !0
  }), s[r]("pointerleave", d.onTouchEnd, {
    passive: !0
  }), s[r]("contextmenu", d.onTouchEnd, {
    passive: !0
  }), (e.preventClicks || e.preventClicksPropagation) && f[r]("click", d.onClick, !0), e.cssMode && i[r]("scroll", d.onScroll), e.updateOnWindowResize ? d[o](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", onResize, !0) : d[o]("observerUpdate", onResize, !0), f[r]("load", d.onLoad, {
    capture: !0
  });
};
function attachEvents() {
  const d = this, {
    params: l
  } = d;
  d.onTouchStart = onTouchStart.bind(d), d.onTouchMove = onTouchMove.bind(d), d.onTouchEnd = onTouchEnd.bind(d), d.onDocumentTouchStart = onDocumentTouchStart.bind(d), l.cssMode && (d.onScroll = onScroll.bind(d)), d.onClick = onClick.bind(d), d.onLoad = onLoad.bind(d), events(d, "on");
}
function detachEvents() {
  events(this, "off");
}
var events$1 = {
  attachEvents,
  detachEvents
};
const isGridEnabled = (d, l) => d.grid && l.grid && l.grid.rows > 1;
function setBreakpoint() {
  const d = this, {
    realIndex: l,
    initialized: s,
    params: e,
    el: f
  } = d, i = e.breakpoints;
  if (!i || i && Object.keys(i).length === 0)
    return;
  const a = d.getBreakpoint(i, d.params.breakpointsBase, d.el);
  if (!a || d.currentBreakpoint === a)
    return;
  const r = (a in i ? i[a] : void 0) || d.originalParams, o = isGridEnabled(d, e), n = isGridEnabled(d, r), u = e.enabled;
  o && !n ? (f.classList.remove(`${e.containerModifierClass}grid`, `${e.containerModifierClass}grid-column`), d.emitContainerClasses()) : !o && n && (f.classList.add(`${e.containerModifierClass}grid`), (r.grid.fill && r.grid.fill === "column" || !r.grid.fill && e.grid.fill === "column") && f.classList.add(`${e.containerModifierClass}grid-column`), d.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach((w) => {
    if (typeof r[w] > "u")
      return;
    const M = e[w] && e[w].enabled, G = r[w] && r[w].enabled;
    M && !G && d[w].disable(), !M && G && d[w].enable();
  });
  const p = r.direction && r.direction !== e.direction, g = e.loop && (r.slidesPerView !== e.slidesPerView || p), v = e.loop;
  p && s && d.changeDirection(), extend$1(d.params, r);
  const x = d.params.enabled, b = d.params.loop;
  Object.assign(d, {
    allowTouchMove: d.params.allowTouchMove,
    allowSlideNext: d.params.allowSlideNext,
    allowSlidePrev: d.params.allowSlidePrev
  }), u && !x ? d.disable() : !u && x && d.enable(), d.currentBreakpoint = a, d.emit("_beforeBreakpoint", r), s && (g ? (d.loopDestroy(), d.loopCreate(l), d.updateSlides()) : !v && b ? (d.loopCreate(l), d.updateSlides()) : v && !b && d.loopDestroy()), d.emit("breakpoint", r);
}
function getBreakpoint(d, l, s) {
  if (l === void 0 && (l = "window"), !d || l === "container" && !s)
    return;
  let e = !1;
  const f = getWindow(), i = l === "window" ? f.innerHeight : s.clientHeight, a = Object.keys(d).map((t) => {
    if (typeof t == "string" && t.indexOf("@") === 0) {
      const r = parseFloat(t.substr(1));
      return {
        value: i * r,
        point: t
      };
    }
    return {
      value: t,
      point: t
    };
  });
  a.sort((t, r) => parseInt(t.value, 10) - parseInt(r.value, 10));
  for (let t = 0; t < a.length; t += 1) {
    const {
      point: r,
      value: o
    } = a[t];
    l === "window" ? f.matchMedia(`(min-width: ${o}px)`).matches && (e = r) : o <= s.clientWidth && (e = r);
  }
  return e || "max";
}
var breakpoints = {
  setBreakpoint,
  getBreakpoint
};
function prepareClasses(d, l) {
  const s = [];
  return d.forEach((e) => {
    typeof e == "object" ? Object.keys(e).forEach((f) => {
      e[f] && s.push(l + f);
    }) : typeof e == "string" && s.push(l + e);
  }), s;
}
function addClasses() {
  const d = this, {
    classNames: l,
    params: s,
    rtl: e,
    el: f,
    device: i
  } = d, a = prepareClasses(["initialized", s.direction, {
    "free-mode": d.params.freeMode && s.freeMode.enabled
  }, {
    autoheight: s.autoHeight
  }, {
    rtl: e
  }, {
    grid: s.grid && s.grid.rows > 1
  }, {
    "grid-column": s.grid && s.grid.rows > 1 && s.grid.fill === "column"
  }, {
    android: i.android
  }, {
    ios: i.ios
  }, {
    "css-mode": s.cssMode
  }, {
    centered: s.cssMode && s.centeredSlides
  }, {
    "watch-progress": s.watchSlidesProgress
  }], s.containerModifierClass);
  l.push(...a), f.classList.add(...l), d.emitContainerClasses();
}
function removeClasses() {
  const d = this, {
    el: l,
    classNames: s
  } = d;
  l.classList.remove(...s), d.emitContainerClasses();
}
var classes = {
  addClasses,
  removeClasses
};
function checkOverflow() {
  const d = this, {
    isLocked: l,
    params: s
  } = d, {
    slidesOffsetBefore: e
  } = s;
  if (e) {
    const f = d.slides.length - 1, i = d.slidesGrid[f] + d.slidesSizesGrid[f] + e * 2;
    d.isLocked = d.size > i;
  } else
    d.isLocked = d.snapGrid.length === 1;
  s.allowSlideNext === !0 && (d.allowSlideNext = !d.isLocked), s.allowSlidePrev === !0 && (d.allowSlidePrev = !d.isLocked), l && l !== d.isLocked && (d.isEnd = !1), l !== d.isLocked && d.emit(d.isLocked ? "lock" : "unlock");
}
var checkOverflow$1 = {
  checkOverflow
}, defaults = {
  init: !0,
  direction: "horizontal",
  oneWayMovement: !1,
  touchEventsTarget: "wrapper",
  initialSlide: 0,
  speed: 300,
  cssMode: !1,
  updateOnWindowResize: !0,
  resizeObserver: !0,
  nested: !1,
  createElements: !1,
  eventsPrefix: "swiper",
  enabled: !0,
  focusableElements: "input, select, option, textarea, button, video, label",
  // Overrides
  width: null,
  height: null,
  //
  preventInteractionOnTransition: !1,
  // ssr
  userAgent: null,
  url: null,
  // To support iOS's swipe-to-go-back gesture (when being used in-app).
  edgeSwipeDetection: !1,
  edgeSwipeThreshold: 20,
  // Autoheight
  autoHeight: !1,
  // Set wrapper width
  setWrapperSize: !1,
  // Virtual Translate
  virtualTranslate: !1,
  // Effects
  effect: "slide",
  // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
  // Breakpoints
  breakpoints: void 0,
  breakpointsBase: "window",
  // Slides grid
  spaceBetween: 0,
  slidesPerView: 1,
  slidesPerGroup: 1,
  slidesPerGroupSkip: 0,
  slidesPerGroupAuto: !1,
  centeredSlides: !1,
  centeredSlidesBounds: !1,
  slidesOffsetBefore: 0,
  // in px
  slidesOffsetAfter: 0,
  // in px
  normalizeSlideIndex: !0,
  centerInsufficientSlides: !1,
  // Disable swiper and hide navigation when container not overflow
  watchOverflow: !0,
  // Round length
  roundLengths: !1,
  // Touches
  touchRatio: 1,
  touchAngle: 45,
  simulateTouch: !0,
  shortSwipes: !0,
  longSwipes: !0,
  longSwipesRatio: 0.5,
  longSwipesMs: 300,
  followFinger: !0,
  allowTouchMove: !0,
  threshold: 5,
  touchMoveStopPropagation: !1,
  touchStartPreventDefault: !0,
  touchStartForcePreventDefault: !1,
  touchReleaseOnEdges: !1,
  // Unique Navigation Elements
  uniqueNavElements: !0,
  // Resistance
  resistance: !0,
  resistanceRatio: 0.85,
  // Progress
  watchSlidesProgress: !1,
  // Cursor
  grabCursor: !1,
  // Clicks
  preventClicks: !0,
  preventClicksPropagation: !0,
  slideToClickedSlide: !1,
  // loop
  loop: !1,
  loopAddBlankSlides: !0,
  loopAdditionalSlides: 0,
  loopPreventsSliding: !0,
  // rewind
  rewind: !1,
  // Swiping/no swiping
  allowSlidePrev: !0,
  allowSlideNext: !0,
  swipeHandler: null,
  // '.swipe-handler',
  noSwiping: !0,
  noSwipingClass: "swiper-no-swiping",
  noSwipingSelector: null,
  // Passive Listeners
  passiveListeners: !0,
  maxBackfaceHiddenSlides: 10,
  // NS
  containerModifierClass: "swiper-",
  // NEW
  slideClass: "swiper-slide",
  slideBlankClass: "swiper-slide-blank",
  slideActiveClass: "swiper-slide-active",
  slideVisibleClass: "swiper-slide-visible",
  slideFullyVisibleClass: "swiper-slide-fully-visible",
  slideNextClass: "swiper-slide-next",
  slidePrevClass: "swiper-slide-prev",
  wrapperClass: "swiper-wrapper",
  lazyPreloaderClass: "swiper-lazy-preloader",
  lazyPreloadPrevNext: 0,
  // Callbacks
  runCallbacksOnInit: !0,
  // Internals
  _emitClasses: !1
};
function moduleExtendParams(d, l) {
  return function(e) {
    e === void 0 && (e = {});
    const f = Object.keys(e)[0], i = e[f];
    if (typeof i != "object" || i === null) {
      extend$1(l, e);
      return;
    }
    if (d[f] === !0 && (d[f] = {
      enabled: !0
    }), f === "navigation" && d[f] && d[f].enabled && !d[f].prevEl && !d[f].nextEl && (d[f].auto = !0), ["pagination", "scrollbar"].indexOf(f) >= 0 && d[f] && d[f].enabled && !d[f].el && (d[f].auto = !0), !(f in d && "enabled" in i)) {
      extend$1(l, e);
      return;
    }
    typeof d[f] == "object" && !("enabled" in d[f]) && (d[f].enabled = !0), d[f] || (d[f] = {
      enabled: !1
    }), extend$1(l, e);
  };
}
const prototypes = {
  eventsEmitter,
  update,
  translate,
  transition,
  slide,
  loop,
  grabCursor,
  events: events$1,
  breakpoints,
  checkOverflow: checkOverflow$1,
  classes
}, extendedDefaults = {};
let Swiper$1 = class ir {
  constructor() {
    let l, s;
    for (var e = arguments.length, f = new Array(e), i = 0; i < e; i++)
      f[i] = arguments[i];
    f.length === 1 && f[0].constructor && Object.prototype.toString.call(f[0]).slice(8, -1) === "Object" ? s = f[0] : [l, s] = f, s || (s = {}), s = extend$1({}, s), l && !s.el && (s.el = l);
    const a = getDocument();
    if (s.el && typeof s.el == "string" && a.querySelectorAll(s.el).length > 1) {
      const n = [];
      return a.querySelectorAll(s.el).forEach((u) => {
        const p = extend$1({}, s, {
          el: u
        });
        n.push(new ir(p));
      }), n;
    }
    const t = this;
    t.__swiper__ = !0, t.support = getSupport(), t.device = getDevice({
      userAgent: s.userAgent
    }), t.browser = getBrowser(), t.eventsListeners = {}, t.eventsAnyListeners = [], t.modules = [...t.__modules__], s.modules && Array.isArray(s.modules) && t.modules.push(...s.modules);
    const r = {};
    t.modules.forEach((n) => {
      n({
        params: s,
        swiper: t,
        extendParams: moduleExtendParams(s, r),
        on: t.on.bind(t),
        once: t.once.bind(t),
        off: t.off.bind(t),
        emit: t.emit.bind(t)
      });
    });
    const o = extend$1({}, defaults, r);
    return t.params = extend$1({}, o, extendedDefaults, s), t.originalParams = extend$1({}, t.params), t.passedParams = extend$1({}, s), t.params && t.params.on && Object.keys(t.params.on).forEach((n) => {
      t.on(n, t.params.on[n]);
    }), t.params && t.params.onAny && t.onAny(t.params.onAny), Object.assign(t, {
      enabled: t.params.enabled,
      el: l,
      // Classes
      classNames: [],
      // Slides
      slides: [],
      slidesGrid: [],
      snapGrid: [],
      slidesSizesGrid: [],
      // isDirection
      isHorizontal() {
        return t.params.direction === "horizontal";
      },
      isVertical() {
        return t.params.direction === "vertical";
      },
      // Indexes
      activeIndex: 0,
      realIndex: 0,
      //
      isBeginning: !0,
      isEnd: !1,
      // Props
      translate: 0,
      previousTranslate: 0,
      progress: 0,
      velocity: 0,
      animating: !1,
      cssOverflowAdjustment() {
        return Math.trunc(this.translate / 2 ** 23) * 2 ** 23;
      },
      // Locks
      allowSlideNext: t.params.allowSlideNext,
      allowSlidePrev: t.params.allowSlidePrev,
      // Touch Events
      touchEventsData: {
        isTouched: void 0,
        isMoved: void 0,
        allowTouchCallbacks: void 0,
        touchStartTime: void 0,
        isScrolling: void 0,
        currentTranslate: void 0,
        startTranslate: void 0,
        allowThresholdMove: void 0,
        // Form elements to match
        focusableElements: t.params.focusableElements,
        // Last click time
        lastClickTime: 0,
        clickTimeout: void 0,
        // Velocities
        velocities: [],
        allowMomentumBounce: void 0,
        startMoving: void 0,
        pointerId: null,
        touchId: null
      },
      // Clicks
      allowClick: !0,
      // Touches
      allowTouchMove: t.params.allowTouchMove,
      touches: {
        startX: 0,
        startY: 0,
        currentX: 0,
        currentY: 0,
        diff: 0
      },
      // Images
      imagesToLoad: [],
      imagesLoaded: 0
    }), t.emit("_swiper"), t.params.init && t.init(), t;
  }
  getDirectionLabel(l) {
    return this.isHorizontal() ? l : {
      width: "height",
      "margin-top": "margin-left",
      "margin-bottom ": "margin-right",
      "margin-left": "margin-top",
      "margin-right": "margin-bottom",
      "padding-left": "padding-top",
      "padding-right": "padding-bottom",
      marginRight: "marginBottom"
    }[l];
  }
  getSlideIndex(l) {
    const {
      slidesEl: s,
      params: e
    } = this, f = elementChildren(s, `.${e.slideClass}, swiper-slide`), i = elementIndex(f[0]);
    return elementIndex(l) - i;
  }
  getSlideIndexByData(l) {
    return this.getSlideIndex(this.slides.filter((s) => s.getAttribute("data-swiper-slide-index") * 1 === l)[0]);
  }
  recalcSlides() {
    const l = this, {
      slidesEl: s,
      params: e
    } = l;
    l.slides = elementChildren(s, `.${e.slideClass}, swiper-slide`);
  }
  enable() {
    const l = this;
    l.enabled || (l.enabled = !0, l.params.grabCursor && l.setGrabCursor(), l.emit("enable"));
  }
  disable() {
    const l = this;
    l.enabled && (l.enabled = !1, l.params.grabCursor && l.unsetGrabCursor(), l.emit("disable"));
  }
  setProgress(l, s) {
    const e = this;
    l = Math.min(Math.max(l, 0), 1);
    const f = e.minTranslate(), a = (e.maxTranslate() - f) * l + f;
    e.translateTo(a, typeof s > "u" ? 0 : s), e.updateActiveIndex(), e.updateSlidesClasses();
  }
  emitContainerClasses() {
    const l = this;
    if (!l.params._emitClasses || !l.el)
      return;
    const s = l.el.className.split(" ").filter((e) => e.indexOf("swiper") === 0 || e.indexOf(l.params.containerModifierClass) === 0);
    l.emit("_containerClasses", s.join(" "));
  }
  getSlideClasses(l) {
    const s = this;
    return s.destroyed ? "" : l.className.split(" ").filter((e) => e.indexOf("swiper-slide") === 0 || e.indexOf(s.params.slideClass) === 0).join(" ");
  }
  emitSlidesClasses() {
    const l = this;
    if (!l.params._emitClasses || !l.el)
      return;
    const s = [];
    l.slides.forEach((e) => {
      const f = l.getSlideClasses(e);
      s.push({
        slideEl: e,
        classNames: f
      }), l.emit("_slideClass", e, f);
    }), l.emit("_slideClasses", s);
  }
  slidesPerViewDynamic(l, s) {
    l === void 0 && (l = "current"), s === void 0 && (s = !1);
    const e = this, {
      params: f,
      slides: i,
      slidesGrid: a,
      slidesSizesGrid: t,
      size: r,
      activeIndex: o
    } = e;
    let n = 1;
    if (typeof f.slidesPerView == "number")
      return f.slidesPerView;
    if (f.centeredSlides) {
      let u = i[o] ? i[o].swiperSlideSize : 0, p;
      for (let g = o + 1; g < i.length; g += 1)
        i[g] && !p && (u += i[g].swiperSlideSize, n += 1, u > r && (p = !0));
      for (let g = o - 1; g >= 0; g -= 1)
        i[g] && !p && (u += i[g].swiperSlideSize, n += 1, u > r && (p = !0));
    } else if (l === "current")
      for (let u = o + 1; u < i.length; u += 1)
        (s ? a[u] + t[u] - a[o] < r : a[u] - a[o] < r) && (n += 1);
    else
      for (let u = o - 1; u >= 0; u -= 1)
        a[o] - a[u] < r && (n += 1);
    return n;
  }
  update() {
    const l = this;
    if (!l || l.destroyed)
      return;
    const {
      snapGrid: s,
      params: e
    } = l;
    e.breakpoints && l.setBreakpoint(), [...l.el.querySelectorAll('[loading="lazy"]')].forEach((a) => {
      a.complete && processLazyPreloader(l, a);
    }), l.updateSize(), l.updateSlides(), l.updateProgress(), l.updateSlidesClasses();
    function f() {
      const a = l.rtlTranslate ? l.translate * -1 : l.translate, t = Math.min(Math.max(a, l.maxTranslate()), l.minTranslate());
      l.setTranslate(t), l.updateActiveIndex(), l.updateSlidesClasses();
    }
    let i;
    if (e.freeMode && e.freeMode.enabled && !e.cssMode)
      f(), e.autoHeight && l.updateAutoHeight();
    else {
      if ((e.slidesPerView === "auto" || e.slidesPerView > 1) && l.isEnd && !e.centeredSlides) {
        const a = l.virtual && e.virtual.enabled ? l.virtual.slides : l.slides;
        i = l.slideTo(a.length - 1, 0, !1, !0);
      } else
        i = l.slideTo(l.activeIndex, 0, !1, !0);
      i || f();
    }
    e.watchOverflow && s !== l.snapGrid && l.checkOverflow(), l.emit("update");
  }
  changeDirection(l, s) {
    s === void 0 && (s = !0);
    const e = this, f = e.params.direction;
    return l || (l = f === "horizontal" ? "vertical" : "horizontal"), l === f || l !== "horizontal" && l !== "vertical" || (e.el.classList.remove(`${e.params.containerModifierClass}${f}`), e.el.classList.add(`${e.params.containerModifierClass}${l}`), e.emitContainerClasses(), e.params.direction = l, e.slides.forEach((i) => {
      l === "vertical" ? i.style.width = "" : i.style.height = "";
    }), e.emit("changeDirection"), s && e.update()), e;
  }
  changeLanguageDirection(l) {
    const s = this;
    s.rtl && l === "rtl" || !s.rtl && l === "ltr" || (s.rtl = l === "rtl", s.rtlTranslate = s.params.direction === "horizontal" && s.rtl, s.rtl ? (s.el.classList.add(`${s.params.containerModifierClass}rtl`), s.el.dir = "rtl") : (s.el.classList.remove(`${s.params.containerModifierClass}rtl`), s.el.dir = "ltr"), s.update());
  }
  mount(l) {
    const s = this;
    if (s.mounted)
      return !0;
    let e = l || s.params.el;
    if (typeof e == "string" && (e = document.querySelector(e)), !e)
      return !1;
    e.swiper = s, e.parentNode && e.parentNode.host && e.parentNode.host.nodeName === "SWIPER-CONTAINER" && (s.isElement = !0);
    const f = () => `.${(s.params.wrapperClass || "").trim().split(" ").join(".")}`;
    let a = (() => e && e.shadowRoot && e.shadowRoot.querySelector ? e.shadowRoot.querySelector(f()) : elementChildren(e, f())[0])();
    return !a && s.params.createElements && (a = createElement("div", s.params.wrapperClass), e.append(a), elementChildren(e, `.${s.params.slideClass}`).forEach((t) => {
      a.append(t);
    })), Object.assign(s, {
      el: e,
      wrapperEl: a,
      slidesEl: s.isElement && !e.parentNode.host.slideSlots ? e.parentNode.host : a,
      hostEl: s.isElement ? e.parentNode.host : e,
      mounted: !0,
      // RTL
      rtl: e.dir.toLowerCase() === "rtl" || elementStyle(e, "direction") === "rtl",
      rtlTranslate: s.params.direction === "horizontal" && (e.dir.toLowerCase() === "rtl" || elementStyle(e, "direction") === "rtl"),
      wrongRTL: elementStyle(a, "display") === "-webkit-box"
    }), !0;
  }
  init(l) {
    const s = this;
    if (s.initialized || s.mount(l) === !1)
      return s;
    s.emit("beforeInit"), s.params.breakpoints && s.setBreakpoint(), s.addClasses(), s.updateSize(), s.updateSlides(), s.params.watchOverflow && s.checkOverflow(), s.params.grabCursor && s.enabled && s.setGrabCursor(), s.params.loop && s.virtual && s.params.virtual.enabled ? s.slideTo(s.params.initialSlide + s.virtual.slidesBefore, 0, s.params.runCallbacksOnInit, !1, !0) : s.slideTo(s.params.initialSlide, 0, s.params.runCallbacksOnInit, !1, !0), s.params.loop && s.loopCreate(), s.attachEvents();
    const f = [...s.el.querySelectorAll('[loading="lazy"]')];
    return s.isElement && f.push(...s.hostEl.querySelectorAll('[loading="lazy"]')), f.forEach((i) => {
      i.complete ? processLazyPreloader(s, i) : i.addEventListener("load", (a) => {
        processLazyPreloader(s, a.target);
      });
    }), preload(s), s.initialized = !0, preload(s), s.emit("init"), s.emit("afterInit"), s;
  }
  destroy(l, s) {
    l === void 0 && (l = !0), s === void 0 && (s = !0);
    const e = this, {
      params: f,
      el: i,
      wrapperEl: a,
      slides: t
    } = e;
    return typeof e.params > "u" || e.destroyed || (e.emit("beforeDestroy"), e.initialized = !1, e.detachEvents(), f.loop && e.loopDestroy(), s && (e.removeClasses(), i.removeAttribute("style"), a.removeAttribute("style"), t && t.length && t.forEach((r) => {
      r.classList.remove(f.slideVisibleClass, f.slideFullyVisibleClass, f.slideActiveClass, f.slideNextClass, f.slidePrevClass), r.removeAttribute("style"), r.removeAttribute("data-swiper-slide-index");
    })), e.emit("destroy"), Object.keys(e.eventsListeners).forEach((r) => {
      e.off(r);
    }), l !== !1 && (e.el.swiper = null, deleteProps(e)), e.destroyed = !0), null;
  }
  static extendDefaults(l) {
    extend$1(extendedDefaults, l);
  }
  static get extendedDefaults() {
    return extendedDefaults;
  }
  static get defaults() {
    return defaults;
  }
  static installModule(l) {
    ir.prototype.__modules__ || (ir.prototype.__modules__ = []);
    const s = ir.prototype.__modules__;
    typeof l == "function" && s.indexOf(l) < 0 && s.push(l);
  }
  static use(l) {
    return Array.isArray(l) ? (l.forEach((s) => ir.installModule(s)), ir) : (ir.installModule(l), ir);
  }
};
Object.keys(prototypes).forEach((d) => {
  Object.keys(prototypes[d]).forEach((l) => {
    Swiper$1.prototype[l] = prototypes[d][l];
  });
});
Swiper$1.use([Resize, Observer]);
const paramsList = [
  "eventsPrefix",
  "injectStyles",
  "injectStylesUrls",
  "modules",
  "init",
  "_direction",
  "oneWayMovement",
  "touchEventsTarget",
  "initialSlide",
  "_speed",
  "cssMode",
  "updateOnWindowResize",
  "resizeObserver",
  "nested",
  "focusableElements",
  "_enabled",
  "_width",
  "_height",
  "preventInteractionOnTransition",
  "userAgent",
  "url",
  "_edgeSwipeDetection",
  "_edgeSwipeThreshold",
  "_freeMode",
  "_autoHeight",
  "setWrapperSize",
  "virtualTranslate",
  "_effect",
  "breakpoints",
  "breakpointsBase",
  "_spaceBetween",
  "_slidesPerView",
  "maxBackfaceHiddenSlides",
  "_grid",
  "_slidesPerGroup",
  "_slidesPerGroupSkip",
  "_slidesPerGroupAuto",
  "_centeredSlides",
  "_centeredSlidesBounds",
  "_slidesOffsetBefore",
  "_slidesOffsetAfter",
  "normalizeSlideIndex",
  "_centerInsufficientSlides",
  "_watchOverflow",
  "roundLengths",
  "touchRatio",
  "touchAngle",
  "simulateTouch",
  "_shortSwipes",
  "_longSwipes",
  "longSwipesRatio",
  "longSwipesMs",
  "_followFinger",
  "allowTouchMove",
  "_threshold",
  "touchMoveStopPropagation",
  "touchStartPreventDefault",
  "touchStartForcePreventDefault",
  "touchReleaseOnEdges",
  "uniqueNavElements",
  "_resistance",
  "_resistanceRatio",
  "_watchSlidesProgress",
  "_grabCursor",
  "preventClicks",
  "preventClicksPropagation",
  "_slideToClickedSlide",
  "_loop",
  "loopAdditionalSlides",
  "loopAddBlankSlides",
  "loopPreventsSliding",
  "_rewind",
  "_allowSlidePrev",
  "_allowSlideNext",
  "_swipeHandler",
  "_noSwiping",
  "noSwipingClass",
  "noSwipingSelector",
  "passiveListeners",
  "containerModifierClass",
  "slideClass",
  "slideActiveClass",
  "slideVisibleClass",
  "slideFullyVisibleClass",
  "slideNextClass",
  "slidePrevClass",
  "slideBlankClass",
  "wrapperClass",
  "lazyPreloaderClass",
  "lazyPreloadPrevNext",
  "runCallbacksOnInit",
  "observer",
  "observeParents",
  "observeSlideChildren",
  // modules
  "a11y",
  "_autoplay",
  "_controller",
  "coverflowEffect",
  "cubeEffect",
  "fadeEffect",
  "flipEffect",
  "creativeEffect",
  "cardsEffect",
  "hashNavigation",
  "history",
  "keyboard",
  "mousewheel",
  "_navigation",
  "_pagination",
  "parallax",
  "_scrollbar",
  "_thumbs",
  "virtual",
  "zoom",
  "control"
];
function isObject(d) {
  return typeof d == "object" && d !== null && d.constructor && Object.prototype.toString.call(d).slice(8, -1) === "Object" && !d.__swiper__;
}
function extend(d, l) {
  const s = ["__proto__", "constructor", "prototype"];
  Object.keys(l).filter((e) => s.indexOf(e) < 0).forEach((e) => {
    typeof d[e] > "u" ? d[e] = l[e] : isObject(l[e]) && isObject(d[e]) && Object.keys(l[e]).length > 0 ? l[e].__swiper__ ? d[e] = l[e] : extend(d[e], l[e]) : d[e] = l[e];
  });
}
function needsNavigation(d) {
  return d === void 0 && (d = {}), d.navigation && typeof d.navigation.nextEl > "u" && typeof d.navigation.prevEl > "u";
}
function needsPagination(d) {
  return d === void 0 && (d = {}), d.pagination && typeof d.pagination.el > "u";
}
function needsScrollbar(d) {
  return d === void 0 && (d = {}), d.scrollbar && typeof d.scrollbar.el > "u";
}
function uniqueClasses(d) {
  d === void 0 && (d = "");
  const l = d.split(" ").map((e) => e.trim()).filter((e) => !!e), s = [];
  return l.forEach((e) => {
    s.indexOf(e) < 0 && s.push(e);
  }), s.join(" ");
}
function wrapperClass(d) {
  return d === void 0 && (d = ""), d ? d.includes("swiper-wrapper") ? d : `swiper-wrapper ${d}` : "swiper-wrapper";
}
function updateSwiper(d) {
  let {
    swiper: l,
    slides: s,
    passedParams: e,
    changedParams: f,
    nextEl: i,
    prevEl: a,
    scrollbarEl: t,
    paginationEl: r
  } = d;
  const o = f.filter((R) => R !== "children" && R !== "direction" && R !== "wrapperClass"), {
    params: n,
    pagination: u,
    navigation: p,
    scrollbar: g,
    virtual: v,
    thumbs: x
  } = l;
  let b, w, M, G, F, V, q, I;
  f.includes("thumbs") && e.thumbs && e.thumbs.swiper && n.thumbs && !n.thumbs.swiper && (b = !0), f.includes("controller") && e.controller && e.controller.control && n.controller && !n.controller.control && (w = !0), f.includes("pagination") && e.pagination && (e.pagination.el || r) && (n.pagination || n.pagination === !1) && u && !u.el && (M = !0), f.includes("scrollbar") && e.scrollbar && (e.scrollbar.el || t) && (n.scrollbar || n.scrollbar === !1) && g && !g.el && (G = !0), f.includes("navigation") && e.navigation && (e.navigation.prevEl || a) && (e.navigation.nextEl || i) && (n.navigation || n.navigation === !1) && p && !p.prevEl && !p.nextEl && (F = !0);
  const _ = (R) => {
    l[R] && (l[R].destroy(), R === "navigation" ? (l.isElement && (l[R].prevEl.remove(), l[R].nextEl.remove()), n[R].prevEl = void 0, n[R].nextEl = void 0, l[R].prevEl = void 0, l[R].nextEl = void 0) : (l.isElement && l[R].el.remove(), n[R].el = void 0, l[R].el = void 0));
  };
  f.includes("loop") && l.isElement && (n.loop && !e.loop ? V = !0 : !n.loop && e.loop ? q = !0 : I = !0), o.forEach((R) => {
    if (isObject(n[R]) && isObject(e[R]))
      Object.assign(n[R], e[R]), (R === "navigation" || R === "pagination" || R === "scrollbar") && "enabled" in e[R] && !e[R].enabled && _(R);
    else {
      const W = e[R];
      (W === !0 || W === !1) && (R === "navigation" || R === "pagination" || R === "scrollbar") ? W === !1 && _(R) : n[R] = e[R];
    }
  }), o.includes("controller") && !w && l.controller && l.controller.control && n.controller && n.controller.control && (l.controller.control = n.controller.control), f.includes("children") && s && v && n.virtual.enabled ? (v.slides = s, v.update(!0)) : f.includes("virtual") && v && n.virtual.enabled && (s && (v.slides = s), v.update(!0)), f.includes("children") && s && n.loop && (I = !0), b && x.init() && x.update(!0), w && (l.controller.control = n.controller.control), M && (l.isElement && (!r || typeof r == "string") && (r = document.createElement("div"), r.classList.add("swiper-pagination"), r.part.add("pagination"), l.el.appendChild(r)), r && (n.pagination.el = r), u.init(), u.render(), u.update()), G && (l.isElement && (!t || typeof t == "string") && (t = document.createElement("div"), t.classList.add("swiper-scrollbar"), t.part.add("scrollbar"), l.el.appendChild(t)), t && (n.scrollbar.el = t), g.init(), g.updateSize(), g.setTranslate()), F && (l.isElement && ((!i || typeof i == "string") && (i = document.createElement("div"), i.classList.add("swiper-button-next"), i.innerHTML = l.hostEl.constructor.nextButtonSvg, i.part.add("button-next"), l.el.appendChild(i)), (!a || typeof a == "string") && (a = document.createElement("div"), a.classList.add("swiper-button-prev"), a.innerHTML = l.hostEl.constructor.prevButtonSvg, a.part.add("button-prev"), l.el.appendChild(a))), i && (n.navigation.nextEl = i), a && (n.navigation.prevEl = a), p.init(), p.update()), f.includes("allowSlideNext") && (l.allowSlideNext = e.allowSlideNext), f.includes("allowSlidePrev") && (l.allowSlidePrev = e.allowSlidePrev), f.includes("direction") && l.changeDirection(e.direction, !1), (V || I) && l.loopDestroy(), (q || I) && l.loopCreate(), l.update();
}
function getParams(d, l) {
  d === void 0 && (d = {}), l === void 0 && (l = !0);
  const s = {
    on: {}
  }, e = {}, f = {};
  extend(s, defaults), s._emitClasses = !0, s.init = !1;
  const i = {}, a = paramsList.map((r) => r.replace(/_/, "")), t = Object.assign({}, d);
  return Object.keys(t).forEach((r) => {
    typeof d[r] > "u" || (a.indexOf(r) >= 0 ? isObject(d[r]) ? (s[r] = {}, f[r] = {}, extend(s[r], d[r]), extend(f[r], d[r])) : (s[r] = d[r], f[r] = d[r]) : r.search(/on[A-Z]/) === 0 && typeof d[r] == "function" ? l ? e[`${r[2].toLowerCase()}${r.substr(3)}`] = d[r] : s.on[`${r[2].toLowerCase()}${r.substr(3)}`] = d[r] : i[r] = d[r]);
  }), ["navigation", "pagination", "scrollbar"].forEach((r) => {
    s[r] === !0 && (s[r] = {}), s[r] === !1 && delete s[r];
  }), {
    params: s,
    passedParams: f,
    rest: i,
    events: e
  };
}
function mountSwiper(d, l) {
  let {
    el: s,
    nextEl: e,
    prevEl: f,
    paginationEl: i,
    scrollbarEl: a,
    swiper: t
  } = d;
  needsNavigation(l) && e && f && (t.params.navigation.nextEl = e, t.originalParams.navigation.nextEl = e, t.params.navigation.prevEl = f, t.originalParams.navigation.prevEl = f), needsPagination(l) && i && (t.params.pagination.el = i, t.originalParams.pagination.el = i), needsScrollbar(l) && a && (t.params.scrollbar.el = a, t.originalParams.scrollbar.el = a), t.init(s);
}
function getChangedParams(d, l, s, e, f) {
  const i = [];
  if (!l)
    return i;
  const a = (r) => {
    i.indexOf(r) < 0 && i.push(r);
  };
  if (s && e) {
    const r = e.map(f), o = s.map(f);
    r.join("") !== o.join("") && a("children"), e.length !== s.length && a("children");
  }
  return paramsList.filter((r) => r[0] === "_").map((r) => r.replace(/_/, "")).forEach((r) => {
    if (r in d && r in l)
      if (isObject(d[r]) && isObject(l[r])) {
        const o = Object.keys(d[r]), n = Object.keys(l[r]);
        o.length !== n.length ? a(r) : (o.forEach((u) => {
          d[r][u] !== l[r][u] && a(r);
        }), n.forEach((u) => {
          d[r][u] !== l[r][u] && a(r);
        }));
      } else
        d[r] !== l[r] && a(r);
  }), i;
}
const updateOnVirtualData = (d) => {
  !d || d.destroyed || !d.params.virtual || d.params.virtual && !d.params.virtual.enabled || (d.updateSlides(), d.updateProgress(), d.updateSlidesClasses(), d.parallax && d.params.parallax && d.params.parallax.enabled && d.parallax.setTranslate());
};
function _extends() {
  return _extends = Object.assign ? Object.assign.bind() : function(d) {
    for (var l = 1; l < arguments.length; l++) {
      var s = arguments[l];
      for (var e in s)
        Object.prototype.hasOwnProperty.call(s, e) && (d[e] = s[e]);
    }
    return d;
  }, _extends.apply(this, arguments);
}
function isChildSwiperSlide(d) {
  return d.type && d.type.displayName && d.type.displayName.includes("SwiperSlide");
}
function processChildren(d) {
  const l = [];
  return React__default.Children.toArray(d).forEach((s) => {
    isChildSwiperSlide(s) ? l.push(s) : s.props && s.props.children && processChildren(s.props.children).forEach((e) => l.push(e));
  }), l;
}
function getChildren(d) {
  const l = [], s = {
    "container-start": [],
    "container-end": [],
    "wrapper-start": [],
    "wrapper-end": []
  };
  return React__default.Children.toArray(d).forEach((e) => {
    if (isChildSwiperSlide(e))
      l.push(e);
    else if (e.props && e.props.slot && s[e.props.slot])
      s[e.props.slot].push(e);
    else if (e.props && e.props.children) {
      const f = processChildren(e.props.children);
      f.length > 0 ? f.forEach((i) => l.push(i)) : s["container-end"].push(e);
    } else
      s["container-end"].push(e);
  }), {
    slides: l,
    slots: s
  };
}
function renderVirtual(d, l, s) {
  if (!s)
    return null;
  const e = (n) => {
    let u = n;
    return n < 0 ? u = l.length + n : u >= l.length && (u = u - l.length), u;
  }, f = d.isHorizontal() ? {
    [d.rtlTranslate ? "right" : "left"]: `${s.offset}px`
  } : {
    top: `${s.offset}px`
  }, {
    from: i,
    to: a
  } = s, t = d.params.loop ? -l.length : 0, r = d.params.loop ? l.length * 2 : l.length, o = [];
  for (let n = t; n < r; n += 1)
    n >= i && n <= a && o.push(l[e(n)]);
  return o.map((n, u) => /* @__PURE__ */ React__default.cloneElement(n, {
    swiper: d,
    style: f,
    key: `slide-${u}`
  }));
}
function useIsomorphicLayoutEffect(d, l) {
  return typeof window > "u" ? useEffect(d, l) : useLayoutEffect(d, l);
}
const SwiperSlideContext = /* @__PURE__ */ createContext(null), SwiperContext = /* @__PURE__ */ createContext(null), Swiper = /* @__PURE__ */ forwardRef(function(d, l) {
  let {
    className: s,
    tag: e = "div",
    wrapperTag: f = "div",
    children: i,
    onSwiper: a,
    ...t
  } = d === void 0 ? {} : d, r = !1;
  const [o, n] = useState("swiper"), [u, p] = useState(null), [g, v] = useState(!1), x = useRef(!1), b = useRef(null), w = useRef(null), M = useRef(null), G = useRef(null), F = useRef(null), V = useRef(null), q = useRef(null), I = useRef(null), {
    params: _,
    passedParams: R,
    rest: W,
    events: O
  } = getParams(t), {
    slides: j,
    slots: U
  } = getChildren(i), C = () => {
    v(!g);
  };
  Object.assign(_.on, {
    _containerClasses(L, re) {
      n(re);
    }
  });
  const ae = () => {
    Object.assign(_.on, O), r = !0;
    const L = {
      ..._
    };
    if (delete L.wrapperClass, w.current = new Swiper$1(L), w.current.virtual && w.current.params.virtual.enabled) {
      w.current.virtual.slides = j;
      const re = {
        cache: !1,
        slides: j,
        renderExternal: p,
        renderExternalUpdate: !1
      };
      extend(w.current.params.virtual, re), extend(w.current.originalParams.virtual, re);
    }
  };
  b.current || ae(), w.current && w.current.on("_beforeBreakpoint", C);
  const J = () => {
    r || !O || !w.current || Object.keys(O).forEach((L) => {
      w.current.on(L, O[L]);
    });
  }, te = () => {
    !O || !w.current || Object.keys(O).forEach((L) => {
      w.current.off(L, O[L]);
    });
  };
  useEffect(() => () => {
    w.current && w.current.off("_beforeBreakpoint", C);
  }), useEffect(() => {
    !x.current && w.current && (w.current.emitSlidesClasses(), x.current = !0);
  }), useIsomorphicLayoutEffect(() => {
    if (l && (l.current = b.current), !!b.current)
      return w.current.destroyed && ae(), mountSwiper({
        el: b.current,
        nextEl: F.current,
        prevEl: V.current,
        paginationEl: q.current,
        scrollbarEl: I.current,
        swiper: w.current
      }, _), a && a(w.current), () => {
        w.current && !w.current.destroyed && w.current.destroy(!0, !1);
      };
  }, []), useIsomorphicLayoutEffect(() => {
    J();
    const L = getChangedParams(R, M.current, j, G.current, (re) => re.key);
    return M.current = R, G.current = j, L.length && w.current && !w.current.destroyed && updateSwiper({
      swiper: w.current,
      slides: j,
      passedParams: R,
      changedParams: L,
      nextEl: F.current,
      prevEl: V.current,
      scrollbarEl: I.current,
      paginationEl: q.current
    }), () => {
      te();
    };
  }), useIsomorphicLayoutEffect(() => {
    updateOnVirtualData(w.current);
  }, [u]);
  function $() {
    return _.virtual ? renderVirtual(w.current, j, u) : j.map((L, re) => /* @__PURE__ */ React__default.cloneElement(L, {
      swiper: w.current,
      swiperSlideIndex: re
    }));
  }
  return /* @__PURE__ */ React__default.createElement(e, _extends({
    ref: b,
    className: uniqueClasses(`${o}${s ? ` ${s}` : ""}`)
  }, W), /* @__PURE__ */ React__default.createElement(SwiperContext.Provider, {
    value: w.current
  }, U["container-start"], /* @__PURE__ */ React__default.createElement(f, {
    className: wrapperClass(_.wrapperClass)
  }, U["wrapper-start"], $(), U["wrapper-end"]), needsNavigation(_) && /* @__PURE__ */ React__default.createElement(React__default.Fragment, null, /* @__PURE__ */ React__default.createElement("div", {
    ref: V,
    className: "swiper-button-prev"
  }), /* @__PURE__ */ React__default.createElement("div", {
    ref: F,
    className: "swiper-button-next"
  })), needsScrollbar(_) && /* @__PURE__ */ React__default.createElement("div", {
    ref: I,
    className: "swiper-scrollbar"
  }), needsPagination(_) && /* @__PURE__ */ React__default.createElement("div", {
    ref: q,
    className: "swiper-pagination"
  }), U["container-end"]));
});
Swiper.displayName = "Swiper";
const SwiperSlide = /* @__PURE__ */ forwardRef(function(d, l) {
  let {
    tag: s = "div",
    children: e,
    className: f = "",
    swiper: i,
    zoom: a,
    lazy: t,
    virtualIndex: r,
    swiperSlideIndex: o,
    ...n
  } = d === void 0 ? {} : d;
  const u = useRef(null), [p, g] = useState("swiper-slide"), [v, x] = useState(!1);
  function b(F, V, q) {
    V === u.current && g(q);
  }
  useIsomorphicLayoutEffect(() => {
    if (typeof o < "u" && (u.current.swiperSlideIndex = o), l && (l.current = u.current), !(!u.current || !i)) {
      if (i.destroyed) {
        p !== "swiper-slide" && g("swiper-slide");
        return;
      }
      return i.on("_slideClass", b), () => {
        i && i.off("_slideClass", b);
      };
    }
  }), useIsomorphicLayoutEffect(() => {
    i && u.current && !i.destroyed && g(i.getSlideClasses(u.current));
  }, [i]);
  const w = {
    isActive: p.indexOf("swiper-slide-active") >= 0,
    isVisible: p.indexOf("swiper-slide-visible") >= 0,
    isPrev: p.indexOf("swiper-slide-prev") >= 0,
    isNext: p.indexOf("swiper-slide-next") >= 0
  }, M = () => typeof e == "function" ? e(w) : e, G = () => {
    x(!0);
  };
  return /* @__PURE__ */ React__default.createElement(s, _extends({
    ref: u,
    className: uniqueClasses(`${p}${f ? ` ${f}` : ""}`),
    "data-swiper-slide-index": r,
    onLoad: G
  }, n), a && /* @__PURE__ */ React__default.createElement(SwiperSlideContext.Provider, {
    value: w
  }, /* @__PURE__ */ React__default.createElement("div", {
    className: "swiper-zoom-container",
    "data-swiper-zoom": typeof a == "number" ? a : void 0
  }, M(), t && !v && /* @__PURE__ */ React__default.createElement("div", {
    className: "swiper-lazy-preloader"
  }))), !a && /* @__PURE__ */ React__default.createElement(SwiperSlideContext.Provider, {
    value: w
  }, M(), t && !v && /* @__PURE__ */ React__default.createElement("div", {
    className: "swiper-lazy-preloader"
  })));
});
SwiperSlide.displayName = "SwiperSlide";
const swiperScrollbar$1 = "_swiperScrollbar_ixjdu_1", swiperScrollbarDrag$1 = "_swiperScrollbarDrag_ixjdu_6", buttonWrapper = "_buttonWrapper_ixjdu_10", styles$2 = {
  swiperScrollbar: swiperScrollbar$1,
  swiperScrollbarDrag: swiperScrollbarDrag$1,
  buttonWrapper
}, faceButtonStyle$1 = "_faceButtonStyle_fgtfb_1", styles$1 = {
  faceButtonStyle: faceButtonStyle$1
}, MakerFaceButton = ({
  face: d,
  faceImage: l,
  onClick: s
}) => /* @__PURE__ */ jsxRuntimeExports.jsx("li", { onClick: s, children: /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: styles$1.faceButtonStyle, children: /* @__PURE__ */ jsxRuntimeExports.jsx("img", { src: l, alt: d }) }) }), MakerPartsFaceMenu = ({
  category: d,
  item: l
}) => {
  const { selectedParts: s, setSelectedParts: e } = useContext(SelectedPartsContext), { menuPartIcons: f, setMenuPartIcons: i } = useContext(MenuPartIconsContext), a = (t) => {
    e({
      ...s,
      selectedFace: {
        ...s.selectedFace,
        [d]: t
      }
    });
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: d !== null && l !== null && f[d].partList[l] && Object.keys(f[d].partList[l].faces).length > 1 ? /* @__PURE__ */ jsxRuntimeExports.jsx(
    Swiper,
    {
      style: { display: "flex" },
      slidesPerView: "auto",
      freeMode: !0,
      spaceBetween: 0,
      children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: Object.keys(f[d].partList[l].faces).map(
        (t) => /* @__PURE__ */ jsxRuntimeExports.jsxs(SwiperSlide, { style: { width: "150px" }, children: [
          " ",
          /* @__PURE__ */ jsxRuntimeExports.jsx(
            MakerFaceButton,
            {
              face: t,
              faceImage: f[d].partList[l].faces[t].imagePath,
              onClick: () => a(t)
            }
          )
        ] }, t)
      ) })
    }
  ) : null });
}, MakerPartsFaceMenu$1 = React__default.memo(MakerPartsFaceMenu), MakerPartsMenu = ({}) => {
  const { selectedParts: d, setSelectedParts: l } = useContext(SelectedPartsContext), { selectedCategory: s, setSelectedCategory: e } = useContext(
    SelectedCategoryContext
  ), f = useContext(PartsObjectContext), { menuPartIcons: i } = useContext(MenuPartIconsContext), a = (n) => {
    e(n === s ? null : n);
  }, t = useRef(null), [r, o] = useState(null);
  return useEffect(() => {
    s === null ? o(null) : d.category[s] ? o(d.category[s].partName) : o(null);
  }, [d, s]), useEffect(() => {
    t.current && t.current.swiper && t.current.swiper.update();
  }, [d]), /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      Swiper,
      {
        ref: t,
        className: styles$2.scrollBarSwiper,
        slidesPerView: "auto",
        freeMode: !0,
        spaceBetween: 0,
        onSwiper: (n) => n.update(),
        children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: Object.keys(d.category).map((n) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "70px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
          MakerPartsCategories$1,
          {
            category: n,
            isSelected: s === n,
            onClick: () => a(n),
            imageSrc: d.category[n].partName ? i[n].partList[d.category[n].partName].faces[d.selectedFace[n]] ? i[n].partList[d.category[n].partName].faces[d.selectedFace[n]].imagePath : i[n].partList[d.category[n].partName].faces.clear.imagePath : i[n].partList[Object.keys(i[n].partList)[0]].bodyType.includes(d.bodyType) || i[n].partList[Object.keys(i[n].partList)[0]].bodyType === null ? i[n].partList[Object.keys(i[n].partList)[0]].faces[d.selectedFace[n]] ? i[n].partList[Object.keys(i[n].partList)[0]].faces[d.selectedFace[n]].imagePath : i[n].partList[Object.keys(i[n].partList)[0]].faces.clear.imagePath : i[n].partList[Object.keys(i[n].partList).find(
              (u) => i[n].partList[u].bodyType.includes(d.bodyType)
            )] ? i[n].partList[Object.keys(i[n].partList).find(
              (u) => i[n].partList[u].bodyType.includes(d.bodyType)
            )].faces[d.selectedFace[n]] ? i[n].partList[Object.keys(i[n].partList).find(
              (u) => i[n].partList[u].bodyType.includes(d.bodyType)
            )].faces[d.selectedFace[n]].imagePath : i[n].partList[Object.keys(i[n].partList).find(
              (u) => i[n].partList[u].bodyType.includes(d.bodyType)
            )].faces.clear.imagePath : i[n].partList[Object.keys(i[n].partList)[0]].faces[d.selectedFace[n]] ? i[n].partList[Object.keys(i[n].partList)[0]].faces[d.selectedFace[n]].imagePath : i[n].partList[Object.keys(i[n].partList)[0]].faces.clear.imagePath
          }
        ) }, n)) })
      }
    ),
    Object.keys(d.category).map(
      (n) => s === n ? Object.keys(i[n].partList).map(
        (u) => n === "body" || i[n].partList[u].bodyType === null || i[n].partList[u].bodyType.includes(
          d.bodyType
        ) ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          MakerPartsButton$1,
          {
            item: u,
            buttonImage: i[n].partList[u].faces.clear.imagePath,
            onClick: () => MakerChangingPart(
              n,
              i[n].partList[u].bodyType,
              u,
              d,
              l,
              f
            )
          },
          u
        ) : null
      ) : null
    ),
    /* @__PURE__ */ jsxRuntimeExports.jsx(MakerPartsFaceMenu$1, { category: s, item: r })
  ] });
}, MakerPartsMenu$1 = React__default.memo(MakerPartsMenu), colorList = "_colorList_13cv7_1", colorListLoading = "_colorListLoading_13cv7_25", MakerColorsButton_module = {
  colorList,
  colorListLoading
}, MakerColorsButton = ({
  colorCode: d,
  colorName: l,
  onClick: s,
  isLoading: e
}) => /* @__PURE__ */ jsxRuntimeExports.jsx(
  "button",
  {
    className: e ? colorListLoading : colorList,
    style: { backgroundColor: d },
    onClick: s,
    children: /* @__PURE__ */ jsxRuntimeExports.jsx("p", { children: l })
  }
), scrollBarSwiper = "_scrollBarSwiper_1pydv_1", partsImg = "_partsImg_1pydv_5", partsImgSelected = "_partsImgSelected_1pydv_14", scrollEvent = "_scrollEvent_1pydv_18", settingButton = "_settingButton_1pydv_22", swiperScrollbar = "_swiperScrollbar_1pydv_36", swiperScrollbarDrag = "_swiperScrollbarDrag_1pydv_42", colorShowButton = "_colorShowButton_1pydv_58", gradient = "_gradient_1pydv_1", MakerColorsPalleteMenu_module = {
  scrollBarSwiper,
  partsImg,
  partsImgSelected,
  scrollEvent,
  settingButton,
  swiperScrollbar,
  swiperScrollbarDrag,
  colorShowButton,
  gradient
}, ColorsObjectContext = createContext(null), MakerChangingColorsObject = (d, l, s, e, f, i, a, t, r, o, n, u, p) => {
  if (i === null && a === null && t === null && r === null && o === null && n === null)
    return null;
  let g = s;
  if (s === "none") {
    const w = p[u].partList;
    g = e === "default" ? s === u ? u : Object.keys(w).length === 1 ? w[Object.keys(w)[0]].colorGroup : "none" : w[e].colorGroup;
  }
  const v = d.selectedColor[s];
  v.default === void 0 && (v.default = {
    ...d.selectedColor.none.default
  });
  const x = v.default;
  let b = {
    bodyType: d.bodyType,
    face: d.face,
    category: d.category,
    selectedColor: {
      ...d.selectedColor,
      [g]: f ? {
        default: {
          color: i || x.color,
          hueReverse: a === null ? x.hueReverse : a,
          saturationReverse: t === null ? x.saturationReverse : t,
          hueGraph: r === null ? x.hueGraph : r,
          saturationGraph: o === null ? x.saturationGraph : o,
          valueGraph: n === null ? x.valueGraph : n
        }
      } : {
        ...v,
        [e]: {
          color: i === null ? v[e] ? v[e].color : x.color : i,
          hueReverse: a === null ? v[e] ? v[e].hueReverse : x.hueReverse : a,
          saturationReverse: t === null ? v[e] ? v[e].saturationReverse : x.saturationReverse : t,
          hueGraph: r === null ? v[e] ? v[e].hueGraph : x.hueGraph : r,
          saturationGraph: o === null ? v[e] ? v[e].saturationGraph : x.saturationGraph : o,
          valueGraph: n === null ? v[e] ? v[e].valueGraph : x.valueGraph : n
        }
      }
    },
    selectedFace: d.selectedFace
  };
  return l(b), b;
}, ColorMenuPartIconsContext = createContext({}), PartObjectJimpContext = createContext(null), PartsPathContext = createContext(""), NullImageContext = createContext(null), MakerPartIconsTrim = async (d, l) => {
  let s, e, f, i;
  if (d.bitmap.width == l && d.bitmap.height == l)
    return d;
  d.scan(0, 0, d.bitmap.width, d.bitmap.height, (v, x, b) => {
    d.bitmap.data[b + 3] !== 0 && (s = Math.min(x, s || x), e = Math.min(v, e || v), f = Math.max(x, f || x), i = Math.max(v, i || v));
  });
  const a = i - e, t = f - s, r = Math.max(a, t) + 4, o = (e + i) / 2, n = (s + f) / 2, u = Math.max(0, o - r / 2), p = Math.max(0, n - r / 2), g = d.clone().crop(u, p, r, r);
  return g.resize(
    l,
    l,
    r >= l / 2 ? Jimp.RESIZE_BILINEAR : Jimp.RESIZE_NEAREST_NEIGHBOR
  ), await g;
}, MakerCombineMenuPartIcons = async (d) => {
  const l = {}, s = Object.entries(d).sort(
    (f, i) => f[1].partOrder - i[1].partOrder
  );
  for (const [f, { faces: i }] of s)
    for (const a in i) {
      const t = i[a].jimpData;
      l[a] ? l[a].jimpData.composite(t, 0, 0) : l[a] = {
        jimpData: t.clone()
      };
    }
  const e = {};
  for (const f in l) {
    const i = await MakerConvertBase64(
      await MakerPartIconsTrim(l[f].jimpData, 128)
    );
    e[f] = {
      imagePath: i
    };
  }
  return e;
}, MakerConvertPartsToMenuIcons = async (d) => {
  const l = MakerConvertPartsList(d), s = {};
  for (const e in l) {
    s[e] = {
      partList: {}
    };
    for (const f in l[e].partList) {
      const i = {
        bodyType: l[e].partList[f].bodyType,
        faces: await MakerCombineMenuPartIcons(
          l[e].partList[f].peaces
        )
        //
      };
      s[e].partList[f] = i;
    }
  }
  return s;
}, MakerConvertPartsList = (d) => {
  const l = {};
  for (const s in d) {
    const e = MakerConvertCategory(
      d[s].partList
    );
    l[s] = {
      partList: e
    };
  }
  return l;
}, MakerConvertCategory = (d) => {
  const l = {};
  for (const s in d) {
    const e = d[s];
    for (const f in e.items)
      l[f] ? l[f].bodyType = e.items[f].bodyType : l[f] = {
        bodyType: e.items[f].bodyType,
        peaces: {}
      }, l[f].peaces || (l[f].peaces = {}), l[f].peaces[s] = {
        partOrder: d[s].partOrder,
        faces: e.items[f].faces
      };
  }
  return l;
}, MakerPartsColoring = async (d, l, s, e, f) => {
  const i = [
    "#fefefe",
    "#e5e5e5",
    "#cbcbcb",
    "#b2b2b2",
    "#989898",
    "#7f7f7f",
    "#656565",
    "#4c4c4c",
    "#323232",
    "#191919"
  ], a = e.selectedColor[s] ? e.selectedColor[s][l] ? e.selectedColor[s][l] : e.selectedColor[s].default : e.selectedColor.none.default, t = f[a.color].hex, r = rgbToHsv(t);
  let o = [];
  for (let n = 0; n < 10; n++) {
    const u = a.hueReverse ? r[0] - (a.hueGraph.globalSlope * n + a.hueGraph.individualSlope[n]) : r[0] + (a.hueGraph.globalSlope * n + a.hueGraph.individualSlope[n]), p = a.saturationReverse ? r[1] + (a.saturationGraph.globalSlope * n + a.saturationGraph.individualSlope[n]) : r[1] - (a.saturationGraph.globalSlope * n + a.saturationGraph.individualSlope[n]), g = r[2] - a.valueGraph.globalSlope * n + a.valueGraph.individualSlope[n], v = u < 0 ? u < -360 ? u * (u / -360) + u : 360 + u : u > 360 ? u > 720 ? u * (u / 360) - u : u - 360 : u, x = p < 0 ? 0 : p > 255 ? 255 : p, b = g < 0 ? 0 : g > 255 ? 255 : g;
    o.push(hsvToRgb([v, x, b]));
  }
  return await MakerPartsColoringChange(d, i, o);
}, MakerPartsColoringChange = async (d, l, s) => {
  try {
    const e = l.map((f, i) => {
      const a = hexToRgb(f), t = hexToRgb(
        s[i]
      );
      return {
        old: a,
        new: t
      };
    });
    return d.scan(0, 0, d.bitmap.width, d.bitmap.height, (f, i, a) => {
      if (d.bitmap.data[a + 3] === 0)
        return;
      const r = d.bitmap.data[a + 0], o = d.bitmap.data[a + 1], n = d.bitmap.data[a + 2];
      for (const { old: u, new: p } of e)
        if (r === u.red && o === u.green && n === u.blue) {
          d.bitmap.data[a + 0] = p.red, d.bitmap.data[a + 1] = p.green, d.bitmap.data[a + 2] = p.blue;
          break;
        }
    }), d;
  } catch (e) {
    throw console.error("", e), e;
  }
}, hexToRgb = (d) => {
  const l = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(d);
  return l ? {
    red: parseInt(l[1], 16),
    green: parseInt(l[2], 16),
    blue: parseInt(l[3], 16)
  } : null;
}, rgbToHsv = (d) => {
  let l = parseInt(d.slice(1, 3), 16) / 255, s = parseInt(d.slice(3, 5), 16) / 255, e = parseInt(d.slice(5, 7), 16) / 255, f = Math.max(l, s, e), i = Math.min(l, s, e), a, t, r = f, o = f - i;
  if (t = f === 0 ? 0 : o / f, f === i)
    a = 0;
  else {
    switch (f) {
      case l:
        a = (s - e) / o + (s < e ? 6 : 0);
        break;
      case s:
        a = (e - l) / o + 2;
        break;
      case e:
        a = (l - s) / o + 4;
        break;
    }
    a /= 6;
  }
  return [Math.round(a * 359), Math.round(t * 255), Math.round(r * 255)];
};
function hsvToRgb(d) {
  let [l, s, e] = d;
  s /= 255, e /= 255;
  let f = 0, i = 0, a = 0, t = Math.floor(l / 60), r = l / 60 - t, o = e * (1 - s), n = e * (1 - s * r), u = e * (1 - s * (1 - r));
  switch (t % 6) {
    case 0:
      [f, i, a] = [e, u, o];
      break;
    case 1:
      [f, i, a] = [n, e, o];
      break;
    case 2:
      [f, i, a] = [o, e, u];
      break;
    case 3:
      [f, i, a] = [o, n, e];
      break;
    case 4:
      [f, i, a] = [u, o, e];
      break;
    case 5:
      [f, i, a] = [e, o, n];
      break;
  }
  let p = (g) => {
    let v = Math.round(g * 255).toString(16);
    return v.length === 1 ? "0" + v : v;
  };
  return "#" + p(f) + p(i) + p(a);
}
const MAX_PROMISE$1 = 20, MakerChangingColor = async (d, l, s, e, f, i, a, t, r, o, n, u, p) => {
  if (!d)
    return;
  let g = {
    ...a
  }, v = {
    ...n
  };
  if (e)
    for (const x in a) {
      const b = a[x].partList;
      for (const w in b)
        if (b[w].colorGroup === l) {
          const M = b[w].items;
          await asyncMap$1(Object.keys(M), async (F) => {
            g[x].partList[w].items[F].faces = await faceJimpWrite(
              F,
              i,
              x,
              w,
              l,
              d,
              r,
              o,
              p
            );
          });
          const G = MakerConvertCategory(
            g[x].partList
          );
          await asyncMap$1(Object.keys(G), async (F) => {
            const V = {
              bodyType: G[F].bodyType,
              faces: await MakerCombineMenuPartIcons(G[F].peaces)
            };
            v[x].partList[F] = V;
          });
        }
    }
  else {
    const x = g[f].partList[s].items;
    for (const w in x)
      await asyncMap$1(Object.keys(x), async (M) => {
        g[f].partList[s].items[M].faces = await faceJimpWrite(
          M,
          i,
          f,
          s,
          l,
          d,
          r,
          o,
          p
        );
      });
    const b = MakerConvertCategory(
      g[f].partList
    );
    await asyncMap$1(Object.keys(b), async (w) => {
      const M = {
        bodyType: b[w].bodyType,
        faces: await MakerCombineMenuPartIcons(b[w].peaces)
      };
      v[f].partList[w] = M;
    });
  }
  t(g), u(v);
}, faceJimpWrite = async (d, l, s, e, f, i, a, t, r) => {
  const o = {};
  return await asyncMap$1(
    Object.keys(
      l[s].partList[e].items[d].faces
    ),
    async (n) => {
      if (l[s].partList[e].items[d].faces[n].imagePath == "" || l[s].partList[e].items[d].faces[n].imagePath == null)
        o[n] = {
          jimpData: r
        };
      else {
        const u = await Jimp.read(
          t + l[s].partList[e].items[d].faces[n].imagePath
        ), p = await MakerPartsColoring(
          u,
          e,
          f,
          i,
          a
        );
        o[n] = {
          jimpData: p
        };
      }
    }
  ), o;
}, asyncMap$1 = async (d, l, s = MAX_PROMISE$1) => {
  const e = d.slice(), f = new Array(d.length), i = new Array(s).fill(Promise.resolve()), a = (t) => {
    if (e.length) {
      const r = e.shift();
      return l(r).then((o) => (f[t] = o, a(t)));
    }
  };
  return await Promise.all(i.map(a)), f;
}, swiperFaceImage = "_swiperFaceImage_1080o_1", faceShowButton = "_faceShowButton_1080o_7", faceButtonStyle = "_faceButtonStyle_1080o_17", faceMenuStyle = "_faceMenuStyle_1080o_30", styles = {
  swiperFaceImage,
  faceShowButton,
  faceButtonStyle,
  faceMenuStyle
}, FaceListContext = createContext([]), FacePathContext = createContext(""), MakerFaceMenu = () => {
  const d = useContext(FaceListContext), l = useContext(FacePathContext), { selectedParts: s, setSelectedParts: e } = useContext(SelectedPartsContext), [f, i] = useState(!1);
  useState({
    left: "4px",
    top: "0px"
  });
  const a = (t) => {
    let r = {
      ...s,
      selectedFace: {
        ...s.selectedFace
      }
    };
    for (const o in s.selectedFace)
      r.selectedFace[o] = t;
    e(r);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(Swiper, { slidesPerView: "auto", freeMode: !0, spaceBetween: 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { style: { position: "relative" }, children: /* @__PURE__ */ jsxRuntimeExports.jsxs(SwiperSlide, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: styles.faceButtonStyle,
        onClick: () => i(!f),
        children: f ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "" }) : /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: "" })
      }
    ),
    f && /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { className: styles.faceMenuStyle, children: d.map((t, r) => /* @__PURE__ */ jsxRuntimeExports.jsx(
      MakerFaceButton,
      {
        face: t.face,
        faceImage: l + t.image,
        onClick: () => a(t.face)
      },
      t.face
    )) })
  ] }) }) });
}, MakerFaceMenu$1 = React__default.memo(MakerFaceMenu), MakerColorsPalleteMenu = ({}) => {
  const [d, l] = useState(!1), [s, e] = useState(0), { selectedParts: f, setSelectedParts: i } = useContext(SelectedPartsContext), a = useContext(PartsPathContext), t = useContext(PartsObjectContext), { partsObjectJimp: r, setPartsObjectJimp: o } = useContext(
    PartObjectJimpContext
  ), n = useContext(ColorsObjectContext), { selectedCategory: u, setSelectedCategory: p } = useContext(
    SelectedCategoryContext
  ), { menuPartIcons: g, setMenuPartIcons: v } = useContext(MenuPartIconsContext), x = useContext(ColorMenuPartIconsContext), [b, w] = useState(
    null
  ), [M, G] = useState(
    null
  ), [F, V] = useState(!0), [q, I] = useState(null), [_, R] = useState(null), [W, O] = useState(null), [j, U] = useState(null), [C, ae] = useState(null), [J, te] = useState(null), [$, L] = useState(null), [re, z] = useState(null), [N, ne] = useState(null), [le, he] = useState(null), [k, T] = useState(null), [B, K] = useState(null), h = useContext(NullImageContext), [c, m] = useState(!1), [D, ee] = useState(!1), [E, Q] = useState(!1), [se, Y] = useState(null), be = (P) => {
    const { colorGroup: we, partSplit: X } = P;
    G(X), w(we);
  }, [Ee, Me] = useState(!0);
  useEffect(() => {
    if (u && b && M) {
      Q(!0), Me(!0);
      const P = f.selectedColor[b], we = f.selectedColor;
      I(
        P ? P[M] ? P[M].color : P.default.color : we.none[M] ? we.none[M].color : we.none.default.color
      ), R(
        P ? P[M] ? P[M].hueReverse : P.default.hueReverse : we.none[M] ? we.none[M].hueReverse : we.none.default.hueReverse
      ), O(
        P ? P[M] ? P[M].saturationReverse : P.default.saturationReverse : we.none[M] ? we.none[M].saturationReverse : we.none.default.saturationReverse
      ), U(
        P ? P[M] ? P[M].hueGraph : P.default.hueGraph : we.none[M] ? we.none[M].hueGraph : we.none.default.hueGraph
      ), ae(
        P ? P[M] ? P[M].saturationGraph : P.default.saturationGraph : we.none[M] ? we.none[M].saturationGraph : we.none.default.saturationGraph
      ), te(
        P ? P[M] ? P[M].valueGraph : P.default.valueGraph : we.none[M] ? we.none[M].valueGraph : we.none.default.valueGraph
      ), L(
        P ? P[M] ? P[M].hueGraph.globalSlope : P.default.hueGraph.globalSlope : we.none[M] ? we.none[M].hueGraph.globalSlope : we.none.default.hueGraph.globalSlope
      ), he(
        P ? P[M] ? P[M].hueGraph.individualSlope : P.default.hueGraph.individualSlope : we.none[M] ? we.none[M].hueGraph.individualSlope : we.none.default.hueGraph.individualSlope
      ), z(
        P ? P[M] ? P[M].saturationGraph.globalSlope : P.default.saturationGraph.globalSlope : we.none[M] ? we.none[M].saturationGraph.globalSlope : we.none.default.saturationGraph.globalSlope
      ), T(
        P ? P[M] ? P[M].saturationGraph.individualSlope : P.default.saturationGraph.individualSlope : we.none[M] ? we.none[M].saturationGraph.individualSlope : we.none.default.saturationGraph.individualSlope
      ), ne(
        P ? P[M] ? P[M].valueGraph.globalSlope : P.default.valueGraph.globalSlope : we.none[M] ? we.none[M].valueGraph.globalSlope : we.none.default.valueGraph.globalSlope
      ), K(
        P ? P[M] ? P[M].valueGraph.individualSlope : P.default.valueGraph.individualSlope : we.none[M] ? we.none[M].valueGraph.individualSlope : we.none.default.valueGraph.individualSlope
      ), Q(!1);
    }
  }, [b, M]);
  const [ke, oe] = React__default.useState(!1), ce = () => {
    oe(!0);
  }, xe = () => {
    oe(!1);
  }, Ce = (P) => {
    let we = Number(P.target.value);
    Me(!1), L(we);
  }, _e = (P) => {
    let we = Number(P.target.value);
    Me(!1), z(we);
  }, Be = (P) => {
    let we = Number(P.target.value);
    Me(!1), ne(we);
  };
  useEffect(() => {
    U({
      globalSlope: $,
      individualSlope: le
    });
  }, [$, le]), useEffect(() => {
    ae({
      globalSlope: re,
      individualSlope: k
    });
  }, [re, k]), useEffect(() => {
    te({
      globalSlope: N,
      individualSlope: B
    });
  }, [N, B]), useEffect(() => {
    ee(!0);
    const P = [], we = [];
    if (u) {
      if (F)
        for (const Ze in x[u].true)
          P.push(
            x[u].true[Ze].colorGroup
          ), we.push(
            x[u].true[Ze].partSplit
          );
      else
        for (const Ze in x[u].false)
          P.push(
            x[u].false[Ze].colorGroup
          ), we.push(
            x[u].false[Ze].partSplit
          );
      const X = f.category[u].partName ? F ? x[u].true.some(
        (Ze) => Ze.colorGroup === b
      ) ? b : x[u].true[0].colorGroup : x[u].false.some(
        (Ze) => Ze.colorGroup === b
      ) ? b : x[u].false[0].colorGroup : null, de = f.category[u].partName ? F ? x[u].true.some(
        (Ze) => Ze.partSplit === M
      ) ? M : x[u].true[0].partSplit : x[u].false.some(
        (Ze) => Ze.partSplit === M
      ) ? M : x[u].false[0].partSplit : null;
      G(de), w(X);
    }
    ee(!1);
  }, [u, F, x]);
  const Fe = ((P) => {
    const we = {};
    for (const X in P) {
      const de = P[X].group;
      we[de] || (we[de] = {
        colorName: [],
        parentColor: P[X].group
      }), we[de].colorName.push(X);
    }
    return we;
  })(n);
  useEffect(() => {
    fetch("/examples/colors.json").then((P) => P.json()).then((P) => {
      const we = Object.keys(P).length;
      e(we);
    });
  }, []), useEffect(() => {
    (async () => {
      if (!(c || !u || !b || !M || Ee)) {
        m(!0);
        try {
          MakerChangingColor(
            MakerChangingColorsObject(
              f,
              i,
              b,
              M,
              F,
              q,
              _,
              W,
              j,
              C,
              J,
              u,
              t
            ),
            b,
            M,
            F,
            u,
            t,
            r,
            o,
            n,
            a,
            g,
            v,
            h
          );
        } catch (we) {
          console.error(we);
        }
        m(!1);
      }
    })();
  }, [
    q,
    _,
    W,
    j,
    C,
    J
  ]);
  const [We, Qe] = useState(null), lt = 1;
  return useEffect(() => {
    if (We !== null && We.el !== void 0) {
      const P = (we) => {
        we.deltaY !== 0 && (we.preventDefault(), We.el.scrollLeft += we.deltaY * lt);
      };
      return We.el.addEventListener("wheel", P), () => {
        We !== null && We.el !== void 0 && We.el.removeEventListener("wheel", P);
      };
    }
  }, [We]), /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: u ? /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
    /* @__PURE__ */ jsxRuntimeExports.jsx(
      "button",
      {
        className: colorShowButton,
        onClick: () => l(!d),
        children: d ? /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            className: void 0,
            src: "/pallete.png",
            alt: "Hide Face"
          }
        ) : /* @__PURE__ */ jsxRuntimeExports.jsx(
          "img",
          {
            className: void 0,
            src: "/pallete.png",
            alt: "Show Face"
          }
        )
      }
    ),
    d && /* @__PURE__ */ jsxRuntimeExports.jsxs(jsxRuntimeExports.Fragment, { children: [
      !b || !M || E ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs(
        "div",
        {
          onMouseDown: ce,
          onMouseUp: xe,
          onTouchStart: ce,
          onTouchEnd: xe,
          children: [
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: settingButton,
                name: "hueReverse",
                id: "hueReverse",
                onClick: () => {
                  Me(!1), R(!_);
                },
                children: _ ? " ON" : " OFF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsx(
              "button",
              {
                className: settingButton,
                name: "saturationReverse",
                id: "saturationReverse",
                onClick: () => {
                  Me(!1), O(!W);
                },
                children: W ? " ON" : " OFF"
              }
            ),
            /* @__PURE__ */ jsxRuntimeExports.jsxs(
              Swiper,
              {
                onSwiper: (P) => {
                  P && P !== We && Qe(P);
                },
                className: scrollBarSwiper,
                slidesPerView: "auto",
                spaceBetween: 0,
                touchRatio: s / 100,
                mousewheel: !1,
                children: [
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(SwiperSlide, { style: { width: "150px" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "H" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "range",
                        name: "hueRange",
                        min: "0",
                        max: "32",
                        value: $,
                        id: "hueRange",
                        onChange: Ce
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(SwiperSlide, { style: { width: "150px" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "S" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "range",
                        name: "saturationRange",
                        min: "0",
                        max: "48",
                        value: re,
                        id: "saturationRange",
                        onChange: _e
                      }
                    )
                  ] }),
                  /* @__PURE__ */ jsxRuntimeExports.jsxs(SwiperSlide, { style: { width: "150px" }, children: [
                    /* @__PURE__ */ jsxRuntimeExports.jsx("label", { children: "V" }),
                    /* @__PURE__ */ jsxRuntimeExports.jsx(
                      "input",
                      {
                        type: "range",
                        name: "valueRange",
                        min: "0",
                        max: "48",
                        value: N,
                        id: "valueRange",
                        onChange: Be
                      }
                    )
                  ] })
                ]
              }
            )
          ]
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: settingButton,
          name: "enableChain",
          id: "enableChain",
          onClick: () => Y(
            f.selectedColor[b][M]
          ),
          children: ""
        }
      ),
      se ? /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: settingButton,
          name: "enableChain",
          id: "enableChain",
          onClick: () => {
            I(se.color), R(se.hueReverse), O(se.saturationReverse), L(se.hueGraph.globalSlope), he(se.hueGraph.individualSlope), z(
              se.saturationGraph.globalSlope
            ), T(
              se.saturationGraph.individualSlope
            ), ne(se.valueGraph.globalSlope), K(
              se.valueGraph.individualSlope
            );
          },
          children: ""
        }
      ) : null,
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        "button",
        {
          className: settingButton,
          name: "enableChain",
          id: "enableChain",
          onClick: () => {
            Me(!1), V(!F);
          },
          children: F ? "" : ""
        }
      ),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MakerFaceMenu$1, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx(
        Swiper,
        {
          onSwiper: (P) => {
            P && P !== We && Qe(P);
          },
          className: scrollBarSwiper,
          slidesPerView: "auto",
          spaceBetween: 0,
          touchRatio: s / 300,
          mousewheel: !1,
          children: D ? null : F ? x[u].true.map(
            (P, we) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "100px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                onClick: () => be({
                  colorGroup: P.colorGroup,
                  partSplit: P.partSplit
                }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    className: `
                                ${partsImg}
                                ${P.colorGroup === b && P.partSplit === M ? partsImgSelected : ""}
                              `,
                    src: P.image,
                    alt: f.category[u] ? f.category[u].partName : ""
                  }
                )
              }
            ) }, we)
          ) : x[u].false.map(
            (P, we) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "100px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              "div",
              {
                onClick: () => be({
                  colorGroup: P.colorGroup,
                  partSplit: P.partSplit
                }),
                children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                  "img",
                  {
                    className: `${partsImg}
                                ${P.colorGroup === b && P.partSplit === M ? partsImgSelected : ""}
                              `,
                    src: P.image,
                    alt: f.category[u] ? f.category[u].partName : ""
                  }
                )
              }
            ) }, we)
          )
        }
      ),
      !b || !M ? null : /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { children: [
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Swiper,
          {
            onSwiper: (P) => {
              P && P !== We && Qe(P);
            },
            className: scrollBarSwiper,
            slidesPerView: "auto",
            spaceBetween: 0,
            touchRatio: s / 300,
            mousewheel: !1,
            children: Object.keys(Fe).map((P) => /* @__PURE__ */ jsxRuntimeExports.jsx(SwiperSlide, { style: { width: "50px" }, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
              MakerColorsButton,
              {
                colorCode: n[P].hex,
                colorName: P,
                isLoading: c,
                onClick: () => {
                  Me(!1), I(P);
                }
              },
              P
            ) }, P))
          }
        ),
        /* @__PURE__ */ jsxRuntimeExports.jsx(
          Swiper,
          {
            onSwiper: (P) => {
              P && P !== We && Qe(P);
            },
            className: scrollBarSwiper,
            simulateTouch: !1,
            slidesPerView: "auto",
            spaceBetween: 0,
            touchRatio: s / 20,
            mousewheel: !1,
            children: /* @__PURE__ */ jsxRuntimeExports.jsx("ul", { children: Object.keys(Fe).map((P) => /* @__PURE__ */ jsxRuntimeExports.jsx("div", { children: Fe[P].colorName.map(
              (we) => /* @__PURE__ */ jsxRuntimeExports.jsx(
                SwiperSlide,
                {
                  style: { width: "50px" },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    MakerColorsButton,
                    {
                      colorCode: n[we].hex,
                      colorName: we,
                      isLoading: c,
                      onClick: () => {
                        Me(!1), I(we);
                      }
                    }
                  )
                },
                we
              )
            ) }, P)) })
          }
        )
      ] })
    ] })
  ] }) : null });
}, MakerColorsMenu = () => /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx(MakerColorsPalleteMenu, {}) }), MakerWindow = () => {
  const { canvasImage: d, setCanvasImage: l } = useContext(CanvasImageContext), [s, e] = useState(0), f = async (a) => {
    let t = a[0];
    for (let n = 1; n < a.length; n++)
      t = t.composite(a[n], 0, 0);
    const r = await t.getBase64Async(Jimp.MIME_PNG), o = document.createElement("a");
    o.href = r, o.download = `avatar_${s}.png`, o.click(), e(s + 1);
  }, i = () => {
    f(d);
  };
  return /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: allObjectContainer, children: [
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: avatarImgAll, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx(MakerView, {}),
      /* @__PURE__ */ jsxRuntimeExports.jsx("button", { className: bottomButton, onClick: i, children: "" })
    ] }),
    /* @__PURE__ */ jsxRuntimeExports.jsxs("div", { className: optionMenuGroup, children: [
      /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: void 0, children: /* @__PURE__ */ jsxRuntimeExports.jsx(MakerPartsMenu$1, {}) }),
      /* @__PURE__ */ jsxRuntimeExports.jsx(MakerColorsMenu, {})
    ] })
  ] }) });
}, MakerWindow$1 = React__default.memo(MakerWindow), windowStyle = "_windowStyle_crz7h_1", loading = "_loading_crz7h_5", AvamopMaker_module = {
  windowStyle,
  loading
}, MAX_PROMISE = 20, MakerConvertPartsJimp = async (d, l, s, e, f) => {
  const i = {};
  for (const a in e.category) {
    i[a] = {
      partCount: d[a].partCount,
      partChain: d[a].partChain,
      ignoreTrigger: d[a].ignoreTrigger,
      partList: {}
    };
    for (const t in d[a.replace(/_\d+$/, "")].partList) {
      i[a].partList[t] = {
        colorGroup: d[a.replace(/_\d+$/, "")].partList[t].colorGroup,
        partOrder: d[a.replace(/_\d+$/, "")].partList[t].partOrder,
        items: {}
      };
      for (const r in d[a.replace(/_\d+$/, "")].partList[t].items)
        i[a].partList[t].items[r] = {
          bodyType: d[a.replace(/_\d+$/, "")].partList[t].items[r].bodyType,
          enableColor: d[a.replace(/_\d+$/, "")].partList[t].items[r].enableColor,
          faces: {}
        }, await asyncMap(
          Object.keys(
            d[a.replace(/_\d+$/, "")].partList[t].items[r].faces
          ),
          async (o) => {
            let n;
            d[a.replace(/_\d+$/, "")].partList[t].items[r].faces[o].imagePath == "" ? n = s : n = await partRead(
              l + d[a.replace(/_\d+$/, "")].partList[t].items[r].faces[o].imagePath,
              d[a.replace(/_\d+$/, "")].partList[t].colorGroup,
              e,
              f,
              t
            ), i[a].partList[t].items[r].faces[o] = {
              jimpData: n
            };
          }
        );
    }
  }
  return i;
}, partRead = async (d, l, s, e, f) => {
  try {
    const i = await Jimp.read(d);
    return await MakerPartsColoring(
      i,
      f,
      l,
      s,
      e
    );
  } catch (i) {
    console.log(":" + i);
    return;
  }
}, asyncMap = async (d, l, s = MAX_PROMISE) => {
  const e = d.slice(), f = new Array(d.length), i = new Array(s).fill(Promise.resolve()), a = (t) => {
    if (e.length) {
      const r = e.shift();
      return l(r).then((o) => (f[t] = o, a(t)));
    }
  };
  return await Promise.all(i.map(a)), f;
}, FacePresetsContext = createContext({
  face: "clear",
  image: "",
  children: []
}), WindowWidthContext = createContext(
  /*window.innerWidth*/
  720
), MakerSelectedPartsGen = (d, l) => {
  const s = {
    bodyType: null,
    face: "clear",
    category: {},
    selectedColor: {},
    selectedFace: {}
  }, e = d.body.partList.body.items[Object.keys(d.body.partList.body.items)[0]].bodyType;
  try {
    if (e) {
      if (e.length > 1)
        throw new Error(":bodybodyType");
      s.bodyType = Object.keys(
        d.body.partList.body.items
      )[0];
    } else
      throw new Error(":bodybodyType");
  } catch (f) {
    console.error(f);
  }
  for (const f in d) {
    const { partList: i, partCount: a } = d[f], t = Object.keys(i);
    for (let r = 0; r < a; r++) {
      const o = t[0];
      let n = 0;
      d[f].partList[o].items;
      for (const g in d[f].partList[o].items) {
        let v = d[f].partList[o].items[g].bodyType;
        if (v === null || Array.isArray(v) && v.includes(s.bodyType))
          break;
        n++;
      }
      let u;
      const p = MakerSearchIgnoreTrigger(
        d,
        f
      );
      p && p.some(
        (g) => s.category.hasOwnProperty(g)
      ) ? u = "" : u = Object.keys(d[f].partList[o].items)[n];
      {
        const g = {
          partName: u,
          partFlip: !1
        };
        s.category[a === 1 ? f : `${f}_${r + 1}`] = g;
      }
    }
  }
  for (const f in l)
    s.selectedColor[f] = l[f];
  for (const f in d)
    s.selectedFace[f] = "clear";
  return console.log(s), s;
}, MakerFaceGen = (d) => {
  let l = [];
  if (l.push({ face: d.face, image: d.image }), d.children.length > 0)
    for (let s of d.children)
      l = l.concat(MakerFaceGen(s));
  return l;
}, MakerCanvasSelectedPartsGen = (d, l, s) => {
  const e = {
    bodyType: d.bodyType,
    face: d.face,
    category: {},
    selectedColor: d.selectedColor,
    selectedFace: d.selectedFace
  }, f = {};
  for (const i in d.category) {
    let a = {};
    for (const t in l[i].partList)
      a[t] = {
        enableColor: d.category[i].partName != "" ? l[i].partList[t].items[d.category[i].partName].enableColor : !1,
        colorGroup: l[i].partList[t].colorGroup,
        partOrder: l[i].partList[t].partOrder,
        partData: d.category[i].partName != "" ? l[i].partList[t].items[d.category[i].partName].faces[d.selectedFace[i]] ? l[i].partList[t].items[d.category[i].partName].faces[d.selectedFace[i]].jimpData : l[i].partList[t].items[d.category[i].partName].faces.clear.jimpData : s
      };
    f[i] = {
      partSplit: a,
      partFlip: d.category[i].partFlip
    };
  }
  return e.category = selectedPartsForCanvasSort(
    f
  ), e;
}, selectedPartsForCanvasSort = (d) => {
  let l = [];
  for (const t in d)
    for (const r in d[t].partSplit)
      l.push({
        category: t,
        partSplit: r,
        partOrder: d[t].partSplit[r].partOrder
      });
  l.sort((t, r) => {
    if (t.partOrder === r.partOrder) {
      const o = Number(
        t.category.match(/_(\d+)$/) ? t.category.match(/_(\d+)$/)[1] : 0
      ), n = Number(
        r.category.match(/_(\d+)$/) ? r.category.match(/_(\d+)$/)[1] : 0
      );
      return o - n;
    }
    return t.partOrder - r.partOrder;
  });
  let s = 0, e = 0, f = 0, i = null;
  for (let t = 0; t < l.length; t++) {
    let r = l[t].category.split("_")[0], o = l[t].partOrder;
    i && r === i ? s++ : i && r !== i && (e = e + s, s = 0), l[t].partOrder = o + f + e + s, i = r;
  }
  let a = {};
  for (let t = 0; t < l.length; t++) {
    let r = l[t].category, o = l[t].partSplit;
    a[r] || (a[r] = {
      partSplit: {},
      partFlip: d[r].partFlip
    }), a[r].partSplit[o] = {
      enableColor: d[r].partSplit[o].enableColor,
      colorGroup: d[r].partSplit[o].colorGroup,
      partOrder: l[t].partOrder,
      partData: d[r].partSplit[o].partData
    };
  }
  return a;
}, SelectedPartsForCanvasContext = createContext(null), MakerLayerCombineParts = async (d) => {
  let l = [];
  for (const e in d.category)
    for (const f in d.category[e].partSplit)
      l.push({
        category: e,
        partSplit: f,
        partOrder: d.category[e].partSplit[f].partOrder,
        partData: d.category[e].partSplit[f].partData
      });
  l.sort((e, f) => e.partOrder - f.partOrder);
  const s = [];
  for (let e = 0; e < l.length; e++)
    s.push(l[e].partData);
  return s;
}, MakerGroupingParts = (d, l) => {
  let s = {};
  return Object.keys(
    d.category[l].partSplit
  ).forEach((e) => {
    let f = d.category[l].partSplit[e].colorGroup;
    s[f] || (s[f] = []), s[f].push(e);
  }), s;
}, AvamopMaker = ({
  partsPath: d,
  facePath: l,
  partsObject: s,
  colorsObject: e,
  defaultColors: f,
  defaultAvaters: i,
  facePresets: a,
  nullImagePath: t
}) => {
  const [r, o] = useState(null), [n, u] = useState(null), [p, g] = useState(null), [v, x] = useState(null), [b, w] = useState(null), [M, G] = useState(
    i || MakerSelectedPartsGen(s, f)
  ), [F, V] = useState(1280), [q, I] = useState(F < 480 ? 1 : 2), [_, R] = useState(null), [W, O] = useState(!0), [j, U] = useState(!0), [C, ae] = useState(!0), [J, te] = useState(!0), [$, L] = useState(!0), [re, z] = useState(null), N = MakerFaceGen(a);
  return useEffect(() => {
    (async () => {
      const le = await Jimp.read(d + t);
      o(le), O(!1);
    })();
  }, []), useEffect(() => {
    (async () => {
      if (!W && r != null && n == null) {
        const le = await MakerConvertPartsJimp(
          s,
          d,
          r,
          M,
          e
        );
        u(le), U(!1);
      }
    })();
  }, [W, M]), useEffect(() => {
    (async () => {
      if (!j && n != null && te) {
        const le = await MakerConvertPartsToMenuIcons(n);
        g(await le), te(!1);
      }
    })();
  }, [j]), useEffect(() => {
    (async () => {
      if (!j && n != null) {
        const le = await MakerCanvasSelectedPartsGen(
          M,
          n,
          r
        );
        R(await le), ae(!1);
      }
    })();
  }, [j, M, n]), useEffect(() => {
    (async () => {
      if (_ != null) {
        const le = await MakerLayerCombineParts(
          _
        );
        z(le);
      }
    })();
  }, [_]), useEffect(() => {
    (async () => {
      if (_ != null) {
        const le = Object.keys(_.category), he = [!0, !1];
        let k = {};
        for (let T of le) {
          k[T] = {
            true: [],
            false: []
          };
          for (let B of he)
            if (B) {
              const K = MakerGroupingParts(
                _,
                T
              ), h = Object.keys(K);
              for (let c of h) {
                let m = K[c];
                const D = [];
                for (let ee = 0; ee < m.length; ee++) {
                  let E = m[ee];
                  s[T].partList[E].items[M.category[T].partName] && s[T].partList[E].items[M.category[T].partName].faces && (s[T].partList[E].items[M.category[T].partName].faces[M.selectedFace[T]] ? _.category[T].partSplit[E].enableColor && s[T].partList[E].items[M.category[T].partName].faces[M.selectedFace[T]].imagePath != null && s[T].partList[E].items[M.category[T].partName].faces[M.selectedFace[T]].imagePath != "" && _.category[T].partSplit[E] && D.push({
                    jimp: _.category[T].partSplit[E].partData.clone(),
                    partOrder: _.category[T].partSplit[E].partOrder
                  }) : _.category[T].partSplit[E].enableColor && s[T].partList[E].items[M.category[T].partName].faces.clear.imagePath != null && s[T].partList[E].items[M.category[T].partName].faces.clear.imagePath != "" && _.category[T].partSplit[E] && D.push({
                    jimp: _.category[T].partSplit[E].partData.clone(),
                    partOrder: _.category[T].partSplit[E].partOrder
                  }));
                }
                if (D.length > 0) {
                  D.sort((Q, se) => Q.partOrder - se.partOrder);
                  let ee = D[0].jimp;
                  for (let Q = 1; Q < D.length; Q++)
                    ee = ee.composite(D[Q].jimp, 0, 0);
                  const E = await MakerConvertBase64(
                    await MakerPartIconsTrim(ee, 64)
                  );
                  k[T].true.push({
                    image: E,
                    colorGroup: c,
                    partSplit: "default"
                  });
                }
              }
            } else {
              const K = Object.keys(
                _.category[T].partSplit
              );
              for (let h of K)
                if (s[T].partList[h].items[M.category[T].partName] && s[T].partList[h].items[M.category[T].partName].faces) {
                  if (s[T].partList[h].items[M.category[T].partName].faces[M.selectedFace[T]]) {
                    if (_.category[T].partSplit[h].enableColor && s[T].partList[h].items[M.category[T].partName].faces[M.selectedFace[T]].imagePath != null && s[T].partList[h].items[M.category[T].partName].faces[M.selectedFace[T]].imagePath != "" && _.category[T].partSplit[h]) {
                      const c = await MakerConvertBase64(
                        await MakerPartIconsTrim(
                          _.category[T].partSplit[h].partData.clone(),
                          64
                        )
                      );
                      k[T].false.push({
                        image: c,
                        colorGroup: _.category[T].partSplit[h].colorGroup,
                        partSplit: h
                      });
                    }
                  } else if (_.category[T].partSplit[h].enableColor && s[T].partList[h].items[M.category[T].partName].faces.clear.imagePath != null && s[T].partList[h].items[M.category[T].partName].faces.clear.imagePath != "" && _.category[T].partSplit[h]) {
                    const c = await MakerConvertBase64(
                      await MakerPartIconsTrim(
                        _.category[T].partSplit[h].partData.clone(),
                        64
                      )
                    );
                    k[T].false.push({
                      image: c,
                      colorGroup: _.category[T].partSplit[h].colorGroup,
                      partSplit: h
                    });
                  }
                }
            }
        }
        x(k), L(!1);
      }
    })();
  }, [_]), /* @__PURE__ */ jsxRuntimeExports.jsx(jsxRuntimeExports.Fragment, { children: /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: windowStyle, children: W || j || J || $ || C ? /* @__PURE__ */ jsxRuntimeExports.jsx("div", { className: loading }) : /* @__PURE__ */ jsxRuntimeExports.jsx(PartsPathContext.Provider, { value: d, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FacePathContext.Provider, { value: l, children: /* @__PURE__ */ jsxRuntimeExports.jsx(PartsObjectContext.Provider, { value: s, children: /* @__PURE__ */ jsxRuntimeExports.jsx(NullImageContext.Provider, { value: r, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
    PartObjectJimpContext.Provider,
    {
      value: { partsObjectJimp: n, setPartsObjectJimp: u },
      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
        MenuPartIconsContext.Provider,
        {
          value: { menuPartIcons: p, setMenuPartIcons: g },
          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
            ColorMenuPartIconsContext.Provider,
            {
              value: v,
              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                SelectedCategoryContext.Provider,
                {
                  value: { selectedCategory: b, setSelectedCategory: w },
                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(ColorsObjectContext.Provider, { value: e, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FaceListContext.Provider, { value: N, children: /* @__PURE__ */ jsxRuntimeExports.jsx(FacePresetsContext.Provider, { value: a, children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                    SelectedPartsContext.Provider,
                    {
                      value: { selectedParts: M, setSelectedParts: G },
                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                        SelectedPartsForCanvasContext.Provider,
                        {
                          value: {
                            selectedPartsForCanvas: _,
                            setSelectedPartsForCanvas: R
                          },
                          children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                            WindowWidthContext.Provider,
                            {
                              value: F,
                              children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                ViewScaleContext.Provider,
                                {
                                  value: q,
                                  children: /* @__PURE__ */ jsxRuntimeExports.jsx(
                                    CanvasImageContext.Provider,
                                    {
                                      value: {
                                        canvasImage: re,
                                        setCanvasImage: z
                                      },
                                      children: /* @__PURE__ */ jsxRuntimeExports.jsx(MakerWindow$1, {})
                                    }
                                  )
                                }
                              )
                            }
                          )
                        }
                      )
                    }
                  ) }) }) })
                }
              )
            }
          )
        }
      )
    }
  ) }) }) }) }) }) });
};
export {
  AvamopMaker as default
};
